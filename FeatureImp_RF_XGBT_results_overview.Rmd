---
title: "RF and XGBT : Features used"
author: "Florian Huber, Leonard Dubois"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
---

# Setup

```{r setup}
# function to check if a package is installed, if so, load it, else install and then load it
source("./R/ipak.R")
# set chunk options and load libraries
source("./setup.R")

ipak(randomForest)
ipak(xgboost)
ipak(kableExtra)
ipak(ggrepel)
ipak(gplots)

# custom functions
walk(list.files("./R", pattern = "*.R", full.names = T), source)
```


```{r}
install.packages("DALEX")
install.packages("live") 
install.packages("auditor")
install.packages("lime") 
install.packages("mlr") 
devtools::install_github("redichh/shapleyr")y


```

# Analysis

## Loading results

Hyperparameter grid for RF was :
- `ntree` (number of trees) : 200, 500
- `mtry` : p, p*(3/4), p/2, p/4, sqrt(p)

Hyperparameter grid for XGBT was :
- `nrounds` (number of trees) : 200, 500
- `max_depth` : 1, 2, 3
- `eta` (learning rate) : 0.01, 0.1, 0.5

```{r}
load("./run_results_from_server/result_RF_10pc_allDrugs_tuneMMCE.RData")
load("./run_results_from_server/result_XGBT_10pc_allDrugs_tuneMMCE.RData")
load("./data/the_matrix_allDrugs_top10pct.RData")
load("../dbsetup/data/genesWithEG_ID.RData")
```

Focus only on these two, mainly because RF is really better with 10% top variance and MMCE tuning so 
one should use the exact same results set for XGBT. 


## Feature importance of DNA Prediction

### Most important features - approach 1

Top features are usually based on average decrease in node impurity. 

First "try" to assess feature importance : Take the top 10 features in each model (top 10% variance, 
all drugs used, tuning hyperparamter based on MMCE, RF *and* XGBT).

Then have a look at the intersection and union of these sets of top 10 features.

Can test the same with other values, top15, top20 features ...

```{r}
# modified the function, it now returns both the plot (as a recordedplot instance) and the 
# feature importance vector
feat_RF_dna <- plot_feat_4model(res = result_RF_10pc_allDrugs_tuneMMCE, moa = "dna")
save_baseplot(filename = "./plots/feature_importance_dna_rf.pdf", width = 10, height = 15, 
              plot = feat_RF_dna$plot)

# make data frame for alternative way of plotting:
feat_RF_dna_dfr <- make_importance_dfr(feat_RF_dna, cutoff = 0.07)
plot_importance(feat_RF_dna_dfr, moa = "dna")
ggsave("./plots/present_feat_imp_rf_dna.pdf", width = 7, height = 5)


feat_XGBT_dna = plot_feat_4model(res = result_XGBT_10pc_allDrugs_tuneMMCE, moa = "dna")
save_baseplot(filename = "./plots/feature_importance_dna_xgbt.pdf", width = 10, height = 15, 
              plot = feat_XGBT_dna$plot)
feat_xgbt_dfr <- make_importance_dfr(feat_XGBT_dna, cutoff = 0.07)
plot_importance(feat_xgbt_dfr, moa = "dna")
ggsave("./plots/present_feat_imp_xgbt_dna.pdf", width = 7, height = 5)

# # check overlap between the 10 most important features
# a = names(sort(feat_RF_dna$features, decreasing = T)[1:10])
# b = names(sort(feat_XGBT_dna$features, decreasing = T)[1:10])
# 
# #If value is 2, feature in core features set, if 1, feature in pan features set
# feat_dna = sort(table(c(a,b)), decreasing = T)
# feat_dna
```

This was just for demonstration. Now simply create lists containing the genes with a certain 
cutoff that are either unique to a mode of action or shared between all possible pairs/triples/
quadruples. We'll omit membrane_stress here because it's currently still making troubles in the 
prediction. I will also only use random forests for now. 

```{r}
my_cutoff <- 0.05 # arbitrary
my_moas <- c("dna", "cell_wall", "protein_synthesis")

# collect data frames in a list
important_rf_feats <- sapply(my_moas, function(x) {
   res <- plot_feat_4model(res = result_RF_10pc_allDrugs_tuneMMCE, moa = x)
   save_baseplot(filename = paste0("./plots/feature_importance_", x, "_rf.pdf"), width = 10, height = 15, plot = res$plot)
   res <- make_importance_dfr(res, cutoff = my_cutoff)
   plot_importance(res, moa = x)
   ggsave(paste0("./plots/present_feat_imp_rf_", x, ".pdf"), width = 7, height = 5)
   res <- res[nchar(res$label) > 0, c("label", "importance")]
   return(res)
}, simplify = FALSE, USE.NAMES = TRUE)

# add gene description
important_rf_feats <- lapply(important_rf_feats, left_join, genes, by = c("label" = "gene_synonym"))

#### to fix - doesn't make sense right now - probably need to compile notebook
# # let's have a look
# View(important_rf_feats$dna[, c("label", "importance", "name")])
# kable(important_rf_feats$dna[, c("label", "importance", "name")], "html") %>%
#    kable_styling()

```



### Most important features - approach 2

Order features in each model, make the sum of ranks for each feature and reorder it.

```{r}
feat_RF_dna = sort(feat_RF_dna$features, decreasing = T)
feat_XGBT_dna = sort(feat_XGBT_dna$features, decreasing = T)

res = numeric(length(feat_RF_dna))
names(res) = names(feat_RF_dna)
res = sapply(names(res), function(x){ 
    which(names(feat_RF_dna) == x) + which(names(feat_XGBT_dna) == x)
    })
res = sort(res)
```


### Most important features - approach 3

Scale each feature list inside a given model, make sum of scaled values and take only those which 
are above 0.

```{r}
feat_RF_dna_scaled = scale(feat_RF_dna)
feat_XGBT_dna_scaled = scale(feat_XGBT_dna)

features_scaled = cbind(feat_RF_dna_scaled, feat_XGBT_dna_scaled)
sum_of_scales <- apply(features_scaled, 1, sum)
sum_of_scales[sum_of_scales > 0]
```

We end with a thirty-one-feature set. Plot distribution across MoA and names from the genes table of DBsetup.


### Most important features - visualise feature distributions

```{r}
for (f in names(sum_of_scales[sum_of_scales > 0])) {
    feature_distrib(m = the_matrix_allDrugs_top10pct, feature = f)
}
```

For presentation: save the feature distributions selected above (`important_rf_feats`).

```{r}
features_of_interest <- do.call(c, lapply(important_rf_feats, `[[`, "label"))
plotlist <- lapply(features_of_interest, feature_distrib_ggplot, dfr = the_matrix_allDrugs_top10pct, save = FALSE)

graphics.off()
pdf("./plots/present_sscore_dists.pdf", width = 7, height = 6)
stopifnot(dev.cur() != 1)
invisible(lapply(plotlist, print))
dev.off()

```


Plot heatmap to see how hierarchical clustering compares to our classification. 

```{r}
# trying to get a heatmap done using heatmap.2 function from package gplots 
# see http://sebastianraschka.com/Articles/heatmaps_in_r.html - contains all you need to know
library(gplots)
library(RColorBrewer)
# e.g.:
# m <- as.matrix(mtcars)
# mdist <- as.dist(1 - abs(cor(m)))
# heatmap.2(m, trace = "none", 
#           Colv = as.dendrogram(hclust(mdist)), # changes ordering of columns accordingly 
#           ColSideColors = c(rep("black", 5), rep("blue", 6))) # order as in the original matrix

plot_heatmap(m = the_matrix_allDrugs_top10pct, feats_to_keep = genes$gene_synonym, 
             filename = "heatmap_cordist_all.pdf")
# exclude SlogP:
features_of_interest <- features_of_interest[features_of_interest != "SlogP"]
# now with only the 'relevant' features:
plot_heatmap(m = the_matrix_allDrugs_top10pct, feats_to_keep = features_of_interest, 
             filename = "heatmap_cordist_most_imprtnt_rf.pdf")

```




#### Function to extract feature importances

We do the scale sum method for each MoA and have a look at the union of all MoA. How many features 
are in common across how many MoA ?

```{r}
get_main_features = function(res1, res2, moa){
    feat1 = plot_feat_4model(res = res1, moa = moa)
    feat2 = plot_feat_4model(res = res2, moa = moa)
    
    feat1 = scale(feat1$features)
    feat2 = scale(feat2$features)
    
    feat1 = feat1[rownames(feat2), ]
    a = cbind(feat1, feat2)
    a = apply(a, 1, sum)
    a = sort(a, decreasing = T)
    res = a[a > 0]
    res 
}

moas <- c("dna", "cell_wall", "membrane_stress", "protein_synthesis")

main_features <- sapply(moas, get_main_features, res1 = result_RF_10pc_allDrugs_tuneMMCE, 
                        res2 = result_XGBT_10pc_allDrugs_tuneMMCE, simplify = FALSE, USE.NAMES = TRUE)

(overview <- sort(table(do.call(c, sapply(main_features, names))), decreasing = TRUE))
```

Extracting gene names and testing them in a panther analysis BP-Slim give only one overrepresented 
significant ontology : response to toxic substance.


### Probing interaction between features

Try to visualize interaction and correlation beetween two features in one MoA compared to the others.

Maybe for some features couples, the correlation is really different inside one MoA

```{r fig.height=5, fig.width=5}

plot_interaction = function(feat1, feat2, dt = the_matrix_allDrugs_top10pct){
    
    set_Moa = c("dna", "cell_wall", "membrane_stress", "protein_synthesis" )
    colMoa = rainbow(length(set_Moa))
    names(colMoa) = set_Moa
    a = list()
    
    for(m in set_Moa){
        a[[m]] = filter(dt, process_broad == m) %>% select(feat1, feat2)
    }
    
    plot(a[[set_Moa[1]]], pch = 21, col = "black", bg = colMoa[1], xlim = c(min(unlist(a)), max(unlist(a))),
         ylim = c(min(unlist(a)), max(unlist(a))), cex = 1.5 )
    abline(coef = (line(a[[set_Moa[1]]]))$coefficients, lwd = 2, col = colMoa[1])
    
    for(m in 2:(length(set_Moa))){
        
        points(a[[set_Moa[m]]],  pch = 21, col = "black", bg = colMoa[m], cex = 1.5)
        abline(coef = (line(a[[set_Moa[m]]]))$coefficients, lwd = 2, col = colMoa[m])
    }
    legend("bottomright", legend=set_Moa,
       col=colMoa, lty=1, lwd = 3)
}

# Is it really an interaction plot or is it smthing else ?
#No interaction ?
plot_interaction(feat1 = "DAM", feat2= "FRE")
plot_interaction_moa(feat1 = "DAM", feat2= "FRE", moa = "dna")
# Interaction ?
plot_interaction(feat1 = "RECC", feat2= "RECA")
plot_interaction_moa(feat1 = "RECC", feat2= "RECA", moa = "dna")

#   Meaning : the relative effect of RECC on RECA is depending with the fact it's a DNA targeting drug or not ?
# Interaction beetween effect of RECC on RECA and dna target or not


plot_interaction_moa = function(feat1, feat2, dt = the_matrix_allDrugs_top10pct, moa = "dna"){
    x1 = filter(dt, process_broad == moa) %>% select(feat1, feat2)
    x2 = filter(dt, process_broad != moa) %>% select(feat1, feat2)
    
    plot(x1, pch = 21,  bg = "blue", xlim = c(min(x1[,1], x2[,1]), max(x1[,1], x2[,1])),
         ylim = c(min(x1[,2], x2[,2]), max(x1[,2], x2[,2])),  cex = 1.5 )
    abline(coef = (line(x1))$coefficients, lwd = 2, col = "blue")
    
    points(x2,  pch = 21, bg = "orange", cex = 1.5)
    abline(coef = (line(x2))$coefficients, lwd = 2, col = "orange")

    legend("bottomright", legend=c(moa, paste0("not_",moa)),
       col=c("blue", "orange"), lty=1, lwd = 3)
}


correlation_moa = function(feat1, feat2, dt = the_matrix_allDrugs_top10pct){
    set_Moa = c("dna", "cell_wall", "membrane_stress", "protein_synthesis" )

    res = c()
    for(m in set_Moa){
        a = filter(dt, process_broad == m) %>% select(feat1, feat2)
        res = c(res, cor(a[,1], a[,2]))
    }
    names(res) = set_Moa
    return(res)
}
```

Time to screen
In fact not really clever to run it, will generate thousand of plot
Look at the difference in line slopes ? take genes couples with the biggest difference ?


```{r}
for (f1 in names(overview)){
    for (f2 in names(overview)) {
        if(f1 != f2)
            plot_interaction(feat1 = f1, feat2 = f2)
    }
}

#Get rid of chemical feat
corFeat = data.frame(matrix(ncol = 4, nrow = 0))
colnames(corFeat) = c("dna", "cell_wall", "membrane_stress", "protein_synthesis" ) 
for (f1 in names(overview)[-c(14, 17, 39, 54 )]){
    for (f2 in names(overview)[-c(14, 17, 39, 54 )]) {
        if(f1 != f2)
            corFeat[paste0(f1, " * ", f2), ] = correlation_moa(feat1 = f1, feat2 = f2)
    }
}

stripchart(abs(corFeat), pch = 21, bg = "orange", method = "jitter")
```



Screen all first order interaction beetween features and plot the distribution of coefficients.
Most of them are (nearly) equal to zero but there's still some which are significants outliers.

Problem to fix cutoff of pvalue (not a new problem) : 0.05 takes to much interaction as significant and Bonferroni correction is too much, none left...


```{r}
data_matrix = the_matrix_allDrugs_top10pct
moa = "dna"

custom_matrix = data_matrix %>% mutate(process_broad = replace(process_broad, process_broad != moa, paste0("not_", moa)))
custom_matrix$process_broad = factor(custom_matrix$process_broad, levels = c(moa, paste0("not_", moa)))


interFeat = data.frame(matrix(ncol = 1, nrow = 0))
for (f1 in names(overview)){
    for (f2 in names(overview)) {
        if(f1 != f2){
            x = glm(custom_matrix$process_broad ~ custom_matrix[ ,f1] * custom_matrix[ ,f2], family = binomial)
            #Pvalue
            interFeat[paste0(f1, " * ", f2), ] = (summary(x))$coefficients[2,4]
            #Coefficient 
            #interFeat[paste0(f1, " * ", f2), ] = x$coefficients[4] 
        }
    }
}

hist(as.matrix(interFeat), breaks = 50, col = "orange")
```

# Ultimate plot

```{r}
ultimate_plot(res =result_XGBT_10pc_allDrugs_tuneMMCE)

pdf(file = "~/Documents/recap_utlimate.pdf", width = 20, height = 30)
layout(matrix(seq(1,6), 3,2, byrow = T))
for(d in the_matrix_allDrugs$drugname_typaslab){
    distrib_drug_prob_small(res = result_RF_10pc_allDrugs_tuneMMCE, drug = d, dt_matrix = the_matrix_allDrugs)
    distrib_drug_prob_small(res = result_RF_5pc_allDrugs_tuneMMCE, drug = d, dt_matrix = the_matrix_allDrugs)
    distrib_drug_prob_small(res = result_XGBT_10pc_allDrugs_tuneMMCE, drug = d, dt_matrix = the_matrix_allDrugs)
    distrib_drug_prob_small(res = result_XGBT_5pc_allDrugs_tuneMMCE, drug = d, dt_matrix = the_matrix_allDrugs)
    distrib_drug_prob_small(res = result_XGBT_10topWilcox_allDrugs_tuneMMCE, drug = d, dt_matrix = the_matrix_allDrugs)
    distrib_drug_prob_small(res = result_RF_27feat_allDrugs_tuneMMCE, drug = d, dt_matrix = the_matrix_allDrugs)
}
dev.off()

```



