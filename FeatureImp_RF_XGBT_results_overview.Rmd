---
title: "RF and XGBT : Features used"
author: "Florian Huber, Leonard Dubois"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
---

# Setup, library loading

This part is the general setup, whichever model we are using.

```{r setup}
knitr::opts_chunk$set(echo = T)
knitr::opts_chunk$set(message = T)
knitr::opts_chunk$set(warning = F)
knitr::opts_chunk$set(error = T)
knitr::opts_chunk$set(cache = F)
Sys.setlocale("LC_ALL", "en_IE.UTF-8")

library(tidyverse)
library(mlr)
library(randomForest)
library(xgboost)


#Custom functions
walk(list.files("./R", pattern = "*.R", full.names = T), source)

```

# Results loading

Hyperparameter grid for RF was :
- `ntree` (number of trees) : 200,500
- `mtry` : p, p*(3/4), p/2, p/4, sqrt(p)

Hyperparameter grid for XGBT was :
- `nrounds` (number of trees) : 200,500
- `max_depth` : 1,2,3
- `eta` (learning rate) : 0.01, 0.1, 0.5

```{r}
load("./run_results_from_server/result_RF_10pc_allDrugs_tuneMMCE.RData")
load("./run_results_from_server/result_XGBT_10pc_allDrugs_tuneMMCE.RData")
load("./data/the_matrix_allDrugs_top10pct.RData")
load("../dbsetup/data/genesWithEG_ID.RData")
```

Focus only on these two, mainly because RF is really better with 10% top variance and MMCE tuning so one should use the exact same results set for XGBT

# DNA Prediction - Features importance

First "try" to assess feature importance : Take the top 10 features in each model (top 10% variance, all Drugs used, tuning hyperparamter based on MMCE, RF *and* XGBT )

Then have a look at the intersection and union of these sets of top 10 features

Can test the same with other values, top15, top20 features...
```{r}
feat_RF_dna = plot_feat_4model(res = result_RF_10pc_allDrugs_tuneMMCE, moa = "dna")
feat_XGBT_dna = plot_feat_4model(res = result_XGBT_10pc_allDrugs_tuneMMCE, moa = "dna")

a = names(sort(feat_RF_dna, decreasing = T)[1:10])
b = names(sort(feat_XGBT_dna, decreasing = T)[1:10])

#If value is 2, feature in core features set, if 1, feature in pan features set
feat_dna = sort(table(c(a,b)), decreasing = T)
feat_dna
```


## Test sum of ranks

Second try, order features in each model, make the sum of ranks for each feature and reorder it.

```{r}
feat_RF_dna = sort(feat_RF_dna, decreasing = T)
feat_XGBT_dna = sort(feat_XGBT_dna, decreasing = T)

res = rep(0, length(feat_RF_dna))
names(res) = names(feat_RF_dna)
res =lapply(names(res), function(x){ 
    which(names(feat_RF_dna) == x) + which(names(feat_XGBT_dna) == x)
    } )
names(res) = names(feat_RF_dna)
res = sort(unlist(res))
```

## Test scale sum

Third try, scale each feature list inside a given model, make sum of scaled values and take only those which are above 0.


```{r}
feat_RF_dna = scale(feat_RF_dna)
feat_XGBT_dna = scale(feat_XGBT_dna)

feat_RF_dna = feat_RF_dna[rownames(feat_XGBT_dna), ]

a = cbind(feat_RF_dna, feat_XGBT_dna)
a = apply(a, 1, sum)
a = sort(a, decreasing = T)
feat_dna = a[a > 0]
```

We end with a thirty-one-feature set. Plot distribution across MoA and names from the genes table of DBsetup.

### Visualise Features distribution

```{r}
for (f in names(feat_dna)) {
    feature_distrib(m = the_matrix_allDrugs_top10pct, feature = f )
}

filter(genes, gene_synonym %in% names(feat_dna)) %>% select(gene_synonym, name)

```



## Function to extract feat imp

We do the scale sum method for each MoA and have a look at the union of all MoA. How many features are in common across how many MoA ?

```{r}

get_main_features = function(res1, res2, moa){
    
    feat1 = plot_feat_4model(res = res1, moa = moa)
    feat2 = plot_feat_4model(res = res2, moa = moa)
    
    feat1 = scale(feat1)
    feat2 = scale(feat2)
    
    feat1 = feat1[rownames(feat2), ]
    a = cbind(feat1, feat2)
    a = apply(a, 1, sum)
    a = sort(a, decreasing = T)
    res = a[a > 0]
    res 
}

feat_dna = get_main_features(res1 = result_RF_10pc_allDrugs_tuneMMCE, res2 = result_XGBT_10pc_allDrugs_tuneMMCE, moa = "dna")
feat_cell_wall = get_main_features(res1 = result_RF_10pc_allDrugs_tuneMMCE, res2 = result_XGBT_10pc_allDrugs_tuneMMCE, moa = "cell_wall")
feat_membrane_stress = get_main_features(res1 = result_RF_10pc_allDrugs_tuneMMCE, res2 = result_XGBT_10pc_allDrugs_tuneMMCE, moa = "membrane_stress")
feat_protein_synthesis = get_main_features(res1 = result_RF_10pc_allDrugs_tuneMMCE, res2 = result_XGBT_10pc_allDrugs_tuneMMCE, moa = "protein_synthesis")

overview = sort(table(names(c(feat_protein_synthesis, feat_membrane_stress, feat_cell_wall, feat_dna))), decreasing = T)
overview
```

Extracting gene names and testing them in a panther analysis BP-Slim give only one overrepresented significant ontology : response to toxic substance.

# Hierarchical Clustering based on sumScaled selected Features

```{r}
color_moa = c(rainbow(4), rep("black", 3))
names(color_moa) = c("dna", "cell_wall", "membrane_stress", "protein_synthesis", "protein_qc", "oxidative_stress", "pmf")
    

# Heatmap with 30 top features
dt = select(the_matrix_allDrugs, names(overview)[1:28])
dt_matrix = as.matrix(dt)
rownames(dt_matrix) = paste0(the_matrix_allDrugs$process_broad, "\t - ",the_matrix_allDrugs$drugname_typaslab)
colPal = colorRampPalette(c("blue","white", "red"), space="rgb") 
heatmap(dt_matrix, scale="column", col = colPal(50), RowSideColors = color_moa[the_matrix_allDrugs[, "process_broad"]])



# Hclust of correlation based distance beetween drugs
dt = select(the_matrix_allDrugs, names(overview)[1:28])
dt_matrix = cor(t(dt))
dt_matrix = 1 - dt_matrix
dt_matrix = as.dist(dt_matrix)
hc = hclust(dt_matrix)
dend = as.dendrogram(hc, hang = 0.1)
    
labels_colors(dend) <- color_moa[the_matrix_allDrugs[order.dendrogram(dend), "process_broad"]]
par(mar = c(3,2,2,10)) 
dend_fp %>%
    set("labels_cex", 0.7) %>%
    set("branches_lwd", 1.5) %>%
    plot(horiz = T, cex = 0.5)



# Heatmap with all features
dt = select(the_matrix_allDrugs, -drugname_typaslab, -process_broad)
dt_matrix = as.matrix(dt)
rownames(dt_matrix) = paste0(the_matrix_allDrugs$process_broad, "\t - ",the_matrix_allDrugs$drugname_typaslab)
colPal = colorRampPalette(c("blue","white", "red"), space="rgb") 
heatmap(dt_matrix, scale="column", col = colPal(50), RowSideColors = color_moa[the_matrix_allDrugs[, "process_broad"]])





################################################################################

library(dendextend)

dist_matrix = dist(dt_matrix, method = "euclidian")
    
hclust_fp = hclust(dist_matrix)
dend_fp = as.dendrogram(hclust_fp, hang = 0.1)
    
labels_colors(dend_fp) <- color_moa[the_matrix_allDrugs[order.dendrogram(dend_fp), "process_broad"]]
par(mar = c(3,2,2,10)) 
dend_fp %>%
    set("labels_cex", 0.7) %>%
    set("branches_lwd", 1.5) %>%
    plot(horiz = T, cex = 0.5)

```



# Interaction plot

Try to visualize interaction and correlation beetween two features in one MoA compared to the others.

Maybe for some features couples, the correlation is really different inside one MoA

```{r fig.height=5, fig.width=5}

plot_interaction = function(feat1, feat2, dt = the_matrix_allDrugs_top10pct){
    
    set_Moa = c("dna", "cell_wall", "membrane_stress", "protein_synthesis" )
    colMoa = rainbow(length(set_Moa))
    names(colMoa) = set_Moa
    a = list()
    
    for(m in set_Moa){
        a[[m]] = filter(dt, process_broad == m) %>% select(feat1, feat2)
    }
    
    plot(a[[set_Moa[1]]], pch = 21, col = "black", bg = colMoa[1], xlim = c(min(unlist(a)), max(unlist(a))),
         ylim = c(min(unlist(a)), max(unlist(a))), cex = 1.5 )
    abline(coef = (line(a[[set_Moa[1]]]))$coefficients, lwd = 2, col = colMoa[1])
    
    for(m in 2:(length(set_Moa))){
        
        points(a[[set_Moa[m]]],  pch = 21, col = "black", bg = colMoa[m], cex = 1.5)
        abline(coef = (line(a[[set_Moa[m]]]))$coefficients, lwd = 2, col = colMoa[m])
    }
    legend("bottomright", legend=set_Moa,
       col=colMoa, lty=1, lwd = 3)
}

# Is it really an interaction plot or is it smthing else ?
#No interaction ?
plot_interaction(feat1 = "DAM", feat2= "FRE")
plot_interaction_moa(feat1 = "DAM", feat2= "FRE", moa = "dna")
# Interaction ?
plot_interaction(feat1 = "RECC", feat2= "RECA")
plot_interaction_moa(feat1 = "RECC", feat2= "RECA", moa = "dna")

#   Meaning : the relative effect of RECC on RECA is depending with the fact it's a DNA targeting drug or not ?
# Interaction beetween effect of RECC on RECA and dna target or not


plot_interaction_moa = function(feat1, feat2, dt = the_matrix_allDrugs_top10pct, moa = "dna"){
    x1 = filter(dt, process_broad == moa) %>% select(feat1, feat2)
    x2 = filter(dt, process_broad != moa) %>% select(feat1, feat2)
    
    plot(x1, pch = 21,  bg = "blue", xlim = c(min(x1[,1], x2[,1]), max(x1[,1], x2[,1])),
         ylim = c(min(x1[,2], x2[,2]), max(x1[,2], x2[,2])),  cex = 1.5 )
    abline(coef = (line(x1))$coefficients, lwd = 2, col = "blue")
    
    points(x2,  pch = 21, bg = "orange", cex = 1.5)
    abline(coef = (line(x2))$coefficients, lwd = 2, col = "orange")

    legend("bottomright", legend=c(moa, paste0("not_",moa)),
       col=c("blue", "orange"), lty=1, lwd = 3)
}


correlation_moa = function(feat1, feat2, dt = the_matrix_allDrugs_top10pct){
    set_Moa = c("dna", "cell_wall", "membrane_stress", "protein_synthesis" )

    res = c()
    for(m in set_Moa){
        a = filter(dt, process_broad == m) %>% select(feat1, feat2)
        res = c(res, cor(a[,1], a[,2]))
    }
    names(res) = set_Moa
    return(res)
}
```

Time to screen
In fact not really clever to run it, will generate thousand of plot
Look at the difference in line slopes ? take genes couples with the biggest difference ?


```{r}
for (f1 in names(overview)){
    for (f2 in names(overview)) {
        if(f1 != f2)
            plot_interaction(feat1 = f1, feat2 = f2)
    }
}

#Get rid of chemical feat
corFeat = data.frame(matrix(ncol = 4, nrow = 0))
colnames(corFeat) = c("dna", "cell_wall", "membrane_stress", "protein_synthesis" ) 
for (f1 in names(overview)[-c(14, 17, 39, 54 )]){
    for (f2 in names(overview)[-c(14, 17, 39, 54 )]) {
        if(f1 != f2)
            corFeat[paste0(f1, " * ", f2), ] = correlation_moa(feat1 = f1, feat2 = f2)
    }
}

stripchart(abs(corFeat), pch = 21, bg = "orange", method = "jitter")
```



Screen all first order interaction beetween features and plot the distribution of coefficients.
Most of them are (nearly) equal to zero but there's still some which are significants outliers.

Problem to fix cutoff of pvalue (not a new problem) : 0.05 takes to much interaction as significant and Bonferroni correction is too much, none left...


```{r}
data_matrix = the_matrix_allDrugs_top10pct
moa = "dna"

custom_matrix = data_matrix %>% mutate(process_broad = replace(process_broad, process_broad != moa, paste0("not_", moa)))
custom_matrix$process_broad = factor(custom_matrix$process_broad, levels = c(moa, paste0("not_", moa)))


interFeat = data.frame(matrix(ncol = 1, nrow = 0))
for (f1 in names(overview)){
    for (f2 in names(overview)) {
        if(f1 != f2){
            x = glm(custom_matrix$process_broad ~ custom_matrix[ ,f1] * custom_matrix[ ,f2], family = binomial)
            #Pvalue
            interFeat[paste0(f1, " * ", f2), ] = (summary(x))$coefficients[2,4]
            #Coefficient 
            #interFeat[paste0(f1, " * ", f2), ] = x$coefficients[4] 
        }
    }
}

hist(as.matrix(interFeat), breaks = 50, col = "orange")
```





