---
title: "Miscellaneous analyses"
author: "Florian Huber, Leonard Dubois"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_caption: yes
    fig_height: 6
    fig_width: 6
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
editor_options: 
  chunk_output_type: console
---

# Setup, library loading

This part is the general setup, whichever model we are using.

```{r setup}
# function to check if a package is installed, if so, load it, else install and then load it
source("./R/ipak.R")
# set chunk options and load libraries
source("./setup.R")
# custom functions
walk(list.files("./R", pattern = "*.R", full.names = T), source)

matrix_container = readRDS("./data/matrix_container_withextractions.rds")
ipak(plotmo)
ipak(reshape2)
ipak(gplots)
ipak("gridExtra")
ipak("plotly")

library(ComplexHeatmap)
library(viridis)
library(circlize)
library(gplots)
library(RColorBrewer)
library(forcats)
```

# Miscellaneous analyses

## Chemical similarities

Check if some drugs are chemically very similar so that they may need to be blocked during CV 
instance creation. Use RDKit chemical fingerprints. Also compare hierarchical clusterings based 
on Nichols data (Euclidean distance and 1-correlation as distance).

Use InChI for KNIME workflow used during dbsetup construction, then calculate fingerprints. 

```{r}
the_matrix_allDrugs <- 
   filter(matrix_container, feat_preselect == "keepall", drug_dosages == "most_interactions", 
          chemical_feats == FALSE) %>%
   select(drug_feature_matrices) %>%
   unnest()

drugs_full <- read.table("/Volumes/typas/Florian/dbsetup_tables/drugs.csv", header = T, 
                         sep = ";", stringsAsFactors = F, dec = ".")

all_inchi <- 
   filter(drugs_full, drugname_typaslab %in% the_matrix_allDrugs$drugname_typaslab) %>% 
   select(drugname_typaslab, data_stdinchi)

write_tsv(all_inchi, col_names = T, path = "data/all_inchi.tsv")
```

Read fingerprints. 

```{r}
drugs_RDkit_fingerprint = read_csv2(file = "data/RDkit_fingerprint.csv")
drugs_RDkit_fingerprint = merge(all_inchi, drugs_RDkit_fingerprint, by = "data_stdinchi")
colnames(drugs_RDkit_fingerprint) = c("data_stdinchi", "drugnames_typaslab", "RDkit_fingerprint")
# could also get morgan and MACCS fingerprints, see ./data
```

Plot dendrogram of similarities. 

```{r}
cluster_matrix <- as.tibble(select(drugs_RDkit_fingerprint, -data_stdinchi))
row.names(cluster_matrix) <- cluster_matrix$drugnames_typaslab
cluster_matrix$drugnames_typaslab <- NULL
process_lut <- the_matrix_allDrugs$process_broad[match(row.names(cluster_matrix), the_matrix_allDrugs$drugname_typaslab)]
names(process_lut) <- row.names(cluster_matrix)

cluster_matrix <- as.matrix(cluster_matrix)
cluster_matrix_splitbits <- t(apply(cluster_matrix, 1, function(x) {
   as.numeric(unlist(strsplit(x["RDkit_fingerprint"], split = "")))
}))
cluster_matrix_splitbits_dist <- dist(cluster_matrix_splitbits, method = "binary")

moa_to_colour <- c(cell_wall = "#a6cee3",
                   dna = "#1f78b4",
                   protein_synthesis = "#b2df8a",
                   membrane_stress = "#33a02c",
                   pmf = "#bababa", protein_qc = "#bababa", oxidative_stress = "#bababa", 
                   unknown = "#bababa")
rowcols <- moa_to_colour[process_lut[rownames(cluster_matrix)]]

pdf("./plots/drug_drug_similarities_RDKit.pdf", width = 14, height = 14)
heatmap.2(cluster_matrix_splitbits, 
          trace = "none", 
          Rowv = as.dendrogram(hclust(cluster_matrix_splitbits_dist)), 
          RowSideColors = rowcols, 
          margins = c(12, 9), 
          dendrogram = "row", 
          labCol = "", 
          breaks = c(0, 0.5, 1), 
          col = rev(heat.colors(n = 2)), 
          main = "Binary distances of drugs (RDKit fingerprint)")
legend("topright", 
       legend = names(moa_to_colour), 
       col = moa_to_colour, 
       lty = 1, 
       lwd = 5, 
       cex = 0.8)
dev.off()
```


## PCA: first 4 PCs of most interactions, top 10% variance, no chemical features

```{r}
m <- filter(matrix_container, feat_preselect == "top10pct", drug_dosages == "most_interactions", 
            chemical_feats == FALSE)$drug_feature_matrices[[1]]

m_matrix <- as.data.frame(m[, c(4:ncol(m))])
rownames(m_matrix) <- m$drugname_typaslab
pr.out <- prcomp(m_matrix, scale = TRUE)
prcomps <- as.data.frame(pr.out$x)
prcomps$drugname_typaslab <- row.names(prcomps)
prcomps <- left_join(prcomps, m[, c("drugname_typaslab", "process_broad")])
prcomps <- select(prcomps, drugname_typaslab, process_broad, everything())

prcomps$process_broad[!(prcomps$process_broad %in% c("cell_wall", "dna", "membrane_stress", "protein_synthesis"))] <- "other"
p1 <- ggplot(prcomps, aes(x = PC1, y = PC2)) + 
   geom_point(aes(colour = process_broad)) + 
#   geom_label_repel(aes(label = drugname_typaslab)) + 
   theme_bw() + 
   ggtitle("PCA (Nichols, top 10% var)")

p2 <- ggplot(prcomps, aes(x = PC1, y = PC3)) + 
   geom_point(aes(colour = process_broad)) + 
#   geom_label_repel(aes(label = drugname_typaslab)) + 
   theme_bw()

p3 <- ggplot(prcomps, aes(x = PC2, y = PC3)) + 
   geom_point(aes(colour = process_broad)) + 
#   geom_label_repel(aes(label = drugname_typaslab)) + 
   theme_bw()

p4 <- ggplot(prcomps, aes(x = PC3, y = PC4)) + 
   geom_point(aes(colour = process_broad)) + 
#   geom_label_repel(aes(label = drugname_typaslab)) + 
   theme_bw()

p <- grid.arrange(p1, p2, p3, p4, nrow = 2)
ggsave(p, file = "./plots/PCA_plots.pdf")

```

## Plots for presentations/posters

### ROC curve

Not nice in the sense of perfect but of colour scheme etc.

```{r plot_flasthalk}
tmp <- readRDS("./data/matrix_container_withextractions.rds")
tmp <- tmp$ThreshVsPerfData[[1]]
tmp <- tmp %>%
   group_by(threshold, moa_modelled) %>%
   summarise(fpr_mean = mean(fpr), tpr_mean = mean(tpr)) %>%
   ungroup()

ggplot(tmp, aes(x = fpr_mean, y = tpr_mean)) + 
   geom_line(aes(colour = moa_modelled), size = 1.5) + 
   theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
         panel.background = element_rect(fill = "white", colour = "black"), 
         text = element_text(size = 14), 
         legend.position = c(0.95, 0.05), legend.justification = c("right", "bottom")) + 
   scale_colour_manual("Mode of action", 
                       labels = c("Cell wall", "DNA", "Membrane stress", "Protein synthesis"), 
                       values = c("#e66101", "#fdb863", "#b2abd2", "#5e3c99")) + 
   labs(title = "ROC curve for random forests", 
        x = "False positive rate", 
        y = "True positive rate") + 
   geom_abline(intercept = 0, slope = 1, linetype = "dotted")
ggsave("./plots/ROC_curve_flashtalk.pdf", width = 5, height = 5)
```

### S-score distribution

```{r, posterplots_Madrid_I}
the_matrix_melted_moainfo <- readRDS("./data/the_matrix_melted_moainfo.rds")

tmp <- 
   filter(the_matrix_melted_moainfo, gene_synonym == "RECA") %>%
   mutate(is_dna = process_broad == "dna") %>%
   arrange(s_score)

ggplot(tmp, aes(x = s_score)) + 
   geom_histogram(aes(fill = is_dna), binwidth = 0.3) + 
   theme_bw() + 
   labs(x = "Relative fitness score", y = "Count", 
        title = "Relative fitness scores for recA mutant\nacross >300 drug-concentration combinations") + 
   scale_fill_manual("Cellular target", values = c("#bababa", "#fdb863"), labels = c("Other", "DNA")) + 
   theme(text = element_text(size = 18))

ggsave(filename = "./plots/POSTER_sscores.pdf", width = 7.5, height = 5)
```


### General statistics

```{r, posterplots_Madrid_II}
matrix_container_with_extractions <- readRDS("./data/matrix_container_withextractions.rds")

drug_feat_mat <- matrix_container_with_extractions$drug_feature_matrices[[1]]
unique(drug_feat_mat$process_broad)

tmp <- drug_feat_mat[, c("drugname_typaslab", "process_broad", "conc")]
tmp <- group_by(tmp, drugname_typaslab) %>%
   mutate(conc_rank = rank(conc)) %>%
   ungroup()

tmp$process_broad <- 
   fct_recode(tmp$process_broad, 
              "Cell Wall" = "cell_wall", 
              "Protein Synthesis" = "protein_synthesis", 
              "Membrane Stress" = "membrane_stress", 
              "DNA" = "dna", 
              "Other" = "oxidative_stress", 
              "Other" = "pmf", 
              "Other" = "protein_qc")

# plot both the number of drugs per mode of action and the number of dosages per drug per MoA

tmp$process_broad <- fct_relevel(tmp$process_broad, "Other", after = Inf)

tmp2 <- 
   group_by(tmp, drugname_typaslab) %>%
   slice(1) %>%
   ungroup() %>%
   count(process_broad)

ggplot(tmp2, aes(x = process_broad, y = n)) + 
   geom_bar(aes(fill = process_broad), stat = "identity") + 
   scale_fill_discrete("Cellular target") + 
   theme_bw() + 
   theme(text = element_text(size = 18), legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1)) + 
   labs(x = "", y = "Count", title = "N observations per MoA") + 
   scale_fill_manual(values = c("#e66101", "#fdb863", "#b2abd2", "#5e3c99", "#bababa"))

ggsave("./plots/POSTER_drugs_per_moa.pdf", width = 5, height = 6)

# more detailed view
(tmp3 <- count(tmp, drugname_typaslab, process_broad))

ggplot(tmp3, aes(x = n)) + 
   geom_bar(aes(fill = process_broad)) + 
   labs(x = "Number of concentrations measured", y = "Number of drugs", 
        title = "Number of concentrations\nmeasured per drug") + 
   scale_fill_discrete("Cellular target") + 
   scale_x_continuous(breaks = c(1, 2, 3, 4, 5, 6)) + 
   theme_bw() + 
   theme(text = element_text(size = 18)) + 
   scale_fill_manual("Cellular target", values = c("#e66101", "#fdb863", "#b2abd2", "#5e3c99", "#bababa"))

ggsave("./plots/POSTER_conc_per_drug.pdf", width = 6.5, height = 4.8)
```



## Nichols data: heatmaps and custom "sub heatmaps" (Euclidean and (1-corr))

Heatmap with all genes and all conditions, Euclidean distance:

```{r}
# take a drug_feature_matrix w/o chemical features from "keepall" and using all dosages

tmp <- as.data.frame(matrix_container$drug_feature_matrices[[1]])

moa_to_colour <- c(cell_wall = "#a6cee3",
                   dna = "#1f78b4",
                   protein_synthesis = "#b2df8a",
                   membrane_stress = "#33a02c",
                   pmf = "#bababa", protein_qc = "#bababa", oxidative_stress = "#bababa", 
                   unknown = "#bababa")
rowcols <- moa_to_colour[tmp$process_broad]

tmp.bak <- tmp
tmp$drugname_typaslab <- paste(tmp$drugname_typaslab, tmp$conc, sep = "_")
row.names(tmp) <- tmp$drugname_typaslab
tmp[, c("drugname_typaslab", "conc", "process_broad")] <- NULL
tmp_m <- as.matrix(tmp)
tmp_m_dist <- dist(tmp_m, method = "euclidean")
tmp_m_dist <- as.dist((1 - cor(t(tmp_m))))

pdf("./plots/Heatmap_drugs_vs_conds_euclid_alldosg_alldrugs.pdf", width = 140, height = 30)
heatmap.2(tmp_m, 
          trace = "none", 
          Rowv = as.dendrogram(hclust(tmp_m_dist)), 
          RowSideColors = rowcols, 
          margins = c(12, 9), 
          dendrogram = "row", 
          breaks = seq(from = -5, to = 5, by = 1),  
          col = rev(heat.colors(n = 10)), 
          main = "")
legend("top", 
       legend = names(moa_to_colour), 
       col = moa_to_colour, 
       lty = 1, 
       lwd = 5, 
       cex = 0.5)
dev.off()
```


Write a function to generate "subheatmaps", depending on the conditions and genes provided.

First run a few tests for choosing color palettes etc. Important websites: the vignette for the 
ComplexHeatmap package (can do everything) and also for the [viridis package](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html).

```{r}
# write a function that:
# takes a drug_feature matrix
# takes a vector of conditions and a vector genes (features) to keep 
# and then creates a heatmaps

my_test <- myhead(tmp_m)
# change two values to check for outliers
my_test["A22_0.5", "AAEX"] <- -5
my_test["ACRIFLAVINE_2", "ABGA"] <- -7

my_cols <- cividis(n = 10)

Heatmap(my_test, col = colorRamp2(seq(from = -4, to = 4, length.out = 10), my_cols), 
        cell_fun = function(j, i, x, y, width, height, fill) {
           grid.text(sprintf("%.2f", my_test[i, j]), x, y, gp = gpar(fontsize = 10))
         })

# use viridis color palette for good perceptual properties
# but how many breaks do we need? let's say we want to see 90% of the data:
hist(tmp_m)
quantile(tmp_m, probs = c(0.005, 0.01, 0.05, 0.1, 0.5, 0.9, 0.95, 0.99, 0.995))
# looks like 90% of the data are between -2.2 and 1.96:
hist(tmp_m, xlim = c(-3.5, 3.5), breaks = 300)

# quantiles if one takes 99% of the data
lapply(list(mean, sd), function(x) x(tmp_m[tmp_m[, 1] > -4.3 & tmp_m[, 1] < 3, c(T, rep(F, ncol(tmp_m) - 1))]))
# might indicate that data were quantile normalised - because if data is normally distributed, IQR = 1.35 * sd
# but I'm not sure, and this data set is not complete
# anyway ...

# cut the interval from -3.5 to 3.5 into 0.1-spaced intervals, using 70 colors
my_cols <- cividis(n = 70)
my_test[] <- seq(from = -4, to = 2, length.out = length(my_test))

# to show only specific rows 
my_test <- tmp_m
my_test <- my_test[grepl(row.names(my_test), pattern = "A22|CEFACLOR|CYCLOSERINED|PEROXIDE"), 
                   colnames(my_test) %in% c("RECG", "DDLB", "RYFC", "RECA", "MRCB", "SLT", "PYRE", "PYRD")]
```


Careful! If one wants to cluster based on Pearson correlation and not taking the sign into 
consideration: don't use the default "pearson" argument, rather define our own distance function:

```{r}
# not what we want
Heatmap(my_test, col = colorRamp2(seq(from = -3.5, to = 3.5, length.out = 70), my_cols), 
        row_names_side = "left", 
        column_names_side = "top", 
        # split = 2, 
        gap = unit(5, "mm"), 
        clustering_distance_rows = "pearson", 
        clustering_distance_columns = "pearson", 
        cell_fun = function(j, i, x, y, width, height, fill) {
           grid.text(sprintf("%.2f", my_test[i, j]), x, y, gp = gpar(col = "black", fontsize = 10))
           }
        )

# what we want:
distfun <- function(x, y) {
   sqrt(1 - abs(cor(x, y)))
}

Heatmap(my_test, col = colorRamp2(seq(from = -3.5, to = 3.5, length.out = 70), my_cols), 
        row_names_side = "left", 
        column_names_side = "top", 
        gap = unit(5, "mm"), 
        clustering_distance_rows = distfun, 
        clustering_distance_columns = "pearson", 
        cell_fun = function(j, i, x, y, width, height, fill) {
           grid.text(sprintf("%.2f", my_test[i, j]), x, y, gp = gpar(col = "black", fontsize = 10))
           }
        )

# how about actually labelling the strong negative/positive q values rather than the noise in 
# between? 
Heatmap(my_test, col = colorRamp2(c(-3, -2.999, 0, 2.999, 3), c("#7b3294", "#cccccc", "#cccccc", "#cccccc", "#008837")), 
        row_names_side = "left", 
        column_names_side = "top", 
        gap = unit(5, "mm"), 
        clustering_distance_rows = distfun, 
        clustering_distance_columns = "pearson", 
        cell_fun = function(j, i, x, y, width, height, fill) {
           grid.text(sprintf("%.2f", my_test[i, j]), x, y, gp = gpar(col = "black", fontsize = 10))
           }
        )
```

Let's plot a few subheatmaps:

```{r}
pdf("./plots/NEW_heatmap_test_SDS_allgenes.pdf")
my_subheatmap(tmp_m, drugs = c("SDS"), genes = colnames(tmp_m)[1:20])
dev.off()
```


## PCA of chemical features

```{r}
#matrix_container = readRDS("/Volumes/typas/Florian/matrix_container_withextractions.rds")

# Preparing data
dt_matrix <- filter(matrix_container, drug_dosages == "most_interactions", chemical_feats == TRUE)$drug_feature_matrices[[1]]

dt_chem_mostInteraction <- cbind(dt_matrix[ , !grepl(x = colnames(dt_matrix), pattern = "^[A-Z]{3,4}")], TPSA = dt_matrix$TPSA)
#Or only the one used for protein synhesis prediction
#   dt_chem_mostInteraction <- dt_matrix %>% select(ExactMW, SlogP, TPSA)
#Make optional
#   dt_chem_mostInteraction = dt_chem_mostInteraction %>% filter(process_broad %in% c("cell_wall", "dna", "membrane_stress", "protein_synthesis"))

dt_chem_mostInteraction = dt_chem_mostInteraction %>% select(-process_broad, -conc)
rownames(dt_chem_mostInteraction) <- dt_chem_mostInteraction$drugname_typaslab
dt_chem_mostInteraction <- dt_chem_mostInteraction[, -1]

# PCA
pca_data <- prcomp(dt_chem_mostInteraction, scale = TRUE)

# Importance of PC in sdev, the two firsts make 45 %
barplot(pca_data$sdev / sum(pca_data$sdev))

plotData <- as.data.frame(pca_data$x)

#plotData = cbind(plotData, process_broad = dt_matrix[ dt_matrix$process_broad %in% c("cell_wall", "dna", "membrane_stress", "protein_synthesis"), "process_broad"])
plotData = cbind(plotData, process_broad = dt_matrix$process_broad)

plotData$process_broad[!(plotData$process_broad %in% c("cell_wall", "dna", "membrane_stress", "protein_synthesis"))] <- "other"

p1 <- ggplot(plotData, aes(x = PC1, y = PC2)) + 
    geom_point(aes(fill = process_broad), shape = 21, size = 4, colour = "black") + 
    theme_bw() + scale_fill_manual(values=rainbow(4)) + 
    ggtitle("PCA Chemical Feat, PC 1 and 2")

p2 <- ggplot(plotData, aes(x = PC3, y = PC2)) + 
    geom_point(aes(fill = process_broad), shape = 21, size = 4, colour = "black") + 
    theme_bw() + scale_fill_manual(values=rainbow(4)) + 
    ggtitle("PCA Chemical Feat, PC 2 and 3 ")

p3 <- ggplot(plotData, aes(x = PC3, y = PC4)) + 
    geom_point(aes(fill = process_broad), shape = 21, size = 4, colour = "black") + 
    theme_bw() + scale_fill_manual(values=rainbow(4)) + 
    ggtitle("PCA Chemical Feat, PC 3 and 4 ")

p4 <- ggplot(plotData, aes(x = PC5, y = PC4)) + 
    geom_point(aes(fill = process_broad), shape = 21, size = 4, colour = "black") + 
    theme_bw() + scale_fill_manual(values=rainbow(4)) + 
    ggtitle("PCA Chemical Feat, PC 4 and 5 ")

grid.arrange(p1, p2, p4, p3, nrow = 2)
```


## Super Random control

Just to be sure, RF model with random features (same sd and mean but random values). test on the chemogenomic matrix with 10% top variance features

```{r}
mat = matrix_container[21, ]
randomMat = mat$drug_feature_matrices[[1]] %>% select(-conc)
randomMat = apply(randomMat[ , grepl(x = colnames(randomMat), pattern = "^[A-Z]{3,4}")], 2, 
                  function(x){
                     assign("x", value = rnorm(78, mean = mean(x), sd = sd(x)))
                  })
randomMat = as.data.frame(randomMat)
randomMat$drugname_typaslab =  mat$drug_feature_matrices[[1]]$drugname_typaslab
randomMat$process_broad =  mat$drug_feature_matrices[[1]]$process_broad

mat$drug_feature_matrices[[1]] = as.tbl(randomMat)

if (!file.exists("./data/programmatic_output/testTotal_random.rds")) {
   testTotal_random = repeated_NCV_run_4models_container(data_container = mat, line_number = 1)
   saveRDS(testTotal_random, file = "./data/programmatic_output/testTotal_random.rds")
} else {
   testTotal_random <- readRDS(file = "./data/programmatic_output/testTotal_random.rds")
}

plot_ROC_allRep(res = testTotal_random, moa = "all")
```

Everything fine, random features leads to diagonal ROC curves


## Correlation between dosages and betwen drugs

Compare within vs. between-dosage correlation. 


```{r}
```


## Correlation between chemical classes of drugs

Check file `data/drugs_chem_classes.txt`. Put special focus on chemical features. 


## ROC curves of single features

```{r, eval = FALSE}
dt_mat = matrix_container[1, ]$drug_feature_matrices[[1]]

all_feat = colnames(dt_mat)[-c(1,2,3)]

areas = list()

for(f in all_feat){
    
    for (moa in c("cell_wall", "dna", "membrane_stress", "protein_synthesis")){
        cat(f, " - ", moa, "\n")
        a = ROC_curve_1feat(dt_mat = dt_mat, moa = moa, feat = f)
        areas[[moa]] = c(areas[[moa]], a$auc)
    }
}
```


# Session info

```{r}
R.version
sessionInfo()
```

