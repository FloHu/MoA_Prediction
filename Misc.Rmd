---
title: "Miscellaneous analyses"
author: "Florian Huber, Leonard Dubois"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_caption: yes
    fig_height: 6
    fig_width: 6
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
editor_options: 
  chunk_output_type: console
---

# Setup, library loading

This part is the general setup, whichever model we are using.

```{r setup}
# function to check if a package is installed, if so, load it, else install and then load it
source("./R/ipak.R")
# set chunk options and load libraries
source("./setup.R")
# custom functions
walk(list.files("./R", pattern = "*.R", full.names = T), source)

matrix_container = readRDS("./data/matrix_container_withextractions.rds")
ipak(plotmo)
ipak(reshape2)
ipak(gplots)
ipak("gridExtra")
ipak("plotly")

library(ComplexHeatmap)
library(viridis)
library(circlize)
```

# Hierarchical clusterings of drugs

## Chemical similarities

Check if some drugs are chemically very similar so that they may need to be blocked during CV 
instance creation. Use RDKit chemical fingerprints. Also compare hierarchical clusterings based 
on Nichols data (Euclidean distance and 1-correlation as distance).

Use InChI for KNIME workflow used during dbsetup construction, then calculate fingerprints. 

```{r}
the_matrix_allDrugs <- 
   filter(matrix_container, feat_preselect == "keepall", drug_dosages == "most_interactions", 
          chemical_feats == FALSE) %>%
   select(drug_feature_matrices) %>%
   unnest()

drugs_full <- read.table("/Volumes/typas/Florian/dbsetup_tables/drugs.csv", header = T, 
                         sep = ";", stringsAsFactors = F, dec = ".")

all_inchi <- 
   filter(drugs_full, drugname_typaslab %in% the_matrix_allDrugs$drugname_typaslab) %>% 
   select(drugname_typaslab, data_stdinchi)

write_tsv(all_inchi, col_names = T, path = "data/all_inchi.tsv")
```

Read fingerprints. 

```{r}
drugs_RDkit_fingerprint = read_csv2(file = "data/RDkit_fingerprint.csv")
drugs_RDkit_fingerprint = merge(all_inchi, drugs_RDkit_fingerprint, by = "data_stdinchi")
colnames(drugs_RDkit_fingerprint) = c("data_stdinchi", "drugnames_typaslab", "RDkit_fingerprint")
# could also get morgan and MACCS fingerprints, see ./data
```

Plot dendrogram of similarities. 

```{r}
library(gplots)
library(RColorBrewer)

cluster_matrix <- as.tibble(select(drugs_RDkit_fingerprint, -data_stdinchi))
row.names(cluster_matrix) <- cluster_matrix$drugnames_typaslab
cluster_matrix$drugnames_typaslab <- NULL
process_lut <- the_matrix_allDrugs$process_broad[match(row.names(cluster_matrix), the_matrix_allDrugs$drugname_typaslab)]
names(process_lut) <- row.names(cluster_matrix)

cluster_matrix <- as.matrix(cluster_matrix)
cluster_matrix_splitbits <- t(apply(cluster_matrix, 1, function(x) {
   as.numeric(unlist(strsplit(x["RDkit_fingerprint"], split = "")))
}))
cluster_matrix_splitbits_dist <- dist(cluster_matrix_splitbits, method = "binary")

moa_to_colour <- c(cell_wall = "#a6cee3",
                   dna = "#1f78b4",
                   protein_synthesis = "#b2df8a",
                   membrane_stress = "#33a02c",
                   pmf = "#bababa", protein_qc = "#bababa", oxidative_stress = "#bababa", 
                   unknown = "#bababa")
rowcols <- moa_to_colour[process_lut[rownames(cluster_matrix)]]

pdf("./plots/drug_drug_similarities_RDKit.pdf", width = 14, height = 14)
heatmap.2(cluster_matrix_splitbits, 
          trace = "none", 
          Rowv = as.dendrogram(hclust(cluster_matrix_dist)), 
          RowSideColors = rowcols, 
          margins = c(12, 9), 
          dendrogram = "row", 
          labCol = "", 
          breaks = c(0, 0.5, 1), 
          col = rev(heat.colors(n = 2)), 
          main = "Binary distances of drugs (RDKit fingerprint)")
legend("topright", 
       legend = names(moa_to_colour), 
       col = moa_to_colour, 
       lty = 1, 
       lwd = 5, 
       cex = 0.8)
dev.off()
```


PCA plot: most interactions, top 10% variance, no chemical features.

```{r}
m <- filter(matrix_container, feat_preselect == "top10pct", drug_dosages == "most_interactions", 
            chemical_feats == FALSE)$drug_feature_matrices[[1]]

m_matrix <- as.data.frame(m[, c(4:ncol(m))])
rownames(m_matrix) <- m$drugname_typaslab
pr.out <- prcomp(m_matrix, scale = TRUE)
prcomps <- as.data.frame(pr.out$x)
prcomps$drugname_typaslab <- row.names(prcomps)
prcomps <- left_join(prcomps, m[, c("drugname_typaslab", "process_broad")])
prcomps <- select(prcomps, drugname_typaslab, process_broad, everything())

prcomps$process_broad[!(prcomps$process_broad %in% c("cell_wall", "dna", "membrane_stress", "protein_synthesis"))] <- "other"
p1 <- ggplot(prcomps, aes(x = PC1, y = PC2)) + 
   geom_point(aes(colour = process_broad)) + 
#   geom_label_repel(aes(label = drugname_typaslab)) + 
   theme_bw() + 
   ggtitle("PCA (Nichols, top 10% var)")

p2 <- ggplot(prcomps, aes(x = PC1, y = PC3)) + 
   geom_point(aes(colour = process_broad)) + 
#   geom_label_repel(aes(label = drugname_typaslab)) + 
   theme_bw()

p3 <- ggplot(prcomps, aes(x = PC2, y = PC3)) + 
   geom_point(aes(colour = process_broad)) + 
#   geom_label_repel(aes(label = drugname_typaslab)) + 
   theme_bw()

p4 <- ggplot(prcomps, aes(x = PC3, y = PC4)) + 
   geom_point(aes(colour = process_broad)) + 
#   geom_label_repel(aes(label = drugname_typaslab)) + 
   theme_bw()

p <- grid.arrange(p1, p2, p3, p4, nrow = 2)
ggsave(p, file = "./plots/PCA_plots.pdf")

```

## Plots for presentations/posters

### ROC curve

Not nice in the sense of perfect but of colour scheme etc.

```{r}
tmp <- readRDS("./data/matrix_container_withextractions.rds")
tmp <- tmp$ThreshVsPerfData[[1]]
tmp <- tmp %>%
   group_by(threshold, moa_modelled) %>%
   summarise(fpr_mean = mean(fpr), tpr_mean = mean(tpr)) %>%
   ungroup()

ggplot(tmp, aes(x = fpr_mean, y = tpr_mean)) + 
   geom_line(aes(colour = moa_modelled), size = 1.5) + 
   theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
         panel.background = element_rect(fill = "white", colour = "black"), 
         text = element_text(size = 14), 
         legend.position = c(0.95, 0.05), legend.justification = c("right", "bottom")) + 
   scale_colour_manual("Mode of action", labels = c("Cell wall", "DNA", "Membrane stress", "Protein synthesis"), 
                       values = c("#e66101", "#fdb863", "#b2abd2", "#5e3c99")) + 
   labs(title = "ROC curve for random forests", x = "False positive rate", y = "True positive rate") + 
   geom_abline(intercept = 0, slope = 1, linetype = "dotted")
ggsave("./plots/ROC_curve_flashtalk.pdf", width = 5, height = 5)

```

### S-score distribution

```{r}
the_matrix_melted_moainfo <- readRDS("./data/the_matrix_melted_moainfo.rds")

tmp <- 
   filter(the_matrix_melted_moainfo, gene_synonym == "RECA") %>%
   mutate(is_dna = process_broad == "dna") %>%
   arrange(s_score)

ggplot(tmp, aes(x = s_score)) + 
   geom_histogram(aes(fill = is_dna), binwidth = 0.3) + 
   theme_bw() + 
   labs(x = "Relative fitness score", y = "Count", 
        title = "Relative fitness scores for recA mutant\nacross >300 drug-concentration combinations") + 
   scale_fill_manual("Cellular target", values = c("#bababa", "#fdb863"), labels = c("Other", "DNA")) + 
   theme(text = element_text(size = 18))

ggsave(filename = "./plots/POSTER_sscores.pdf", width = 7.5, height = 5)
```


### General statistics

```{r}
library(forcats)
matrix_container_with_extractions <- readRDS("./data/matrix_container_withextractions.rds")

drug_feat_mat <- matrix_container_with_extractions$drug_feature_matrices[[1]]
unique(drug_feat_mat$process_broad)

tmp <- drug_feat_mat[, c("drugname_typaslab", "process_broad", "conc")]
tmp <- group_by(tmp, drugname_typaslab) %>%
   mutate(conc_rank = rank(conc)) %>%
   ungroup()

tmp$process_broad <- 
   fct_recode(tmp$process_broad, 
              "Cell Wall" = "cell_wall", 
              "Protein Synthesis" = "protein_synthesis", 
              "Membrane Stress" = "membrane_stress", 
              "DNA" = "dna", 
              "Other" = "oxidative_stress", 
              "Other" = "pmf", 
              "Other" = "protein_qc")

# plot both the number of drugs per mode of action and the number of dosages per drug per MoA

tmp$process_broad <- fct_relevel(tmp$process_broad, "Other", after = Inf)

tmp2 <- 
   group_by(tmp, drugname_typaslab) %>%
   slice(1) %>%
   ungroup() %>%
   count(process_broad)

ggplot(tmp2, aes(x = process_broad, y = n)) + 
   geom_bar(aes(fill = process_broad), stat = "identity") + 
   scale_fill_discrete("Cellular target") + 
   theme_bw() + 
   theme(text = element_text(size = 18), legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1)) + 
   labs(x = "", y = "Count", title = "N observations per MoA") + 
   scale_fill_manual(values = c("#e66101", "#fdb863", "#b2abd2", "#5e3c99", "#bababa"))

ggsave("./plots/POSTER_drugs_per_moa.pdf", width = 5, height = 6)

# more detailed view
(tmp3 <- count(tmp, drugname_typaslab, process_broad))

ggplot(tmp3, aes(x = n)) + 
   geom_bar(aes(fill = process_broad)) + 
   labs(x = "Number of concentrations measured", y = "Number of drugs", 
        title = "Number of concentrations\nmeasured per drug") + 
   scale_fill_discrete("Cellular target") + 
   scale_x_continuous(breaks = c(1, 2, 3, 4, 5, 6)) + 
   theme_bw() + 
   theme(text = element_text(size = 18)) + 
   scale_fill_manual("Cellular target", values = c("#e66101", "#fdb863", "#b2abd2", "#5e3c99", "#bababa"))

ggsave("./plots/POSTER_conc_per_drug.pdf", width = 6.5, height = 4.8)

```



## Nichols data: heatmaps and custom "sub heatmaps" (Euclidean and (1-corr))

Heatmap with all genes and all conditions, Euclidean distance:

```{r}
# take a drug_feature_matrix w/o chemical features from "keepall" and using all dosages

tmp <- as.data.frame(matrix_container$drug_feature_matrices[[1]])

moa_to_colour <- c(cell_wall = "#a6cee3",
                   dna = "#1f78b4",
                   protein_synthesis = "#b2df8a",
                   membrane_stress = "#33a02c",
                   pmf = "#bababa", protein_qc = "#bababa", oxidative_stress = "#bababa", 
                   unknown = "#bababa")
rowcols <- moa_to_colour[tmp$process_broad]

tmp.bak <- tmp
tmp$drugname_typaslab <- paste(tmp$drugname_typaslab, tmp$conc, sep = "_")
row.names(tmp) <- tmp$drugname_typaslab
tmp[, c("drugname_typaslab", "conc", "process_broad")] <- NULL
tmp_m <- as.matrix(tmp)
tmp_m_dist <- dist(tmp_m, method = "euclidean")
tmp_m_dist <- as.dist((1 - cor(t(tmp_m))))

pdf("./plots/euclid.pdf", width = 140, height = 30)
heatmap.2(tmp_m, 
          trace = "none", 
          Rowv = as.dendrogram(hclust(tmp_m_dist)), 
          RowSideColors = rowcols, 
          margins = c(12, 9), 
          dendrogram = "row", 
          breaks = seq(from = -5, to = 5, by = 1),  
          col = rev(heat.colors(n = 10)), 
          main = "")
legend("top", 
       legend = names(moa_to_colour), 
       col = moa_to_colour, 
       lty = 1, 
       lwd = 5, 
       cex = 0.5)
dev.off()
```

Write a function to generate "sub heatmaps", depending on the conditions and genes provided.

First run a few tests for choosing color palettes etc. Important websites: the vignette for the 
ComplexHeatmap package (can do everything) and also for the [viridis package](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html).

```{r}
# write a function that:
# takes a drug_feature matrix
# takes a vector of conditions and a vector genes (features) to keep 
# and then creates a heatmaps

my_test <- myhead(tmp_m)
# change two values to check for outliers
my_test["A22_0.5", "AAEX"] <- -5
my_test["ACRIFLAVINE_2", "ABGA"] <- -7

my_cols <- cividis(n = 10)

Heatmap(my_test, col = colorRamp2(seq(from = -4, to = 4, length.out = 10), my_cols), 
        cell_fun = function(j, i, x, y, width, height, fill) {
           grid.text(sprintf("%.2f", my_test[i, j]), x, y, gp = gpar(fontsize = 10))
         })

# use viridis color palette for good perceptual properties
# but how many breaks do we need? let's say we want to see 90% of the data:
hist(tmp_m)
quantile(tmp_m, probs = c(0.005, 0.01, 0.05, 0.1, 0.5, 0.9, 0.95, 0.99, 0.995))
# looks like 90% of the data are between -2.2 and 1.96:
hist(tmp_m, xlim = c(-3.5, 3.5), breaks = 300)

# quantiles if one takes 99% of the data
lapply(list(mean, sd), function(x) x(tmp_m[tmp_m[, 1] > -4.3 & tmp_m[, 1] < 3, c(T, rep(F, ncol(tmp_m) - 1))]))
# might indicate that data were quantile normalised - because if data is normally distributed, IQR = 1.35 * sd
# but I'm not sure, and this data set is not complete
# anyway ...

# cut the interval from -3.5 to 3.5 into 0.1-spaced intervals, using 70 colors
my_cols <- cividis(n = 70)
my_test[] <- seq(from = -4, to = 2, length.out = length(my_test))

# to show only specific rows 
my_test <- tmp_m
my_test <- my_test[grepl(row.names(my_test), pattern = "A22|CEFACLOR|CYCLOSERINED|PEROXIDE"), 
                   colnames(my_test) %in% c("RECG", "DDLB", "RYFC", "RECA", "MRCB", "SLT", "PYRE", "PYRD")]
```


Careful! If one wants to cluster based on Pearson correlation and not taking the sign into 
consideration: don't use the default "pearson" argument, rather define our own distance function:

```{r}
# not what we want
Heatmap(my_test, col = colorRamp2(seq(from = -3.5, to = 3.5, length.out = 70), my_cols), 
        row_names_side = "left", 
        column_names_side = "top", 
        # split = 2, 
        gap = unit(5, "mm"), 
        clustering_distance_rows = "pearson", 
        clustering_distance_columns = "pearson", 
        cell_fun = function(j, i, x, y, width, height, fill) {
           grid.text(sprintf("%.2f", my_test[i, j]), x, y, gp = gpar(col = "black", fontsize = 10))
           }
        )

# what we want:
distfun <- function(x, y) {
   sqrt(1 - abs(cor(x, y)))
}

Heatmap(my_test, col = colorRamp2(seq(from = -3.5, to = 3.5, length.out = 70), my_cols), 
        row_names_side = "left", 
        column_names_side = "top", 
        gap = unit(5, "mm"), 
        clustering_distance_rows = distfun, 
        clustering_distance_columns = "pearson", 
        cell_fun = function(j, i, x, y, width, height, fill) {
           grid.text(sprintf("%.2f", my_test[i, j]), x, y, gp = gpar(col = "black", fontsize = 10))
           }
        )

# how about actually labelling the strong negative/positive q values rather than the noise in 
# between? 
Heatmap(my_test, col = colorRamp2(c(-3, -2.999, 0, 2.999, 3), c("#7b3294", "#cccccc", "#cccccc", "#cccccc", "#008837")), 
        row_names_side = "left", 
        column_names_side = "top", 
        gap = unit(5, "mm"), 
        clustering_distance_rows = distfun, 
        clustering_distance_columns = "pearson", 
        cell_fun = function(j, i, x, y, width, height, fill) {
           grid.text(sprintf("%.2f", my_test[i, j]), x, y, gp = gpar(col = "black", fontsize = 10))
           }
        )
```

Let's plot a few subheatmaps:

```{r}
pdf("./plots/NEW_heatmap_test_SDS_allgenes.pdf")
my_subheatmap(tmp_m, drugs = c("SDS"), genes = colnames(tmp_m))
dev.off()
```



# PCA of chemical features

```{r}

#matrix_container = readRDS("/Volumes/typas/Florian/matrix_container_withextractions.rds")

# Preparing data
dt_matrix <- filter(matrix_container, drug_dosages == "most_interactions", chemical_feats == TRUE)$drug_feature_matrices[[1]]

dt_chem_mostInteraction <- cbind(dt_matrix[ , !grepl(x = colnames(dt_matrix), pattern = "^[A-Z]{3,4}")], TPSA = dt_matrix$TPSA)
#Or only the one used for protein synhesis prediction
#   dt_chem_mostInteraction <- dt_matrix %>% select(ExactMW, SlogP, TPSA)
#Make optional
#   dt_chem_mostInteraction = dt_chem_mostInteraction %>% filter(process_broad %in% c("cell_wall", "dna", "membrane_stress", "protein_synthesis"))

dt_chem_mostInteraction = dt_chem_mostInteraction %>% select(-process_broad, -conc)
rownames(dt_chem_mostInteraction) <- dt_chem_mostInteraction$drugname_typaslab
dt_chem_mostInteraction <- dt_chem_mostInteraction[, -1]

# PCA
pca_data <- prcomp(dt_chem_mostInteraction, scale = TRUE)

# Importance of PC in sdev, the two firsts make 45 %
barplot(pca_data$sdev / sum(pca_data$sdev))

plotData <- as.data.frame(pca_data$x)

#plotData = cbind(plotData, process_broad = dt_matrix[ dt_matrix$process_broad %in% c("cell_wall", "dna", "membrane_stress", "protein_synthesis"), "process_broad"])
plotData = cbind(plotData, process_broad = dt_matrix$process_broad)

plotData$process_broad[!(plotData$process_broad %in% c("cell_wall", "dna", "membrane_stress", "protein_synthesis"))] <- "other"

p1 <- ggplot(plotData, aes(x = PC1, y = PC2)) + 
    geom_point(aes(fill = process_broad), shape = 21, size = 4, colour = "black") + 
    theme_bw() + scale_fill_manual(values=rainbow(4)) + 
    ggtitle("PCA Chemical Feat, PC 1 and 2")

p2 <- ggplot(plotData, aes(x = PC3, y = PC2)) + 
    geom_point(aes(fill = process_broad), shape = 21, size = 4, colour = "black") + 
    theme_bw() + scale_fill_manual(values=rainbow(4)) + 
    ggtitle("PCA Chemical Feat, PC 2 and 3 ")

p3 <- ggplot(plotData, aes(x = PC3, y = PC4)) + 
    geom_point(aes(fill = process_broad), shape = 21, size = 4, colour = "black") + 
    theme_bw() + scale_fill_manual(values=rainbow(4)) + 
    ggtitle("PCA Chemical Feat, PC 3 and 4 ")

p4 <- ggplot(plotData, aes(x = PC5, y = PC4)) + 
    geom_point(aes(fill = process_broad), shape = 21, size = 4, colour = "black") + 
    theme_bw() + scale_fill_manual(values=rainbow(4)) + 
    ggtitle("PCA Chemical Feat, PC 4 and 5 ")

grid.arrange(p1, p2, p4, p3, nrow = 2)


# ====================== TEST MDS =====================

mds_data = data.frame(cmdscale(dist(dt_chem_mostInteraction), k=2))

mds_data = cbind(mds_data, process_broad = dt_matrix$process_broad)
#mds_data = cbind(mds_data, process_broad = dt_matrix[ dt_matrix$process_broad %in% c("cell_wall", "dna", "membrane_stress", "protein_synthesis"), "process_broad"])

mds_data$process_broad[!(mds_data$process_broad %in% c("cell_wall", "dna", "membrane_stress", "protein_synthesis"))] <- "other"


mdsPlot <- ggplot(data = mds_data) + 
        geom_point(mapping = aes(x = X1, y = X2, fill = process_broad ), colour = "black", size = 3, shape = 21 ) +
        scale_fill_manual(values = rainbow(4)) + theme_bw()

```



# Super Random control

Just to be sure, RF model with random features (same sd and mean but random values). test on the chemogenomic matrix with 10% top variance features

```{r}

mat = matrix_container[21, ]
randomMat = mat$drug_feature_matrices[[1]] %>% select(-conc)
randomMat = apply(randomMat[ , grepl(x = colnames(randomMat), pattern = "^[A-Z]{3,4}")], 2, function(x){assign("x", value = rnorm(78, mean = mean(x), sd = sd(x)))})
randomMat = as.data.frame(randomMat)
randomMat$drugname_typaslab =  mat$drug_feature_matrices[[1]]$drugname_typaslab
randomMat$process_broad =  mat$drug_feature_matrices[[1]]$process_broad

mat$drug_feature_matrices[[1]] = as.tbl(randomMat)

testTotal_random = repeated_NCV_run_4models_container(data_container = mat, line_number = 1)
plot_ROC_allRep(res = testTotal_random, moa = "all")
```

Everything fine, random features leads to diagonal ROC curves





# Correlation between dosages and betwen drugs

Compare repartition of the correlation (Pearson and Spearman) of drugs dosages, all drugs together and drugs within mode of action 
Data might be list of 6 unequal vectors

```{r}

# I know the code here is really awful but I was so eager to see the result I couldn't wait to figure out a good solution to compute it

corData = list()

matDrugs_mostInteraction = matrix_container[19, ]$drug_feature_matrices[[1]] %>% select(-conc, -drugname_typaslab)
matDrugs_allDosages = matrix_container[1, ]$drug_feature_matrices[[1]] %>% select(-conc, -process_broad) 


# Correlation between Dosages
resP = c()
resS = c()
for(moa in unique(matDrugs_mostInteraction$process_broad)){
    subData = matDrugs_mostInteraction %>% filter(process_broad == moa) %>% select(-process_broad) %>% t()
    if(ncol(subData) > 1){
        for(i in 1:(ncol(subData)-1)){
            for(j in (i+1):ncol(subData)){
                resP = c(resP, cor(subData[,i], subData[,j]))
                resS = c(resS, cor(subData[,i], subData[,j], method = "spearman"))
            }
        }
    }
}
corData[["betweenMoA\nPearson"]] = resP
corData[["betweenMoa\nSpearman"]] = resS


matDrugs_mostInteraction = matDrugs_mostInteraction %>% select(-process_broad) %>% t()
# Correlation between Drugs
resP = c()
resS = c()
for(i in 1:(ncol(matDrugs_mostInteraction)-1)){
    for(j in (i+1):ncol(matDrugs_mostInteraction)){
        resP = c(resP, cor(matDrugs_mostInteraction[,i], matDrugs_mostInteraction[,j]))
        resS = c(resS, cor(matDrugs_mostInteraction[,i], matDrugs_mostInteraction[,j], method = "spearman"))
    }
}
corData[["betweenDrugs\nPearson"]] = resP
corData[["betweenDrugs\nSpearman"]] = resS



# Correlation between Dosages
resP = c()
resS = c()
for(d in unique(matDrugs_allDosages$drugname_typaslab)){
    subData = matDrugs_allDosages %>% filter(drugname_typaslab == d) %>% select(-drugname_typaslab) %>% t()
    if(ncol(subData) > 1){
        for(i in 1:(ncol(subData)-1)){
            for(j in (i+1):ncol(subData)){
                resP = c(resP, cor(subData[,i], subData[,j]))
                resS = c(resS, cor(subData[,i], subData[,j], method = "spearman"))
            }
        }
    }
}
corData[["betweenDosages\nPearson"]] = resP
corData[["betweenDosages\nSpearman"]] = resS


# ggplot can easily handle boxplot of list of vector of differents length, so let's do it the traditionnal way
par(mgp = c(3,2,0))    
boxplot(corData,
        at=c(1,2,4,5,7,8),
        col = rep(rainbow(2), times = 2), lwd = 1.5, outline = T, pch = 21
)
abline(h = 0, lty = "dotted")



```



Look at correlation between drugs chemical classes


# Details of drugs chemical classes

```{r}

full_matrix = matrix_container[2, ]$drug_feature_matrices[[1]]
tail(colnames(full_matrix), n = 14)
chem_feat = tail(colnames(full_matrix), n = 13)

labels = unique(full_matrix$drugname_typaslab)
chem_class = read.table(file = "data/drugs_chem_classes.txt", header = FALSE, sep = "\t", stringsAsFactors = FALSE)
chem_class = chem_class %>% filter(V1 %in% labels)


chem_class$V2 = unlist(lapply(chem_class$V2, function(x){ifelse(x== "", "others", x)}))

colnames(chem_class) = c("drugname_typaslab", "chem_class")
full_matrix = left_join(full_matrix, chem_class, by = "drugname_typaslab")
full_matrix = full_matrix %>% select(drugname_typaslab, process_broad, chem_class, chem_feat)
full_matrix = unique(full_matrix)
full_matrix = full_matrix %>% filter(chem_class %in% names(which(table(full_matrix$chem_class) >=2)))

for (feat in colnames(full_matrix)[-c(1,2,3)]) {
    boxplot(full_matrix[[feat]] ~ full_matrix$chem_class, main = feat)
}

```


```{r}


m = full_matrix %>% select(-drugname_typaslab, -process_broad, -chem_class)
pca_data <- prcomp(m, scale = TRUE)

barplot(pca_data$sdev / sum(pca_data$sdev))
sum((pca_data$sdev / sum(pca_data$sdev))[1:3])

plotData <- as.data.frame(pca_data$x)
plotData = cbind(plotData, process_broad = full_matrix$process_broad, chem_class = full_matrix$chem_class, names = full_matrix$drugname_typaslab)

plotData$process_broad[!(plotData$process_broad %in% c("cell_wall", "dna", "membrane_stress", "protein_synthesis"))] <- "other"

p <- plot_ly(plotData, x = ~PC1, y = ~PC2, z = ~PC3, color = ~chem_class, colors = rainbow(10)) %>%
  add_markers(text = paste(plotData$process_broad, plotData$names)) %>%
  layout(scene = list(xaxis = list(title = paste('PC1', as.character(round((pca_data$sdev / sum(pca_data$sdev))[1], digits = 3)))),
                     yaxis = list(title =  paste('PC2', as.character(round((pca_data$sdev / sum(pca_data$sdev))[2], digits = 3)))),
                     zaxis = list(title =  paste('PC3', as.character(round((pca_data$sdev / sum(pca_data$sdev))[3], digits = 3))))))


# ========================================================================================

cor(m)
# TOO MUCH !
for (feat in c("TPSA", "SlogP", "NumRings")) {
    boxplot(full_matrix[[feat]] ~ full_matrix$chem_class, main = feat)
}



# ========================================================================================

data = matrix_container[2, ]$drug_feature_matrices[[1]]  %>% select(-drugname_typaslab, -conc, -process_broad)

test  = corr_feat_selection(data = data)
matrix_container[2, ]$drug_feature_matrices[[1]] = matrix_container[2, ]$drug_feature_matrices[[1]] %>% select(drugname_typaslab, conc, process_broad, colnames(test))

x = ncol(test)
matrix_container[2, ]$hyperparam_grid[[1]] = makeParamSet(
                    makeDiscreteParam("ntree", values = c(200, 500)),
                    makeDiscreteParam("mtry", values = floor(c(x, x*(3/4), x/2, x/4, sqrt(x))))
                    )


```


# ROC Curves of one feature

```{r}

dt_mat = matrix_container[1, ]$drug_feature_matrices[[1]]

all_feat = colnames(dt_mat)[-c(1,2,3)]

areas = list()

for(f in all_feat){
    
    for (moa in c("cell_wall", "dna", "membrane_stress", "protein_synthesis")){
        cat(f, " - ", moa, "\n")
        a = ROC_curve_1feat(dt_mat = dt_mat, moa = moa, feat = f)
        areas[[moa]] = c(areas[[moa]], a$auc)
    }
}


```


# Old chunks from "Boosting_tree_results_overview.Rmd"

File was deleted on 2018-07-25. Some stuff may still be useful so keep it here. 

Wilcoxon test based feature selection: some features contain information, others don't: 

```{r boosting_tree_results_overview_legacy_I}
load("./run_results_from_server/result_XGBT_10topWilcox_allDrugs_tuneMMCE.RData")
load("./run_results_from_server/result_XGBT_10worstWilcox_allDrugs_tuneMMCE.RData")

compare_ROC_models(moa = "dna", result_XGBT_10topWilcox_allDrugs_tuneMMCE, 
                   result_XGBT_10worstWilcox_allDrugs_tuneMMCE)
```

Random forests plot: how OOB error changes with number of trees. Note that the error for "not" 
class goes down, the other error stays the same - class imbalance. 

```{r boosting_tree_results_overview_legacy_II}
plot_RF_perf_allRep = function(res = result_RF_10pc_allDrugs_tuneMMCE, moa = "dna"){
    res_all500 = matrix(0, nrow = 500, ncol = 3)
    res_all200 = matrix(0, nrow = 200, ncol = 3)
    nb500 = 0
    nb200 = 0
    
    plot(NULL, xlim = c(1,500), ylim = c(0,1), xlab = "Number of trees", ylab = "Error rate")
    for (i in 1:length(res)){
        for(j in 1:length(res[[1]])){
            rf_res = res[[i]][[j]][[paste0("model_",moa)]]$learner.model
            plot(rf_res, lty = 1, col = c("lightgrey", "lightblue", "orange"), add =T)
            if(dim(rf_res$err.rate)[1] == 500){
                res_all500 = res_all500 + rf_res$err.rate
                nb500 = nb500 +1
            }else{
                res_all200 = res_all200 + rf_res$err.rate
                nb200 = nb200 + 1
            }
        }
    }
    
    res200 = (res_all200 +res_all500[1:200,]) / (nb200 + nb500)
    res500 = res_all500 / nb500
    
    lines(res200[ ,1], lty = 1, lwd = 3, col = "black")
    lines(x = seq(201, 500), y = res500[201:500, 1], lty = 1, lwd = 3, col = "black")
    lines(res200[ ,2], lty = 1, lwd = 3, col = "blue")
    lines(x = seq(201, 500), y = res500[201:500, 2], lty = 1, lwd = 3, col = "blue")
    lines(res200[ ,3], lty = 1, lwd = 3, col = "red")
    lines(x = seq(201, 500), y = res500[201:500, 3], lty = 1, lwd = 3, col = "red")
    legend("topright", legend= colnames(res500), col=c("black", "blue", "red"), lwd=3, cex=1)  
}

load("./run_results_from_server/result_RF_10pc_allDrugs_tuneMMCE.RData")

plot_RF_perf_allRep(res = result_RF_10pc_allDrugs_tuneMMCE, moa = "dna")
plot_RF_perf_allRep(res = result_RF_10pc_allDrugs_tuneMMCE, moa = "cell_wall")
plot_RF_perf_allRep(res = result_RF_10pc_allDrugs_tuneMMCE, moa = "membrane_stress")
plot_RF_perf_allRep(res = result_RF_10pc_allDrugs_tuneMMCE, moa = "protein_synthesis")
```

This here is actually useful as a draft to mark a specific point on a ROC curve. Here, it shows the 
point with the highest MCC. 

```{r boosting_tree_results_overview_legacy_III}
load("./run_results_from_server/result_XGBT_10pc_allDrugs_tuneMMCE.RData")

my_res <- plot_ROC_optThres(result_XGBT_10pc_allDrugs_tuneMMCE, moa = "dna")
View(my_res$confMat)

ggsave(filename = "./plots/present_optThres.pdf", width = 14, height = 7, 
       plot = my_res$plot)
```


# Old chunks from "FeatureImp_RF_XGBT_results_overview.Rmd"

Like above: file was deleted on 2018-07-25, useful stuff can still be found here. That notebook was 
dealing mainly with feature importances and has been superseded by `Inspecting_models.Rmd` and 
`model_analysis.R`. 

Old heatmap plotting function. May be useful for other heatmaps. Was used to check if we can get 
MoA classification by doing a simple hierarchical clustering of all/a selected subset of 
(presumably) best features from the chemical genomics data. Need to provide some "the_matrix" 
object, which can still be found under ./data or in the drug_feature_matrices field from the 
matrix_container. Not sure if it runs like this though:

```{r eval = FALSE}
plot_heatmap <- function(m = the_matrix_allDrugs_top10pct, feats_to_keep = "all", filename = "heatmap.pdf") {
   library(gplots)
   library(RColorBrewer)
   # plots a heatmap for all drugs with only the features provided in the feats_to_keep argument
   cluster_matrix <- m
   row.names(cluster_matrix) <- cluster_matrix$drugname_typaslab
   cluster_matrix$drugname_typaslab <- NULL
   process_lut <- cluster_matrix$process_broad
   names(process_lut) <- row.names(cluster_matrix)
   cluster_matrix$process_broad <- NULL
   cluster_matrix <- as.matrix(cluster_matrix)

   # keep only genes in the columns because of measurement scale
   if (feats_to_keep != "all") {
      cluster_matrix <- cluster_matrix[, colnames(cluster_matrix) %in% feats_to_keep]
   }

   # get correlation-based distances between the drugs (--> transpose matrix)
   drug_drug_dist <- as.dist(1 - abs(cor(t(cluster_matrix))))
   gene_gene_dist <- as.dist(1 - abs(cor(cluster_matrix)))

   # define colors for the mode of action
   moa_to_colour <- c(cell_wall = "#a6cee3",
                      dna = "#1f78b4",
                      protein_synthesis = "#b2df8a",
                      membrane_stress = "#33a02c",
                      pmf = "#bababa", protein_qc = "#bababa", oxidative_stress = "#bababa"
                      )
   rowcols <- moa_to_colour[process_lut[rownames(cluster_matrix)]]

   pdf(paste0("./plots/", filename), width = 20, height = 20)
   heatmap.2(cluster_matrix,
             trace = "none",
             breaks = c(-10, -5, -3, -1, 0, 1, 3, 5, 10), # use this i/o zlim
             Rowv = as.dendrogram(hclust(drug_drug_dist)), # change order of rows
             Colv = as.dendrogram(hclust(gene_gene_dist)),
             RowSideColors = rowcols,
             margins = c(12, 9),
             dendrogram = "row") # only draw row dendrogram
   legend("top",
          legend = names(moa_to_colour),
          col = moa_to_colour,
          lty = 1,
          lwd = 10)
   dev.off()
}

plot_heatmap(m = the_matrix_allDrugs_top10pct, feats_to_keep = genes$gene_synonym, 
             filename = "heatmap_cordist_all.pdf")
# exclude SlogP:
features_of_interest <- features_of_interest[features_of_interest != "SlogP"]
# now with only the 'relevant' features:
plot_heatmap(m = the_matrix_allDrugs_top10pct, feats_to_keep = features_of_interest, 
             filename = "heatmap_cordist_most_imprtnt_rf.pdf")

```

Plotting feature importances using results objects. Were used to generate plots "present_sscore_dists.pdf" 
and "present_feat_imp${MOA}.pdf". 

```{r old_feature_importance_functions}
# make sure you loaded the results object from ./data
feat_RF_dna <- plot_feat_4model(res = result_RF_10pc_allDrugs_tuneMMCE, moa = "dna")
feat_RF_dna_dfr <- make_importance_dfr(feat_RF_dna, cutoff = 0.07)
plot_importance(feat_RF_dna_dfr, moa = "dna")
load("./data/the_matrix_newDrugs_top10pct.RData")
p <- feature_distrib_ggplot(the_matrix_newDrugs_top10pct, "RECA", save = FALSE)
p
```

Code to generate old to generate "ultimate_plot" files. 

```{r old_ultimate_plot eval = FALSE}
ultimate_plot(res =result_XGBT_10pc_allDrugs_tuneMMCE)

pdf(file = "~/Documents/recap_utlimate.pdf", width = 20, height = 30)
layout(matrix(seq(1,6), 3,2, byrow = T))
for(d in the_matrix_allDrugs$drugname_typaslab){
    distrib_drug_prob_small(res = result_RF_10pc_allDrugs_tuneMMCE, drug = d, dt_matrix = the_matrix_allDrugs)
    distrib_drug_prob_small(res = result_RF_5pc_allDrugs_tuneMMCE, drug = d, dt_matrix = the_matrix_allDrugs)
    distrib_drug_prob_small(res = result_XGBT_10pc_allDrugs_tuneMMCE, drug = d, dt_matrix = the_matrix_allDrugs)
    distrib_drug_prob_small(res = result_XGBT_5pc_allDrugs_tuneMMCE, drug = d, dt_matrix = the_matrix_allDrugs)
    distrib_drug_prob_small(res = result_XGBT_10topWilcox_allDrugs_tuneMMCE, drug = d, dt_matrix = the_matrix_allDrugs)
    distrib_drug_prob_small(res = result_RF_27feat_allDrugs_tuneMMCE, drug = d, dt_matrix = the_matrix_allDrugs)
}
dev.off()
```












