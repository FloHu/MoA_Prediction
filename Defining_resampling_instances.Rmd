---
title: "Predicting drug mode of action: Defining resampling instances"
author: "Florian Huber, Leonard Dubois"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_caption: yes
    fig_height: 6
    fig_width: 6
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
editor_options: 
  chunk_output_type: console
---

# Setup

```{r setup}
# function to check if a package is installed, if so, load it, else install and then load it
source("./R/ipak.R")
# set chunk options and load libraries
source("./setup.R")
# custom functions
walk(list.files("./R", pattern = "*.R", full.names = T), source)

matrix_container <- readRDS("./data/programmatic_output/matrix_container.rds")
```


# Aim of notebook: defining sampling instances - motivation

In order to compare performances of different models (e.g. Random Forest, Boosting trees...), one 
has to use the *exact same samples in every fold* (inner and outer) of the nested cross-validation.

The function `makeResampleInstance()` could be used to keep in memory a object containing details 
on the sampling. For a 5-fold by 5-fold nested cross-validation, 6 resampling instances are needed: 
one for each inner fold and one for the outer loop. In particular, instances of the inner fold 
should be based on the training sets defined in the outer loop instances.

Even if such a strategy can't be avoided in order to obtain an unbiased comparison of models, it 
still presents some weaknesses : one can easily argue that the chosen instances are the ones giving 
the best performances. To prevent such criticism, a repeated cross validation is possible, e.g. 
10 times. 

Thus, the exact strategy for assessing models' performances and comparing them could be called: 
**Repeated nested cross-validation with instanced stratified resampling**


## Generating instances

Since we have a small data set, it is actually better to use more folds. Thus, the training set 
will contain more individuals. The testing set results can be concatenated afterwards, with each 
individual having been predicted by a model in which it was not trained. 

Function for instance creation:

```{r instance_creation_function}
# getter functions
get_outer_train_ids <- function(NCV_sampling, rep_nb){
    NCV_sampling[[rep_nb]]$outer$train.inds
}

get_inner_train_ids <- function(NCV_sampling, rep_nb, outer_nb){
    NCV_sampling[[rep_nb]]$inner[[outer_nb]]$train.inds
}

instance_creation <- function(dataset, printTest = F, nFoldsOuter = 8, nFoldsInner = 8){
    dataset = select(dataset, -drugname_typaslab)
    sampling_method = makeResampleDesc(method = "CV", iters = nFoldsOuter, stratify = TRUE)
    
    # outer instance
    outer_task =  makeClassifTask(data = dataset, target = "process_broad")
    sample_instance_outer =  makeResampleInstance(sampling_method, outer_task)
    
    if(printTest){
        # Testing stratification of outer instance
        for(i in 1:nFoldsOuter){
            cat("Fold", i, "- Train and test sets\n" )
            ind = sample_instance_outer$train.inds[[i]]
            print(table(dataset[ind, "process_broad"]))
            ind = sample_instance_outer$test.inds[[i]]
            print(table(dataset[ind, "process_broad"]))
        }
    }
    
    # defining inner instances
    sampling_method = makeResampleDesc(method = "CV", iters = nFoldsInner, stratify = TRUE)
    sample_instance_inner = list()
    for(i in 1:nFoldsOuter){
        # New task using a subset of the whole dataset defined by outer training set ID
        inner_task = makeClassifTask(data = dataset[sample_instance_outer$train.inds[[i]], ], 
                                     target = "process_broad")
        sample_instance_inner[[i]] = makeResampleInstance(sampling_method, inner_task)
    }
    
    if(printTest){
       # Testing stratification of inner instances
       # BE CAREFUL !!!
       # Indexes of individuals in the inner fold are the indexes of the vector of indexes of the 
       # corresponding outer fold 
        for (j in 1:nFoldsOuter ){
            outer_ind = sample_instance_outer$train.inds[[j]]
            cat("Outer fold", j, "\n")
            print(table(dataset[outer_ind, "process_broad"] ))
            cat("Inner folds \n")
            for (i in 1:nFoldsInner){
                ind = c(sample_instance_inner[[j]]$train.inds[[i]], sample_instance_inner[[j]]$test.inds[[i]])
                print(table(dataset[outer_ind[ind], "process_broad"]))
            }
        }
    }

    nested_CV_instance = list(outer = sample_instance_outer, inner = sample_instance_inner)
    return(nested_CV_instance)
}
```

Actually creating the instance: 'new' drugs = updated drug labels from 05/2018.

```{r making_nested_cvinst_onedosg}
Rep_Nest_CV_instance_newDrugs = list()

dataset_newDrugs = 
   filter(matrix_container, drug_dosages != "all") %>% 
   select(drug_feature_matrices) %>% 
   `[[`(1,1)

dataset_newDrugs$process_broad <- 
   ifelse(dataset_newDrugs$process_broad %in% c("oxidative_stress", "pmf", "protein_qc"), 
          "other", 
          dataset_newDrugs$process_broad)

for(i in 1:10){
    name = paste("NCV_", as.character(i), sep="")
    Rep_Nest_CV_instance_newDrugs[[name]] <- 
       instance_creation(dataset = dataset_newDrugs, printTest = FALSE)
}
```


### Expanding resampling instance to all dosages

The idea here is to copy the resampling object and map individuals IDs from the newDrug dataset to 
the drugs names and then remap the names to the individuals IDs of the allDosage dataset. One 
should also make the size fields in the lists match the length of vector of IDs. 

Mapping function:

```{r mapping_function}
# AIM : This function creates some extended version of a Resampling instance by mapping drugnames to 
# a full dataset containing all the dosages
# INPUT : A resampling instance with one dosage for each drugs 
#       + A dataset with several dosages for the same drugs 
# OUTPUT : A new resampling instance, blocked with drug based on the name

RepNCV_instance_map_drugname = function(instance_oneDrug, dataset_oneDosage, dataset_allDosage, 
                                        DEBUG = FALSE){

    # THe new resampling object will be like the first one but extended   
    Rep_Nest_CV_instance_allDosage = instance_oneDrug
    
    # For each repetition
    for(i in 1:length(Rep_Nest_CV_instance_allDosage)){
        
        # OUTER FOLD RESAMPLING MAPPING
        # ====== Training sets ======
        # drugNameSet = name of individuals/drugs in the training set based on the ID
        drugNameSet_outer_train = map(get_outer_train_ids(instance_oneDrug, rep_nb = i), 
                                      function(x) {dataset_oneDosage[x, "drugname_typaslab"]})
        # then get all IDs linked to these name in the full dataset
        allDosage_indexes = map(drugNameSet_outer_train, 
                                function(x) {
                                   which(dataset_allDosage$drugname_typaslab %in% x$drugname_typaslab)
                                })
        Rep_Nest_CV_instance_allDosage[[i]]$outer$train.inds = allDosage_indexes 
        # ====== Testing sets ======
        # Just use setdiff, what's not in the training set is in the test set
        allDosage_indexes_test = map(allDosage_indexes, 
                                     function(x) {setdiff(seq(1, nrow(dataset_allDosage)), x)})
        Rep_Nest_CV_instance_allDosage[[i]]$outer$test.inds = allDosage_indexes_test
        #Size mapping
        Rep_Nest_CV_instance_allDosage[[i]]$outer$size = nrow(dataset_allDosage)
        
        if(DEBUG){
            print(Rep_Nest_CV_instance_allDosage[[i]]$outer$train.inds)
            a = map(Rep_Nest_CV_instance_allDosage[[i]]$outer$train.inds, 
                    function(x) {unique(dataset_allDosage[x , ]$drugname_typaslab)})
            b = map(instance_oneDrug[[i]]$outer$train.inds, 
                    function(x) {dataset_oneDosage[x , ]$drugname_typaslab})
            print(map2(.x = a, .y = b, .f = function(x,y) {print(setdiff(y,x))}))
        }
        
        # NEVER MAP INNER IDS DIRECTLY TO THE DATASET, ALWAYS MAP THEM FIRST TO OUTER ID  !!!
        # INNER FOLDS RESAMPLING MAPPING
        for(outer in 1:length(get_outer_train_ids(instance_oneDrug, rep_nb = i))) {
            
            # ====== Training sets ======
            innerID = get_inner_train_ids(NCV_sampling = instance_oneDrug, rep_nb = i, outer_nb = outer)
            outerID = get_outer_train_ids(NCV_sampling = instance_oneDrug, rep_nb = i)[[outer]]
            innerID_to_rawData = map(.x = innerID, .f = function(x){ outerID[x]})
            
            drugNameSet_inner_train = map(innerID_to_rawData, 
                                          function(x) {dataset_oneDosage[x, "drugname_typaslab"]})
            # Here we got names of the drugs that should be in the inner training sets

            # Extract a subset of raw dataset based on outer training id and select names of this subset
            dataset_outer_train = 
               dataset_allDosage[get_outer_train_ids(NCV_sampling = Rep_Nest_CV_instance_allDosage, rep_nb = i)[[outer]], ]$drugname_typaslab
            
            allDosage_indexes = map(drugNameSet_inner_train, function(x) {
               which(dataset_outer_train %in% x$drugname_typaslab) 
            })
            
            Rep_Nest_CV_instance_allDosage[[i]]$inner[[outer]]$train.inds = allDosage_indexes  
            
            if(DEBUG){
                print(Rep_Nest_CV_instance_allDosage[[i]]$inner[[outer]]$train.inds)
                
                allDosageName_inner = map(.x = get_inner_train_ids(NCV_sampling = Rep_Nest_CV_instance_allDosage, rep_nb = i, outer_nb = outer),
                                          .f = function(x) {
                                              unique(dataset_allDosage[(get_outer_train_ids(Rep_Nest_CV_instance_allDosage, rep_nb = i)[[outer]])[x], ]$drugname_typaslab)
                                          })
                
                newDrugsName_inner = map(.x = get_inner_train_ids(NCV_sampling = instance_oneDrug, rep_nb = i, outer_nb = outer),
                                         .f = function(x) {
                                             unique(dataset_oneDosage[(get_outer_train_ids(instance_oneDrug, rep_nb = i)[[outer]])[x], ]$drugname_typaslab)
                                         })
                
                print(map2(.x = allDosageName_inner, .y = newDrugsName_inner, .f = function(x,y) {print(setdiff(y, x))}))
            }
            
            # ====== Testing sets ======
            allDosage_indexes_test = 
               map(allDosage_indexes, function(x) {setdiff(seq(1, length(dataset_outer_train)), x)})
            Rep_Nest_CV_instance_allDosage[[i]]$inner[[outer]]$test.inds = allDosage_indexes_test
            Rep_Nest_CV_instance_allDosage[[i]]$inner[[outer]]$size = length(dataset_outer_train)
        }
    }
    return(Rep_Nest_CV_instance_allDosage)
}
```


Actual generation of nested cv instance for all dosages from the one with one dosage:

```{r making_nested_cvinst_alldosg}
dataset_allDosage = 
   filter(matrix_container, drug_dosages == "all") %>% 
   select(drug_feature_matrices) %>% 
   `[[`(1,1)

dataset_allDosage$process_broad <- 
   ifelse(dataset_allDosage$process_broad %in% c("oxidative_stress", "pmf", "protein_qc"), 
          "other", 
          dataset_allDosage$process_broad)

Rep_Nest_CV_instance_allDosage = Rep_Nest_CV_instance_newDrugs

Rep_Nest_CV_instance_allDosage = 
   RepNCV_instance_map_drugname(instance_oneDrug = Rep_Nest_CV_instance_newDrugs, 
                                dataset_oneDosage = dataset_newDrugs, 
                                dataset_allDosage = dataset_allDosage)
```


## Test functions

For each repeat, need to make sure that:
1. The number of indices corresponds to the number of observations.
2. Each drug ends up in the test set of the outer loop exactly once.
3. For each training test split of the outer loop only those drugs end up in the training set that 
are not in the test set. 
4. Observations that are just different dosages of the same drug should move together: both in 
the outer and in all the inner CV instances.
5. Stratification should be respected.

```{r cv_instance_testfunctions}
# all these functions work similarly: pass a nested cv instance + the corresponding data set

cvtest_check_n_obs <- function(nest_cvinst, data) {
   # checks if a cv instance has the same length as there are observations in the data
   # after that it checks if inner resampling instance has the same size as the size of the 
   # training set of the corresponding outer resampling instance
   required_length <- nrow(data)
   is_ok <- TRUE
   if (nest_cvinst$outer$size != required_length) {
      stop("Mismatch between cv instance size and number of data points")
      is_ok <- FALSE
   }
   
   if (!all(lengths(nest_cvinst$outer$train.inds)
       ==
       map_dbl(nest_cvinst$inner, "size"))) {
      stop("Mismatch between inner cv size and size of outer training set")
      is_ok <- FALSE
   }
   
   return(is_ok)
   # return(all(required_length == map_chr(cvinst, c("outer", "size"))))
}

cvtest_check_indices <- function(nest_cvinst, data) {
   ## make sure that no values occur twice in all the training/test splits
   # for outer instance:
   required_length <- nrow(data)
   is_ok <- TRUE
   
   # for each outer cv instance, make sure that no values occur twice
   inds <- map2(nest_cvinst$NCV_1$outer$train.inds, nest_cvinst$NCV_1$outer$test.inds, ~sort(c(.x, .y)))
   all(map_lgl(inds, function(.x) {
      if (!all(rle(.x)$lengths == 1) && all(rle(.x)$values) <= required_length) {
         stop("Error in train/test set splits (outer CV)")
         is_ok <- FALSE
      }
   }))
   
   # same for each inner cv instance
   inds <- map(nest_cvinst$inner, function(.x) {
      map2(.x[["train.inds"]], .x[["test.inds"]], ~sort(c(.x, .y)))
   })
   inds <- flatten(inds)
   if (!all(flatten_int(map(inds, function(.x) rle(.x)$lengths == 1)))) {
      stop("Error in train/test set splits of one of the inner CVs")
      is_ok <- FALSE
   }
   return(is_ok)
}

cvtest_check_blocking <- function(nest_cvinst, data) {
   # this function tests if blocking is respected
   
   # this is a list of indices that shouldn't be torn apart
   the_indivisible <- list()
   for (drugname in unique(data$drugname_typaslab)) {
      the_indivisible[[drugname]] <- which(drugname == data$drugname_typaslab)
   }
   
   check_exclusivity <- function(vec, train_test_pair) {
      # returns TRUE only if the elements of vec are found in either the first or the second element 
      # or in none of the elements of train_test pair, and FALSE if in both
      stopifnot(length(train_test_pair) == 2 || is.list(train_test_pair) || all(sapply(train_test_pair, is.numeric)))
      stopifnot(is.atomic(vec) || (!is.numeric(vec)))
      # think De Morgan!
      return(!all(vec %in% train_test_pair[[1]]) || !all(vec %in% train_test_pair[[2]]))
   }
   
   check_blocking <- function(cvinst, indexlist) {
      # function that "checks exclusivity" for a given CV instance
      # takes a list of indices and checks that in cvinst they are either in the training or the 
      # test set but not both
      is_ok <- TRUE
      train_test_pairs <- transpose(list(cvinst$train.inds, cvinst$test.inds))
      for (i in seq_along(indexlist)) {
         if (! all(map_lgl(train_test_pairs, check_exclusivity, vec = indexlist[[i]]))) {
            warning("An element was found in both the training and the test set (", names(indexlist)[i], ")!\n")
            is_ok <- FALSE
            break
         }
      }
      invisible(is_ok)
   }
   
   check_blocking(nest_cvinst$outer, indexlist = the_indivisible)
   
   # and now the same for the inner instances
   # first we need to translate the inner indices to the correct outer indices 
   # (inner indices correspond to indices of the vector "training.inds" of the corresponding outer 
   # training set)
   # within each inner instance: for each train/test pair needs to be matched up with the 
   # right outer training set indices
   
   # ensure we have the same amount of inner cv instances as training sets in the outer instance
   stopifnot(length(nest_cvinst$outer$train.inds) == length(nest_cvinst$inner))
   matching_numbers <- seq_len(length(nest_cvinst$outer$train.inds))
   
   for (m in matching_numbers) {
      outer_indices <- nest_cvinst$outer$train.inds[[m]]
      inner_inst <- nest_cvinst$inner[[m]]
      # map indices back
      inner_inst$train.inds <- map(inner_inst$train.inds, ~outer_indices[.x])
      inner_inst$test.inds <- map(inner_inst$test.inds, ~outer_indices[.x])
      
      # and now replace with 'correct' cv instance
      nest_cvinst$inner[[m]] <- inner_inst
   }
   
   # so now that the inner cv instances have been 'repaired' we can check_blocking() for each inner 
   # instance

   map_lgl(nest_cvinst$inner, check_blocking, indexlist = the_indivisible)
}

# this function is designed for visual inspection
cvtest_report_stratification <- function(nest_cvinst, data, return_as_table = TRUE) {
   # take a nested cv instance and corresponding data, then report how the different classes where 
   # split into training and test set
   # return_as_table: switch, if TRUE get back a table, otherwise the underlying data frame
   report_tables <- list()
   
   data$process_broad <- ifelse(data$process_broad %in% c("cell_wall", "dna", "membrane_stress", 
                                                          "protein_synthesis"), 
                                data$process_broad, 
                                "other")
   
   make_table <- function(cvinst, return_as_table) {
      train_test_pairs <- transpose(list(cvinst$train.inds, cvinst$test.inds), .names = letters[1:8])
      train_test_pairs <- map(train_test_pairs, function(.x) {names(.x) <- c('train', 'test'); return(.x)})
      train_test_pairs <- map(train_test_pairs, ~ unnest(enframe(.x)))
      
      train_test_pairs <- map2_dfr(train_test_pairs, names(train_test_pairs), function(.x, .y) {
         .x$split <- .y
         return(.x)
      })
      
      train_test_pairs$drugname <- data$drugname_typaslab[train_test_pairs$value]
      train_test_pairs$value <- data$process_broad[train_test_pairs$value]
      train_test_pairs <- select(train_test_pairs, value, name, split, drugname)
      names(train_test_pairs) <- c("MoA", "test.or.train", "split", "drugname")
      if (return_as_table) {
         train_test_pairs <- ftable(train_test_pairs[, c("MoA", "test.or.train", "split")])
      }
      return(train_test_pairs)
   }
   
   # translate inner indices to outer ones (see also 'cvtest_check_blocking')
   stopifnot(length(nest_cvinst$outer$train.inds) == length(nest_cvinst$inner))
   matching_numbers <- seq_len(length(nest_cvinst$outer$train.inds))
   
   for (m in matching_numbers) {
      outer_indices <- nest_cvinst$outer$train.inds[[m]]
      inner_inst <- nest_cvinst$inner[[m]]
      # map indices back
      inner_inst$train.inds <- map(inner_inst$train.inds, ~outer_indices[.x])
      inner_inst$test.inds <- map(inner_inst$test.inds, ~outer_indices[.x])
      
      # and now replace with 'correct' cv instance
      nest_cvinst$inner[[m]] <- inner_inst
   }
   
   report_tables[["outer"]] <- make_table(nest_cvinst$outer, return_as_table = return_as_table)
   report_tables[["inner"]] <- map(nest_cvinst$inner, make_table, return_as_table = return_as_table)
   return(report_tables)
}

cvtest_all_drugs_in_test <- function(nest_cvinst, data) {
   le_report <- cvtest_report_stratification(nest_cvinst, data, FALSE)
   
   check_table <- function(table) {
      all(unique(table$drugname) %in% table$drugname[table$test.or.train == "test"])
   }
   
   checks <- logical(length = 9)
   checks[1] <- check_table(le_report$outer)
   checks[2:9] <- map_lgl(le_report$inner, check_table)
   all(checks)
}

# master function
run_cv_tests <- function(rep_nest_cvinst, data) {
   cv_tests_report <- list()
   
   cv_tests_report$cvtest_check_n_obs <- 
      map_lgl(rep_nest_cvinst, cvtest_check_n_obs, data = data)
   
   cv_tests_report$cvtest_check_indices <- 
      map_lgl(rep_nest_cvinst, cvtest_check_indices, data = data)
   
   cv_tests_report$cvtest_check_blocking <- 
      map(rep_nest_cvinst, cvtest_check_blocking, data = data)
   
   cv_tests_report$cvtest_all_drugs_in_test <- 
      map_lgl(rep_nest_cvinst, cvtest_all_drugs_in_test, data = data)
   
   if (!all(unlist(cv_tests_report))) {
      cat("Potential problem with CV instance detected.")
      return(cv_tests_report)
   } else {
      invisible(TRUE)
   }
}
```

Running the actual tests:

```{r testing_cvinsts_I}
# we have two types of data frames in terms of number of samples: one with all dosages, one with 
# most interactions
# just keep the columns that we need
(the_matrix_all <- matrix_container$drug_feature_matrices[[3]][, 1:3])
(the_matrix_mostias <- matrix_container$drug_feature_matrices[[180]][, 1:3])

run_cv_tests(Rep_Nest_CV_instance_newDrugs, the_matrix_mostias)
run_cv_tests(Rep_Nest_CV_instance_allDosage, the_matrix_all)
```


We already have some nested cv instances - those that were used in the matrix_container:

```{r testing_cvinsts_II}
stopifnot(file.exists("./data/programmatic_output/Rep_Nest_CV_instance_newDrugs.RData") && 
             file.exists("./data/programmatic_output/Rep_Nest_CV_instance_allDosage.RData"))

oldname <- load("./data/programmatic_output/Rep_Nest_CV_instance_newDrugs.RData")
cvinst_mostias <- get(oldname)
rm(oldname)

oldname <- load("./data/programmatic_output/Rep_Nest_CV_instance_allDosage.RData")
cvinst_alldosg <- get(oldname)
rm(oldname)

run_cv_tests(cvinst_mostias, the_matrix_mostias)
run_cv_tests(cvinst_alldosg, the_matrix_all)

# these are indeed the cv instances used in matrix_container:
all(map_lgl(matrix_container$resamp_instance[matrix_container$drug_dosages == "most_interactions"], 
            ~identical(.x, cvinst_mostias)))
all(map_lgl(matrix_container$resamp_instance[matrix_container$drug_dosages == "all"], 
            ~identical(.x, cvinst_alldosg)))


# an example instance + data set
nest_cvinst <- cvinst_alldosg$NCV_1
data <- the_matrix_all

# something's strange, e.g. in the first split there is one observation for cell_wall 
# in the most interactions thing and 7 observations in the all dosages thing
# (even though the all dosage instance generation works by mapping ...)
cvtest_report_stratification(cvinst_alldosg$NCV_1, the_matrix_all)$outer
cvtest_report_stratification(cvinst_mostias$NCV_1, the_matrix_mostias)$outer

# to be more precise:
tab <- cvtest_report_stratification(cvinst_mostias$NCV_1, the_matrix_mostias, FALSE)$outer
filter(tab, test.or.train == "test", MoA == "cell_wall", split == "a")

# whereas
tab2 <- cvtest_report_stratification(cvinst_alldosg$NCV_1, the_matrix_all, FALSE)$outer
filter(tab2, test.or.train == "test", MoA == "cell_wall", split == "a")

# no idea why - since all the other tests are passed, however, I wouldn't change anything here now 
```


<!--
# Resampling instance - 2 mostIA dosages + main MoA

Load the matrix, get rid of doubles, run once the instance creation and run again the chunk above 
to map dosages together.

```{r echo = FALSE, eval = FALSE}

matrix_2mostia_mainMoa = readRDS(file = "data/matrix_2mostia_mainMoA.rds")
Rep_Nest_CV_instance = list()
unique_pos = match(unique(matrix_2mostia_mainMoa$drugname_typaslab), matrix_2mostia_mainMoa$drugname_typaslab)
dataset = matrix_2mostia_mainMoa[unique_pos, ] 

# Create a simple resampling instance with one dosage (it can thus be stratified)
for(i in 1:10){
    name = paste("NCV_", as.character(i), sep="")
    Rep_Nest_CV_instance[[name]] = instance_creation(dataset = dataset, printTest = F)
}

# Extend the ressmapling instance to add oth drug dosages in the right sampling set : Thus it becomes also a blocked CV
Rep_Nest_CV_instance_allDosage = RepNCV_instance_map_drugname(instance_oneDrug = Rep_Nest_CV_instance, dataset_oneDosage = dataset, dataset_allDosage = matrix_2mostia_mainMoa)

saveRDS(object = Rep_Nest_CV_instance_allDosage, file = "data/RNCV_instance_2mostia_mainMoa.rds")
```
-->


## Saving data

```{r saving_data}
if (! file.exists("./data/programmatic_output/Rep_Nest_CV_instance_newDrugs.RData")) {
   save(Rep_Nest_CV_instance_newDrugs, file = "./data/programmatic_output/Rep_Nest_CV_instance_newDrugs.RData")
}

if (! file.exists("./data/programmatic_output/Rep_Nest_CV_instance_allDosage.RData")) {
   save(Rep_Nest_CV_instance_newDrugs, file = "./data/programmatic_output/Rep_Nest_CV_instance_allDosage.RData")
}
```


## System and session info

```{r}
R.Version
sessionInfo()
```

