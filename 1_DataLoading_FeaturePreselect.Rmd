---
title: "Predicting drug mode of action: loading data and preselecting features"
author: "Florian Huber, Leonard Dubois"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_caption: yes
    fig_height: 6
    fig_width: 6
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
editor_options: 
  chunk_output_type: console
---

# Setup, library loading

```{r}
rm(list = ls())
# function to check if a package is installed, if so, load it, else install and then load it
source("./R/ipak.R")
# set chunk options and load libraries
source("./setup.R")

# custom functions
walk(list.files("./R", pattern = "*.R", full.names = T), source)
```


# Loading and merging data

In all subsequent cases, the final goal is to have a matrix with the drugs in the rows and the 
features in the columns. We will refer to such a matrix as a `drug_feature_matrix`. In the next 
section we will generate different "versions" of this matrix, differing, for example, in the number 
of drugs or features selected or whether features were transformed in some way.


## Reading in and joining of tables, common preprocessing operations

```{r}
nichols_2011 <- read.table("/Volumes/typas/Florian/dbsetup_tables/nichols_2011.csv", header = T, 
                           sep = ";", stringsAsFactors = F)
strains <- read.table("/Volumes/typas/Florian/dbsetup_tables/strains.csv", header = T, 
                           sep = ";", stringsAsFactors = F)
strains_has_genes <- read.table("/Volumes/typas/Florian/dbsetup_tables/strains_has_genes.csv", 
                                header = T, sep = ";", stringsAsFactors = F)
genes <- read.table("/Volumes/typas/Florian/dbsetup_tables/genes.csv", header = T, sep = ";", 
                    stringsAsFactors = F)
# generated in project dbsetup using KNIME
drugs_full <- read.table("/Volumes/typas/Florian/dbsetup_tables/drugs.csv", header = T, 
                         sep = ";", stringsAsFactors = F, dec = ".")
drugs_full$X <- NULL
mode_of_action <- read.table("/Volumes/typas/Florian/dbsetup_tables/mode_of_action.csv", 
                             header = T, sep = ";", stringsAsFactors = F)
```

Add gene information to Nichols table, remove unnecessary columns.

```{r}
the_matrix <- 
   nichols_2011 %>%
   left_join(strains[, c("strain"), drop = F]) %>%
   left_join(strains_has_genes[, c("strain", "ugi")]) %>%
   left_join(genes[, c("ugi", "gene_synonym")]) %>%
   select(gene_synonym, drugname_typaslab, conc, sscore, qvalue, strain) 
    
the_matrix$significant <- the_matrix$qvalue <= 0.05
```

Join drug tables with mode of action information.

```{r}
drugs_full <- left_join(drugs_full, mode_of_action[, c("moa_id", "process_broad")]) %>%
   select(-moa_id)

the_matrix <- filter(the_matrix, drugname_typaslab %in% drugs_full$drugname_typaslab)
```

If a gene doesn't interact with any drug, exclude it.

```{r}
the_matrix <- the_matrix %>%
   group_by(gene_synonym) %>% 
   filter(any(significant)) %>%
   ungroup()
```

This leaves us with `r length(unique(the_matrix$gene_synonym))` genes. Only a very small fraction 
of gene drug combinations are missing (less than 0.1%):

```{r}
t <- table(the_matrix$gene_synonym, the_matrix$drugname_typaslab)
sum(t == 0) / (nrow(t) * ncol(t))
```

For essential genes there were sometimes several hypomorphic mutants. We just want to keep one of 
them: always the one with most phenotypes over all conditions.

```{r}
the_matrix <- 
   group_by(the_matrix, gene_synonym) %>%
   do(select_mutant(.))

saveRDS(the_matrix, file = "./data/the_matrix_after_select_mutant.rds")

tmp <- group_by(the_matrix, gene_synonym) %>% 
   mutate(n = length(unique(strain))) %>%
   ungroup() %>%
   select(n)
stopifnot(all(tmp$n == 1))
rm(tmp)
```

Restructure the matrix to put drugs into rows, genes into columns. 

```{r}
# we need a matrix just indicating the significant s-scores for later on
the_matrix_signifs <- the_matrix

the_matrix <- select(the_matrix, gene_synonym, drugname_typaslab, conc, sscore)
the_matrix <- spread(the_matrix, key = gene_synonym, value = sscore)

the_matrix_signifs <- select(the_matrix_signifs, gene_synonym, drugname_typaslab, conc, significant)
the_matrix_signifs <- spread(the_matrix_signifs, key = gene_synonym, value = significant, fill = FALSE)
```

We replace all NA values with the median of all s-scores over all conditions for a particular 
mutant. `the_matrix` now contains all drug dosages and all mutants from nichols_2011 and forms the 
basis for all other derived matrices. 

```{r}
# check if all drug names are defined 
stopifnot(!any(is.na(the_matrix$drugname_typaslab)))
sel <- grep(colnames(the_matrix), pattern = "drugname_typaslab|conc")

the_matrix[, -sel] <- lapply(the_matrix[, -sel], function(x) {
   x[is.na(x)] <- median(x, na.rm = T)
   return(x)
})

if (any(sapply(the_matrix, is.na))) {
   stop("Undefined values present in the_matrix.")
}
```


# Generating different 'versions' of our matrix

## Drug selection and drug classification procedures

### Dosage selection

#### Approach 1: "`most_interactions`" 
Selects for each drug the one dosages with the highest number of significant interactions. If none 
or all are, keep the highest dosage. 

```{r}
selector <- 
   the_matrix_signifs %>%
   group_by(drugname_typaslab) %>%
   arrange(conc, .by_group = TRUE) %>%
   do(select_dosage_most_ias(.)) %>%
   ungroup() %>%
   pull(selector)

selector_2dosages <- 
   the_matrix_signifs %>%
   group_by(drugname_typaslab) %>%
   arrange(conc, .by_group = TRUE) %>%
   do(select_dosage_most_ias_2(.)) %>%
   ungroup() %>%
   pull(selector)

the_matrix <- the_matrix %>%
   group_by(drugname_typaslab) %>%
   arrange(conc, .by_group = TRUE) %>%
   ungroup()

the_matrix_alldosgs_nochemfeats <- the_matrix
the_matrix_mostias_nochemfeats <- the_matrix[selector, ]
the_matrix_mostias_nochemfeats_2dosages <- the_matrix[selector_2dosages, ]
```


## Collecting data in a data frame with list columns

```{r}
matrix_container <- 
   tibble(datasets_included = list("nichols_2011", "nichols_2011"), 
          drug_dosages = c("all", "most_interactions"), 
          feat_preselect = c("keepall", "keepall"), 
          chemical_feats = c(FALSE, FALSE), 
          drug_feature_matrices = list(the_matrix_alldosgs_nochemfeats, the_matrix_mostias_nochemfeats))
```


## Feature selection and transformation procedures

### Selecting features with the highest variance

#### Top x per cent features

Sort features (i.e. mutants = genes here) by variance and select top x %. 

```{r}
variances_to_select <- c(5, 10, 15, 20, 25, 30, 40, 50)

# add some datasets to our matrix_container: for the table using all dosages, we want to select 
# the genes which have the highest variance (top x%)
targetrow <- match("all", matrix_container$drug_dosages)
for (v in variances_to_select) {
   tmp_row <- matrix_container[targetrow, ] # = row containing matrix with all drug dosages => let's do feature preselection
   tmp_mat <- tmp_row$drug_feature_matrices[[1]]
   tmp_mat <- feature_selection_variance(tmp_mat, featStart = 3, percentTop = v)
   tmp_row$drug_feature_matrices[[1]] <- tmp_mat # replace the matrix
   tmp_row$feat_preselect <- paste0("top", v, "pct") # update metadata
   matrix_container <- bind_rows(matrix_container, tmp_row) # and update our data container
}

# repeat the same thing with the table that doesn't have all dosages but only those dosages with 
# most interactions in the chemical genomics data
# I know, code repetition - shame! but I really want to be explicit here
(targetrow <- match("most_interactions", matrix_container$drug_dosages))
for (v in variances_to_select) {
   tmp_row <- matrix_container[targetrow, ] # = row containing matrix with all drug dosages => let's do feature preselection
   tmp_mat <- tmp_row$drug_feature_matrices[[1]]
   tmp_mat <- feature_selection_variance(tmp_mat, featStart = 3, percentTop = v)
   tmp_row$drug_feature_matrices[[1]] <- tmp_mat # replace the matrix
   tmp_row$feat_preselect <- paste0("top", v, "pct") # update metadata
   matrix_container <- bind_rows(matrix_container, tmp_row) # and update our data container
}
```

### Adding chemical features

Don't use all chemical features from KNIME. Make tables with and without chemical features

```{r}
# check if all drugs in all tables are in our 'drugs_full' table
stopifnot(
   all(
      unique(flatten_chr(map(matrix_container$drug_feature_matrices, "drugname_typaslab")))
      %in%
      drugs_full$drugname_typaslab
   )
)

drugs_full_selected_features <- drugs_full[, c("drugname_typaslab", "SlogP", "LabuteASA", "TPSA", 
                                               "ExactMW", "NumLipinskiHBA", "NumLipinskiHBD", 
                                               "NumRotatableBonds", "NumAmideBonds", 
                                               "NumRings", "NumAromaticRings", "NumSaturatedRings", 
                                               "NumAliphaticRings", "data_effective_rotor_count")]

# take whole matrix_container, add chemical features, update metadata and rbind to old container
matrix_container <- 
   matrix_container %>%
   mutate(drug_feature_matrices = map(drug_feature_matrices, left_join, drugs_full_selected_features), 
          chemical_feats = TRUE, 
          datasets_included = map(datasets_included, append, "knime")) %>%
   bind_rows(matrix_container) %>%
   arrange(drug_dosages, feat_preselect, chemical_feats)
```


## Adding drug classification = mode of action information, generate dfr with list columns

```{r}
my_labels <- drugs_full[, c("drugname_typaslab", "process_broad")]
my_labels_knowndrugs <- my_labels[my_labels$process_broad != "unknown", ]

# remove unknown drugs, then add MoA information
matrix_container <- 
   matrix_container %>%
   mutate(drug_feature_matrices = map(drug_feature_matrices, semi_join, my_labels_knowndrugs)) %>%
   mutate(drug_feature_matrices = map(drug_feature_matrices, left_join, my_labels))

# arrange rows nicely
matrix_container$drug_feature_matrices <- 
   map(matrix_container$drug_feature_matrices, select, drugname_typaslab, conc, process_broad, everything())
```

## Adding model and hyperparameter specifications

For all of the above drug-feature matrices we want to run the following:
- random forests with a number of trees and mtry values
- boosted trees in 3 flavours: (i) 'normal' parameters changed, (ii) testing regularisation, (iii) 
  trying out subsample parameters
- lasso regression

```{r}
matrix_container.bak <- matrix_container
matrix_container_tmp <- matrix_container

# stuff common to all: tuning measures, CV instances
load("./data/Rep_Nest_CV_instance_newDrugs.RData") # normal instanced repeated stratified CV
load("./data/Rep_Nest_CV_instance_allDosage.RData") # as above but with dosages blocked together

matrix_container$tuning_measure <- list("auc" = list(auc, mmce, ppv))
matrix_container$resamp_instance <- 
   ifelse(matrix_container$drug_dosages == "all", 
          list(Rep_Nest_CV_instance_allDosage), 
          list(Rep_Nest_CV_instance_newDrugs))

names(matrix_container$resamp_instance) <- # as ifelse ignores names
   ifelse(matrix_container$drug_dosages == "all", 
          "Rep_Nest_CV_instance_allDosage", 
          "Rep_Nest_CV_instance_newDrugs")


#####################################
## SPECIFYING HYPERPARAMETER GRIDS ##
#####################################
# specify hyperparameter grids, put them into lists with the fitted model as the names of the 
# elements
# lists should have same lengths as matrix_container since the whole matrix_container should be 
# processed once for each hyperparameter grid
# then apply some map magic to collect everything into a big data frame

#### step (1): specifying the hyperparameter grids

# RANDOM FORESTS:
rf_hyp_param <- 
   lapply(
      map_dbl(matrix_container$drug_feature_matrices, ncol), 
      function(x) {
         x <- x - 3 # to account for drugname, process_broad, conc
         makeParamSet(
            makeDiscreteParam("ntree", values = c(200, 500)), 
            makeDiscreteParam("mtry", values = floor(c(x, x*(3/4), x/2, x/4, sqrt(x))))
         )
      }
   )
names(rf_hyp_param) <- rep_len("rf_hyp_param", length(rf_hyp_param))

# XGBOOST:
# (a) 'standard' approach, tuning just most common parameters
xgboost_hyp_param_std <- 
   makeParamSet(
    makeDiscreteParam("nrounds", values = c(200,500)), # number of trees
    makeDiscreteParam("max_depth", values = c(1,2,3, 6)), 
    makeDiscreteParam("eta", values = c(0.01,0.1,0.3)) 
    )
xgboost_hyp_param_std <- rep(list("xgboost_hyp_param_std" = xgboost_hyp_param_std), nrow(matrix_container))

# (b) play around with regularisations
xgboost_hyp_param_reg <- 
   makeParamSet(
    makeDiscreteParam("nrounds", values = c(200,500)), # number of trees
    makeDiscreteParam("max_depth", values = c(1,2,3, 6)), 
    makeDiscreteParam("eta", values = c(0.01,0.1,0.3)), 
    makeDiscreteParam("lambda", values = c(1, 10, 100, 1000)), 
    makeDiscreteParam("alpha", values = c(0, 0.5, 1))
    )
xgboost_hyp_param_reg <- rep(list("xgboost_hyp_param_reg" = xgboost_hyp_param_reg), nrow(matrix_container))

# (c) play around with subsampling functions
xgboost_hyp_param_subsmp <- 
   makeParamSet(
    makeDiscreteParam("nrounds", values = c(200,500)), # number of trees
    makeDiscreteParam("max_depth", values = c(1,2,3, 6)), 
    makeDiscreteParam("eta", values = c(0.01,0.1,0.3)), 
    makeDiscreteParam("subsample", values = c(0.5, 0.8, 1)), 
    makeDiscreteParam("colsample_bytree", values = c(0.5, 0.8, 1))
    )
xgboost_hyp_param_subsmp <- rep(list("xgboost_hyp_param_subsmp" = xgboost_hyp_param_subsmp), nrow(matrix_container))

# LASSO:
lasso_hyp_param <- 
   makeParamSet(
      makeDiscreteParam("alpha", 1), 
      makeDiscreteParam("s", values = seq(from = 0.01, to = 10, length.out = 200))
   )
lasso_hyp_param <- rep(list("lasso_hyp_param" = lasso_hyp_param), nrow(matrix_container))


#### step (2): merging hyperparameter grids + model information with matrix_container

# add here the information about the model that is fitted
hyperparam_container <- 
   list("classif.randomForest" = rf_hyp_param, 
        "classif.xgboost" = xgboost_hyp_param_std, 
        "classif.xgboost" = xgboost_hyp_param_reg, 
        "classif.xgboost" = xgboost_hyp_param_subsmp, 
        "classif.glmnet" = lasso_hyp_param)

# turn into list of data frames
hyperparam_container <- 
   map2(hyperparam_container, 
        names(hyperparam_container), 
        ~data_frame('hyperparam_grid' = .x, 'fitted_model' = .y))

# dplyr functions remove names of list columns with map_dfr - so go back to good old do.call + rbind
matrix_container <- do.call(rbind, map(hyperparam_container, ~bind_cols(matrix_container, .x)))

save(matrix_container, file = "./data/matrix_container.RData")
```


# New small matrix container - 10/07/2018

Do the same with matrix with 2 dosages with most significant phenotypes. 
And also get rid of the "other" MoA (different from cell_wall, dna, membrane_stress, protein_synthesis)

```{r}

the_matrix_mostias_nochemfeats_2dosages = left_join(the_matrix_mostias_nochemfeats_2dosages, my_labels_knowndrugs)
the_matrix_mostias_nochemfeats_2dosages = the_matrix_mostias_nochemfeats_2dosages %>% select(drugname_typaslab, conc, process_broad, everything())
the_matrix_mostias_nochemfeats_2dosages = the_matrix_mostias_nochemfeats_2dosages %>% filter(process_broad %in% c("cell_wall", "dna", "membrane_stress", "protein_synthesis"))

saveRDS(object = the_matrix_mostias_nochemfeats_2dosages, file = "data/matrix_2mostia_mainMoA.rds")

```

The saved matrix can be used (loaded) to run a resampling instance creation with the appropriate notebook.
Once generated, the resampling object need to be loaded


Edit the data matrices with the right filtering

First correlation based feature preselection
```{r}
mat_corr07 = corr_feat_selection(data = the_matrix_mostias_nochemfeats_2dosages %>% select(-drugname_typaslab, -conc, -process_broad), thres = 0.7)
mat_corr07 = the_matrix_mostias_nochemfeats_2dosages %>% select(drugname_typaslab, conc, process_broad, colnames(mat_corr07))

mat_corr06 = corr_feat_selection(data = mat_corr07 %>% select(-drugname_typaslab, -conc, -process_broad), thres = 0.6)
mat_corr06 = the_matrix_mostias_nochemfeats_2dosages %>% select(drugname_typaslab, conc, process_broad, colnames(mat_corr06))

mat_corrBonf01 = corr_feat_selection(data = the_matrix_mostias_nochemfeats_2dosages %>% select(-drugname_typaslab, -conc, -process_broad), thres = "bonf01")
mat_corrBonf01 = the_matrix_mostias_nochemfeats_2dosages %>% select(drugname_typaslab, conc, process_broad, colnames(mat_corrBonf01))

mat_corrBonf05 = corr_feat_selection(data = mat_corrBonf01 %>% select(-drugname_typaslab, -conc, -process_broad), thres = "bonf05")
mat_corrBonf05 = the_matrix_mostias_nochemfeats_2dosages %>% select(drugname_typaslab, conc, process_broad, colnames(mat_corrBonf05))

```

Then based on protein complexes from the EcoCyc database. The average signal for a complex is computed and defined as a new feature

```{r}

cmplx = read_tsv(file = "data/All_instances_of_Protein-Complexes_in_Escherichia_coli_K-12_substr._MG1655.txt")
load("../dbsetup/data/genesWithEG_ID.RData")
gene_synonyms$synonym = toupper(gene_synonyms$synonym)


genes_cmplx = lapply(cmplx$`Genes of polypeptide, complex, or RNA`,
        FUN = function(x){
            genenames = str_match_all(string = x, pattern = "[a-zA-Z]{3,4}")
            genenames = toupper(unlist(genenames))
       })

names(genes_cmplx) = cmplx$`Protein-Complexes`
genes_cmplx = genes_cmplx[!is.na(genes_cmplx)]

lens = lapply(genes_cmplx, function(x){length(x)})
genes_cmplx = genes_cmplx[lens != 1]

mat_cmplx = the_matrix_mostias_nochemfeats_2dosages %>% select(-drugname_typaslab, -conc, -process_broad)

for (g in genes_cmplx) {
    map_gene = which(g %in% colnames(mat_cmplx))
    if(length(map_gene) > 1){
        new_value = apply(mat_cmplx[ ,g[map_gene]], 1, mean)
        
        # Is there an easier way to supress column ?
        mat_cmplx = mat_cmplx[, !(colnames(mat_cmplx) %in% g[map_gene])]
        mat_cmplx[, paste(g[map_gene], collapse = "_")] = new_value
    }
}

mat_cmplx = mat_cmplx %>% mutate("drugname_typaslab" = the_matrix_mostias_nochemfeats_2dosages$drugname_typaslab,
                   "conc" = the_matrix_mostias_nochemfeats_2dosages$conc, 
                   "process_broad" = the_matrix_mostias_nochemfeats_2dosages$process_broad) 

mat_cmplx = mat_cmplx %>% select(drugname_typaslab, conc, process_broad, everything())

```

Extreme features selection : First take the Protein complexes matrix, and apply the correlation based selection with 0.6 or 0.7 cutoff. Than look at the variance across all drugs. 
By boxploting these variances, one can extract the outlier individuals (based on some distribution and IQR, outlier are individuals with values above (median + 1.5 * IQR)). It is similar in a way to the top 10% or top 15% of individuals with the highest variance but it make more sense to define the cutoff that way. It is in this case kind of a data-dependant cutoff.


```{r}

mat_cmplx_corr07 = corr_feat_selection(data = mat_cmplx %>% select(-drugname_typaslab, -conc, -process_broad), thres = 0.7)
var_all = unlist(apply(mat_cmplx_corr07, 2, var))
out_ind = boxplot.stats(var_all)$out
mat_cmplx_corr07 = mat_cmplx %>% select(drugname_typaslab, conc, process_broad, names(out_ind))


mat_cmplx_Bonf01 = corr_feat_selection(data = mat_cmplx %>% select(-drugname_typaslab, -conc, -process_broad), thres = "bonf01")
var_all = unlist(apply(mat_cmplx_Bonf01, 2, var))
out_ind = boxplot.stats(var_all)$out
mat_cmplx_Bonf01 = mat_cmplx %>% select(drugname_typaslab, conc, process_broad, names(out_ind))

mat_cmplx_Bonf05 = corr_feat_selection(data = mat_cmplx %>% select(-drugname_typaslab, -conc, -process_broad), thres = "bonf05")
var_all = unlist(apply(mat_cmplx_Bonf05, 2, var))
out_ind = boxplot.stats(var_all)$out
mat_cmplx_Bonf05 = mat_cmplx %>% select(drugname_typaslab, conc, process_broad, names(out_ind))


mat_cmplx_corr06 = corr_feat_selection(data = mat_cmplx %>% select(-drugname_typaslab, -conc, -process_broad), thres = 0.6)
var_all = unlist(apply(mat_cmplx_corr06, 2, var))
out_ind = boxplot.stats(var_all)$out
mat_cmplx_corr06 = mat_cmplx %>% select(drugname_typaslab, conc, process_broad, names(out_ind))


```


Building the new matrix container

```{r}

instance_2mostia_mainMoA = readRDS(file = "data/RNCV_instance_2mostia_mainMoa.rds")

tmp = list()
tmp = list(the_matrix_mostias_nochemfeats_2dosages, the_matrix_mostias_nochemfeats_2dosages,
                mat_corr06, mat_corr06, mat_corr07, mat_corr07,
                mat_cmplx, mat_cmplx, mat_cmplx_corr06, mat_cmplx_corr06, 
                mat_corrBonf01, mat_corrBonf01, mat_cmplx_Bonf01, mat_cmplx_Bonf01,
                mat_corrBonf05, mat_corrBonf05, mat_cmplx_Bonf05, mat_cmplx_Bonf05)

matrix_container_new <- 
    tibble(datasets_included = rep("nichols_2011", 18), 
          drug_dosages =  rep("most2_interactions", 18), 
          feat_preselect = rep(c("all", "corr06", "corr07", "protCmplx", "cplx_corr_outlier", "corrBonf01", "cplx_corrBonf_outlier01", "corrBonf05", "cplx_corrBonf_outlier05"), each = 2), 
          chemical_feats = rep(FALSE, 18), 
          drug_feature_matrices = tmp)

matrix_container_new$tuning_measure <- list("meas" = list(auc, mmce, ppv))
matrix_container_new$resamp_instance <- list(instance_2mostia_mainMoA)

el_net_hyp_param <- makeParamSet( makeDiscreteParam("alpha", values = c(0,0.25,0.5,0.75,1)), 
                    makeDiscreteParam("s", values = seq(from = 0.01, to = 10, length.out = 100)))


rf_hyp_param <- lapply(map_dbl(matrix_container_new$drug_feature_matrices, ncol), 
        function(x) {
            x <- x - 3 # to account for drugname, process_broad, conc
            makeParamSet(makeDiscreteParam("ntree", values = c(200, 500)), 
                makeDiscreteParam("mtry", values = floor(c(x, x*(3/4), x/2, x/4, sqrt(x))))
            )
        })

names(rf_hyp_param) <- rep_len("rf_hyp_param", length(rf_hyp_param))
matrix_container_new$hyperparam_grid = rf_hyp_param
matrix_container_new$fitted_model = rep(c("classif.glmnet", "classif.randomForest"), times = 9)

matrix_container_new[matrix_container_new$fitted_model == "classif.glmnet", ]$hyperparam_grid = list("classif.elastic_net" = el_net_hyp_param)


saveRDS(object = matrix_container_new, file = "data/matrix_container_new.rds")

```


# System and session info

```{r}
R.version
sessionInfo()
```
