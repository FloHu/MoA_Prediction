---
title: "Predicting drug mode of action: loading data and preselecting features"
author: "Florian Huber, Leonard Dubois"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_caption: yes
    fig_height: 6
    fig_width: 6
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
editor_options: 
  chunk_output_type: console
---

# Setup, library loading

```{r}
rm(list = ls())
# function to check if a package is installed, if so, load it, else install and then load it
source("./R/ipak.R")
# set chunk options and load libraries
source("./setup.R")

# custom functions
walk(list.files("./R", pattern = "*.R", full.names = T), source)
```


# Loading and merging data

In all subsequent cases, the final goal is to have a matrix with the drugs in the rows and the 
features in the columns. We will refer to such a matrix as a `drug_feature_matrix`. In the next 
section we will generate different "versions" of this matrix, differing, for example, in the number 
of drugs or features selected or whether features were transformed in some way.


## Reading in and joining of tables, common preprocessing operations

```{r}
nichols_2011 <- read.table("/Volumes/typas/Florian/dbsetup_tables/nichols_2011.csv", header = T, 
                           sep = ";", stringsAsFactors = F)
strains <- read.table("/Volumes/typas/Florian/dbsetup_tables/strains.csv", header = T, 
                           sep = ";", stringsAsFactors = F)
strains_has_genes <- read.table("/Volumes/typas/Florian/dbsetup_tables/strains_has_genes.csv", 
                                header = T, sep = ";", stringsAsFactors = F)
genes <- read.table("/Volumes/typas/Florian/dbsetup_tables/genes.csv", header = T, sep = ";", 
                    stringsAsFactors = F)
# generated in project dbsetup using KNIME
drugs_full <- read.table("/Volumes/typas/Florian/dbsetup_tables/drugs.csv", header = T, 
                         sep = ";", stringsAsFactors = F, dec = ".")
drugs_full$X <- NULL
mode_of_action <- read.table("/Volumes/typas/Florian/dbsetup_tables/mode_of_action.csv", 
                             header = T, sep = ";", stringsAsFactors = F)
```

Add gene information to Nichols table, remove unnecessary columns.

```{r}
the_matrix <- 
   nichols_2011 %>%
   left_join(strains[, c("strain"), drop = F]) %>%
   left_join(strains_has_genes[, c("strain", "ugi")]) %>%
   left_join(genes[, c("ugi", "gene_synonym")]) %>%
   select(gene_synonym, drugname_typaslab, conc, sscore, qvalue, strain) 
    
the_matrix$significant <- the_matrix$qvalue <= 0.05
```

Join drug tables with mode of action information.

```{r}
drugs_full <- left_join(drugs_full, mode_of_action[, c("moa_id", "process_broad")]) %>%
   select(-moa_id)

the_matrix <- filter(the_matrix, drugname_typaslab %in% drugs_full$drugname_typaslab)
```

If a gene doesn't interact with any drug, exclude it.

```{r}
the_matrix <- the_matrix %>%
   group_by(gene_synonym) %>% 
   filter(any(significant)) %>%
   ungroup()
```

This leaves us with `r length(unique(the_matrix$gene_synonym))` genes. Only a very small fraction 
of gene drug combinations are missing (less than 0.1%):

```{r}
t <- table(the_matrix$gene_synonym, the_matrix$drugname_typaslab)
sum(t == 0) / (nrow(t) * ncol(t))
```

For essential genes there were sometimes several hypomorphic mutants. We just want to keep one of 
them: always the one with most phenotypes over all conditions.

```{r}
the_matrix <- 
   group_by(the_matrix, gene_synonym) %>%
   do(select_mutant(.))

saveRDS(the_matrix, file = "./data/the_matrix_after_select_mutant.rds")

tmp <- group_by(the_matrix, gene_synonym) %>% 
   mutate(n = length(unique(strain))) %>%
   ungroup() %>%
   select(n)
stopifnot(all(tmp$n == 1))
rm(tmp)
```

Restructure the matrix to put drugs into rows, genes into columns. 

```{r}
# we need a matrix just indicating the significant s-scores for later on
the_matrix_signifs <- the_matrix

the_matrix <- select(the_matrix, gene_synonym, drugname_typaslab, conc, sscore)
the_matrix <- spread(the_matrix, key = gene_synonym, value = sscore)

the_matrix_signifs <- select(the_matrix_signifs, gene_synonym, drugname_typaslab, conc, significant)
the_matrix_signifs <- spread(the_matrix_signifs, key = gene_synonym, value = significant, fill = FALSE)
```


### *NEW CHUNK* 2018-08-10: inspecting data
One should probably check a bit the behaviour of our variables: how skewed are the distributions, 
are certain drugs or conditions far off, are NA values clustered in certain genes/drugs?


#### Predictor skewness

Let's check skewness of predictors first.

```{r}
skewness_vals <- sapply(the_matrix[, 3:ncol(the_matrix)], e1071::skewness, na.rm = TRUE)
skewness_vals <- data.frame(gene_synonym = names(skewness_vals), 
                            skewness = skewness_vals, 
                            stringsAsFactors = FALSE)

# indicate outlier boundaries using boxplot.stats
my_boundaries <- get_outlier_boundaries(skewness_vals$skewness)
skewness_vals$is_outlier <- 
   skewness_vals$skewness <= my_boundaries$lower_bound | 
   skewness_vals$skewness >= my_boundaries$upper_bound

my_lower <- my_boundaries$lower_bound
my_upper <- my_boundaries$upper_bound

ggplot(skewness_vals, aes(x = skewness)) + 
   geom_histogram(binwidth = 0.1) + 
   geom_vline(xintercept = c(my_lower, my_upper), linetype = "dotted") + 
   labs(title = "Skewness of predictors (mutants) across conditions\n(outliers indicated acc. to boxplot.stats())")

ggsave(filename = "./plots/NEW_predictor_skewness_distribution.pdf")
```

We have a number of predictors that are more skewed than the others: indicated by their skewness 
values again being outliers in the skewness distribution of all predictors.

```{r}
# skewness values are mostly negative, which makes sense, considering the nature of our data
# but there are 130 outliers
filter(skewness_vals, is_outlier) %>%
   arrange(skewness)
```

PLDA has the most negative skewness value, let's have a look:

```{r}
# a few seem to be quite bad, e.g. "PLDA"
hist(the_matrix$PLDA, breaks = 100, main = "Histogram of s-scores for PLDA")

pdf("./plots/NEW_PLDA_sscore_dist.pdf")
hist(the_matrix$PLDA, breaks = 100, main = "Histogram of s-scores for PLDA")
dev.off()
```

So actually it looks like a handful of genes with very low s-scores are responsible for the 
"skewness" of the distribution:

```{r}
e1071::skewness(the_matrix$PLDA)
my_boundaries <- get_outlier_boundaries(the_matrix$PLDA)
# skewness metric without outliers
e1071::skewness(my_boundaries$input_data_noout)
```

Interestingly, delta-PLDA seems to selectively interact with CHIR090. 3/4 of those interactions are 
statistically significant. Probably skewness is just one way of finding such "selective" genes. 

```{r}
dplyr::select(the_matrix, drugname_typaslab, conc, PLDA) %>%
   filter(PLDA <= my_boundaries$lower_bound)

# significant interactions:
dplyr::select(the_matrix_signifs, drugname_typaslab, conc, PLDA) %>%
   filter(PLDA)
```

Removing the outliers (according to `boxplot.stats()`) from each predictor makes the skewness 
distribution a lot more "normal":

```{r}
# what if we remove the outliers everywhere? 
skewness_vals$skewness_vals_noout <- 
   sapply(colnames(the_matrix[, 3:ncol(the_matrix)]), function(x) {
      noout <- get_outlier_boundaries(the_matrix[[x]])$input_data_noout
      return(e1071::skewness(noout, na.rm = TRUE))
})

my_boundaries <- get_outlier_boundaries(skewness_vals$skewness_vals_noout)
my_lower_new <- my_boundaries$lower_bound
my_upper_new <- my_boundaries$upper_bound

ggplot(skewness_vals, aes(x = skewness_vals_noout)) + 
   geom_histogram(binwidth = 0.1) + 
   geom_vline(xintercept = c(my_lower, my_upper), linetype = "dotted") + 
   geom_vline(xintercept = c(my_lower_new, my_upper_new), linetype = "dashed") + 
   labs(title = "Skewness of predictors (mutants) across conditions:
        \n(this time with outliers removed, dashed lines = new boundaries)")

ggsave("./plots/NEW_predictor_skewness_distribution_noout.pdf")
# seems like there are a few outliers left, perhaps worth checking them:
sort(boxplot.stats(skewness_vals$skewness_vals_noout)$out)

# let's have a look at the respective s-score histograms/boxplots, indicating the outliers
# skewness_vals$to_check <- skewness_vals$skewness_vals_noout < -1 | skewness_vals$skewness_vals_noout > 1
skewness_vals$to_check <- 
   skewness_vals$skewness_vals_noout <= my_lower_new | 
   skewness_vals$skewness_vals_noout >= my_upper_new

genes_to_check <- skewness_vals$gene_synonym[skewness_vals$to_check]
skewness_vals_melted <- 
   dplyr::select(the_matrix, drugname_typaslab, conc, genes_to_check) %>%
   gather(genes_to_check, key = "gene_synonym", value = "s_score") %>%
   left_join(skewness_vals[, c("gene_synonym", "skewness", "skewness_vals_noout")])

# add information about MoA:
moa_info <- drugs_full[, c("drugname_typaslab", "process_broad")]
moa_info$process_broad <- 
   ifelse(moa_info$process_broad %in% c("cell_wall", "dna", "protein_synthesis", "membrane_stress"), 
          moa_info$process_broad, 
          "other")

skewness_vals_melted <- left_join(skewness_vals_melted, moa_info)

annot_helper <- skewness_vals_melted %>%
   group_by(gene_synonym) %>%
   summarise(x = 0, y = 40, skewness = mean(skewness), skewness_vals_noout = mean(skewness_vals_noout))
```

These are the most skewed distributions after outlier removal. Some of them are really messed up, 
for example OXYR. 

```{r}
ggplot(skewness_vals_melted, aes(x = s_score)) + 
   geom_histogram() + 
   facet_wrap( ~ gene_synonym, scales = "free") + 
   geom_text(data = annot_helper, aes(label = round(skewness, digits = 2), x = x, y = y), color = "blue", size = 3)

ggsave(filename = "./plots/NEW_sscore_dists_skewed_features.pdf")
```

Pair plots of sscores of the skewed features. 

```{r}
all_by_all <- 
   full_join(skewness_vals_melted, skewness_vals_melted, 
             by = c("drugname_typaslab" = "drugname_typaslab", "conc" = "conc", "process_broad" = "process_broad"))

# plot_pairplots takes the data frame above and plots all by all combinations of the genes of 
# interest

plot_pairplots(c("PURD", "PURM"))
plot_pairplots(c("PURD", "PURM", "PYRE"))
```

Perhaps these are features that can be used to isolate certain (sub)groups of drugs? - would be 
interesting to test. Another interesting observation: s-scores can fluctuate a lot such as ACRA and 
novobiocin - why does conc = 6 suddenly have an s-score of 3.98? Is there a better way to select 
dosages than just highest concentrations or "most interactions"? In general, my impression was that 
s-scores _do_ go down with higher concentrations even though in an earlier analysis I couldn't see 
a clear trend. 

```{r}
filter(skewness_vals_melted, gene_synonym == "ACRA", drugname_typaslab == "NOVOBIOCIN")
dplyr::select(the_matrix_signifs, drugname_typaslab, conc, ACRA) %>%
   filter(drugname_typaslab == "NOVOBIOCIN", ACRA)
```


#### NA values

Are there drug-dosage combinations or mutants with an exceptional high number of NA values? 

Here, we can see that some genes have a high number of NA values. Perhaps they should be excluded. 
Not surprisingly, they are also all part of the "top10pct variance". Should probably fix in the 
future.

```{r}
the_matrix_melted <- 
   the_matrix %>% 
   gather(-one_of("drugname_typaslab", "conc"), key = "gene_synonym", value = "s_score")

NAs_by_mutant <- 
   group_by(the_matrix_melted, gene_synonym) %>%
   summarise(total_conds = n(), total_conds_NA = sum(is.na(s_score)))

# and now the respective genes (seed arguments don't work)
set.seed(9)
ggplot(NAs_by_mutant, aes(x = "", y = total_conds_NA)) + 
   geom_text(aes(label = gene_synonym), size = 3, position = position_jitter(width = 0.3, height = 0)) + 
   geom_hline(yintercept = c(0, 5, 10, 15, 20, 30, 40), linetype = "dotted") + 
   theme_classic() + 
   scale_y_continuous(breaks = c(0, 5, 10, 15, 20, 30, 40)) + 
   labs(title = "Number of conditions with 'NA' per mutant.\n(total number of conds = 256)")

ggsave("./plots/NEW_NA_conditions_per_mutant.pdf")
```

There are also some drug-dosage combinations with many NA values:

```{r}
NAs_by_drugndosg <- 
   group_by(the_matrix_melted, drugname_typaslab, conc) %>%
   summarise(total_conds = n(), total_conds_NA = sum(is.na(s_score)))

NAs_by_drugndosg$label <- paste(NAs_by_drugndosg$drugname_typaslab, NAs_by_drugndosg$conc, sep = "_")
ggplot(NAs_by_drugndosg, aes(x = "", y = total_conds_NA)) + 
   geom_text(aes(label = label), size = 3, position = position_jitter(width = 0.3)) + 
   labs(title = "Number of mutants with 'NA' per drug-dosage combination\n(total number of mutants = 1711)")

ggsave("./plots/NEW_NA_mutants_per_condition.pdf")
```


### Imputing NA values

We replace all NA values with the median of all s-scores over all conditions for a particular 
mutant. `the_matrix` now contains all drug dosages and all mutants from nichols_2011 and forms the 
basis for all other derived matrices. 

```{r}
# check if all drug names are defined 
stopifnot(!any(is.na(the_matrix$drugname_typaslab)))
sel <- grep(colnames(the_matrix), pattern = "drugname_typaslab|conc")

the_matrix[, -sel] <- lapply(the_matrix[, -sel], function(x) {
   x[is.na(x)] <- median(x, na.rm = T)
   return(x)
})

if (any(sapply(the_matrix, is.na))) {
   stop("Undefined values present in the_matrix.")
}
```


# Generating different 'versions' of our matrix

## Drug selection and drug classification procedures

### Dosage selection

#### Approach 1: "`most_interactions`" 
Selects for each drug the one dosages with the highest number of significant interactions. If none 
or all are, keep the highest dosage. 

```{r}
selector <- 
   the_matrix_signifs %>%
   group_by(drugname_typaslab) %>%
   arrange(conc, .by_group = TRUE) %>%
   do(select_dosage_most_ias(.)) %>%
   ungroup() %>%
   pull(selector)

selector_2dosages <- 
   the_matrix_signifs %>%
   group_by(drugname_typaslab) %>%
   arrange(conc, .by_group = TRUE) %>%
   do(select_dosage_most_ias_2(.)) %>%
   ungroup() %>%
   pull(selector)

the_matrix <- the_matrix %>%
   group_by(drugname_typaslab) %>%
   arrange(conc, .by_group = TRUE) %>%
   ungroup()

the_matrix_alldosgs_nochemfeats <- the_matrix
the_matrix_mostias_nochemfeats <- the_matrix[selector, ]
the_matrix_mostias_nochemfeats_2dosages <- the_matrix[selector_2dosages, ]
```


## Collecting data in a data frame with list columns

```{r}
matrix_container <- 
   tibble(datasets_included = list("nichols_2011", "nichols_2011"), 
          drug_dosages = c("all", "most_interactions"), 
          feat_preselect = c("keepall", "keepall"), 
          chemical_feats = c(FALSE, FALSE), 
          drug_feature_matrices = list(the_matrix_alldosgs_nochemfeats, the_matrix_mostias_nochemfeats))
```


## Feature selection and transformation procedures

### Selecting features with the highest variance

#### Top x per cent features

Sort features (i.e. mutants = genes here) by variance and select top x %. 

```{r}
variances_to_select <- c(5, 10, 15, 20, 25, 30, 40, 50)

# add some datasets to our matrix_container: for the table using all dosages, we want to select 
# the genes which have the highest variance (top x%)
targetrow <- match("all", matrix_container$drug_dosages)
for (v in variances_to_select) {
   tmp_row <- matrix_container[targetrow, ] # = row containing matrix with all drug dosages => let's do feature preselection
   tmp_mat <- tmp_row$drug_feature_matrices[[1]]
   tmp_mat <- feature_selection_variance(tmp_mat, featStart = 3, percentTop = v)
   tmp_row$drug_feature_matrices[[1]] <- tmp_mat # replace the matrix
   tmp_row$feat_preselect <- paste0("top", v, "pct") # update metadata
   matrix_container <- bind_rows(matrix_container, tmp_row) # and update our data container
}

# repeat the same thing with the table that doesn't have all dosages but only those dosages with 
# most interactions in the chemical genomics data
# I know, code repetition - shame! but I really want to be explicit here
(targetrow <- match("most_interactions", matrix_container$drug_dosages))
for (v in variances_to_select) {
   tmp_row <- matrix_container[targetrow, ] # = row containing matrix with all drug dosages => let's do feature preselection
   tmp_mat <- tmp_row$drug_feature_matrices[[1]]
   tmp_mat <- feature_selection_variance(tmp_mat, featStart = 3, percentTop = v)
   tmp_row$drug_feature_matrices[[1]] <- tmp_mat # replace the matrix
   tmp_row$feat_preselect <- paste0("top", v, "pct") # update metadata
   matrix_container <- bind_rows(matrix_container, tmp_row) # and update our data container
}
```

### Adding chemical features

Don't use all chemical features from KNIME. Make tables with and without chemical features

```{r}
# check if all drugs in all tables are in our 'drugs_full' table
stopifnot(
   all(
      unique(flatten_chr(map(matrix_container$drug_feature_matrices, "drugname_typaslab")))
      %in%
      drugs_full$drugname_typaslab
   )
)

drugs_full_selected_features <- drugs_full[, c("drugname_typaslab", "SlogP", "LabuteASA", "TPSA", 
                                               "ExactMW", "NumLipinskiHBA", "NumLipinskiHBD", 
                                               "NumRotatableBonds", "NumAmideBonds", 
                                               "NumRings", "NumAromaticRings", "NumSaturatedRings", 
                                               "NumAliphaticRings", "data_effective_rotor_count")]

# take whole matrix_container, add chemical features, update metadata and rbind to old container
matrix_container <- 
   matrix_container %>%
   mutate(drug_feature_matrices = map(drug_feature_matrices, left_join, drugs_full_selected_features), 
          chemical_feats = TRUE, 
          datasets_included = map(datasets_included, append, "knime")) %>%
   bind_rows(matrix_container) %>%
   arrange(drug_dosages, feat_preselect, chemical_feats)
```


## Adding drug classification = mode of action information, generate dfr with list columns

```{r}
my_labels <- drugs_full[, c("drugname_typaslab", "process_broad")]
my_labels_knowndrugs <- my_labels[my_labels$process_broad != "unknown", ]

# remove unknown drugs, then add MoA information
matrix_container <- 
   matrix_container %>%
   mutate(drug_feature_matrices = map(drug_feature_matrices, semi_join, my_labels_knowndrugs)) %>%
   mutate(drug_feature_matrices = map(drug_feature_matrices, left_join, my_labels))

# arrange rows nicely
matrix_container$drug_feature_matrices <- 
   map(matrix_container$drug_feature_matrices, select, drugname_typaslab, conc, process_broad, everything())
```

## Adding model and hyperparameter specifications

For all of the above drug-feature matrices we want to run the following:
- random forests with a number of trees and mtry values
- boosted trees in 3 flavours: (i) 'normal' parameters changed, (ii) testing regularisation, (iii) 
  trying out subsample parameters
- lasso regression

```{r}
matrix_container.bak <- matrix_container
matrix_container_tmp <- matrix_container

# stuff common to all: tuning measures, CV instances
load("./data/Rep_Nest_CV_instance_newDrugs.RData") # normal instanced repeated stratified CV
load("./data/Rep_Nest_CV_instance_allDosage.RData") # as above but with dosages blocked together

matrix_container$tuning_measure <- list("auc" = list(auc, mmce, ppv))
matrix_container$resamp_instance <- 
   ifelse(matrix_container$drug_dosages == "all", 
          list(Rep_Nest_CV_instance_allDosage), 
          list(Rep_Nest_CV_instance_newDrugs))

names(matrix_container$resamp_instance) <- # as ifelse ignores names
   ifelse(matrix_container$drug_dosages == "all", 
          "Rep_Nest_CV_instance_allDosage", 
          "Rep_Nest_CV_instance_newDrugs")


#####################################
## SPECIFYING HYPERPARAMETER GRIDS ##
#####################################
# specify hyperparameter grids, put them into lists with the fitted model as the names of the 
# elements
# lists should have same lengths as matrix_container since the whole matrix_container should be 
# processed once for each hyperparameter grid
# then apply some map magic to collect everything into a big data frame

#### step (1): specifying the hyperparameter grids

# RANDOM FORESTS:
rf_hyp_param <- 
   lapply(
      map_dbl(matrix_container$drug_feature_matrices, ncol), 
      function(x) {
         x <- x - 3 # to account for drugname, process_broad, conc
         makeParamSet(
            makeDiscreteParam("ntree", values = c(200, 500)), 
            makeDiscreteParam("mtry", values = floor(c(x, x*(3/4), x/2, x/4, sqrt(x))))
         )
      }
   )
names(rf_hyp_param) <- rep_len("rf_hyp_param", length(rf_hyp_param))

# XGBOOST:
# (a) 'standard' approach, tuning just most common parameters
xgboost_hyp_param_std <- 
   makeParamSet(
    makeDiscreteParam("nrounds", values = c(200,500)), # number of trees
    makeDiscreteParam("max_depth", values = c(1,2,3, 6)), 
    makeDiscreteParam("eta", values = c(0.01,0.1,0.3)) 
    )
xgboost_hyp_param_std <- rep(list("xgboost_hyp_param_std" = xgboost_hyp_param_std), nrow(matrix_container))

# (b) play around with regularisations
xgboost_hyp_param_reg <- 
   makeParamSet(
    makeDiscreteParam("nrounds", values = c(200,500)), # number of trees
    makeDiscreteParam("max_depth", values = c(1,2,3, 6)), 
    makeDiscreteParam("eta", values = c(0.01,0.1,0.3)), 
    makeDiscreteParam("lambda", values = c(1, 10, 100, 1000)), 
    makeDiscreteParam("alpha", values = c(0, 0.5, 1))
    )
xgboost_hyp_param_reg <- rep(list("xgboost_hyp_param_reg" = xgboost_hyp_param_reg), nrow(matrix_container))

# (c) play around with subsampling functions
xgboost_hyp_param_subsmp <- 
   makeParamSet(
    makeDiscreteParam("nrounds", values = c(200,500)), # number of trees
    makeDiscreteParam("max_depth", values = c(1,2,3, 6)), 
    makeDiscreteParam("eta", values = c(0.01,0.1,0.3)), 
    makeDiscreteParam("subsample", values = c(0.5, 0.8, 1)), 
    makeDiscreteParam("colsample_bytree", values = c(0.5, 0.8, 1))
    )
xgboost_hyp_param_subsmp <- rep(list("xgboost_hyp_param_subsmp" = xgboost_hyp_param_subsmp), nrow(matrix_container))

# LASSO:
lasso_hyp_param <- 
   makeParamSet(
      makeDiscreteParam("alpha", 1), 
      makeDiscreteParam("s", values = seq(from = 0.01, to = 10, length.out = 200))
   )
lasso_hyp_param <- rep(list("lasso_hyp_param" = lasso_hyp_param), nrow(matrix_container))


#### step (2): merging hyperparameter grids + model information with matrix_container

# add here the information about the model that is fitted
hyperparam_container <- 
   list("classif.randomForest" = rf_hyp_param, 
        "classif.xgboost" = xgboost_hyp_param_std, 
        "classif.xgboost" = xgboost_hyp_param_reg, 
        "classif.xgboost" = xgboost_hyp_param_subsmp, 
        "classif.glmnet" = lasso_hyp_param)

# turn into list of data frames
hyperparam_container <- 
   map2(hyperparam_container, 
        names(hyperparam_container), 
        ~data_frame('hyperparam_grid' = .x, 'fitted_model' = .y))

# dplyr functions remove names of list columns with map_dfr - so go back to good old do.call + rbind
matrix_container <- do.call(rbind, map(hyperparam_container, ~bind_cols(matrix_container, .x)))

save(matrix_container, file = "./data/matrix_container.RData")
```


# New small matrix container - 10/07/2018

Do the same with matrix with 2 dosages with most significant phenotypes. 
And also get rid of the "other" MoA (different from cell_wall, dna, membrane_stress, protein_synthesis)

```{r}

the_matrix_mostias_nochemfeats_2dosages = left_join(the_matrix_mostias_nochemfeats_2dosages, my_labels_knowndrugs)
the_matrix_mostias_nochemfeats_2dosages = the_matrix_mostias_nochemfeats_2dosages %>% select(drugname_typaslab, conc, process_broad, everything())
the_matrix_mostias_nochemfeats_2dosages = the_matrix_mostias_nochemfeats_2dosages %>% filter(process_broad %in% c("cell_wall", "dna", "membrane_stress", "protein_synthesis"))

saveRDS(object = the_matrix_mostias_nochemfeats_2dosages, file = "data/matrix_2mostia_mainMoA.rds")

```

The saved matrix can be used (loaded) to run a resampling instance creation with the appropriate notebook.
Once generated, the resampling object need to be loaded


Edit the data matrices with the right filtering

First correlation based feature preselection
```{r}
mat_corr07 = corr_feat_selection(data = the_matrix_mostias_nochemfeats_2dosages %>% select(-drugname_typaslab, -conc, -process_broad), thres = 0.7)
mat_corr07 = the_matrix_mostias_nochemfeats_2dosages %>% select(drugname_typaslab, conc, process_broad, colnames(mat_corr07))

mat_corr06 = corr_feat_selection(data = mat_corr07 %>% select(-drugname_typaslab, -conc, -process_broad), thres = 0.6)
mat_corr06 = the_matrix_mostias_nochemfeats_2dosages %>% select(drugname_typaslab, conc, process_broad, colnames(mat_corr06))

mat_corrBonf01 = corr_feat_selection(data = the_matrix_mostias_nochemfeats_2dosages %>% select(-drugname_typaslab, -conc, -process_broad), thres = "bonf01")
mat_corrBonf01 = the_matrix_mostias_nochemfeats_2dosages %>% select(drugname_typaslab, conc, process_broad, colnames(mat_corrBonf01))

mat_corrBonf05 = corr_feat_selection(data = mat_corrBonf01 %>% select(-drugname_typaslab, -conc, -process_broad), thres = "bonf05")
mat_corrBonf05 = the_matrix_mostias_nochemfeats_2dosages %>% select(drugname_typaslab, conc, process_broad, colnames(mat_corrBonf05))

```

Then based on protein complexes from the EcoCyc database. The average signal for a complex is computed and defined as a new feature

```{r}

cmplx = read_tsv(file = "data/All_instances_of_Protein-Complexes_in_Escherichia_coli_K-12_substr._MG1655.txt")
load("../dbsetup/data/genesWithEG_ID.RData")
gene_synonyms$synonym = toupper(gene_synonyms$synonym)


genes_cmplx = lapply(cmplx$`Genes of polypeptide, complex, or RNA`,
        FUN = function(x){
            genenames = str_match_all(string = x, pattern = "[a-zA-Z]{3,4}")
            genenames = toupper(unlist(genenames))
       })

names(genes_cmplx) = cmplx$`Protein-Complexes`
genes_cmplx = genes_cmplx[!is.na(genes_cmplx)]

lens = lapply(genes_cmplx, function(x){length(x)})
genes_cmplx = genes_cmplx[lens != 1]

mat_cmplx = the_matrix_mostias_nochemfeats_2dosages %>% select(-drugname_typaslab, -conc, -process_broad)

for (g in genes_cmplx) {
    map_gene = which(g %in% colnames(mat_cmplx))
    if(length(map_gene) > 1){
        new_value = apply(mat_cmplx[ ,g[map_gene]], 1, mean)
        
        # Is there an easier way to supress column ?
        mat_cmplx = mat_cmplx[, !(colnames(mat_cmplx) %in% g[map_gene])]
        mat_cmplx[, paste(g[map_gene], collapse = "_")] = new_value
    }
}

mat_cmplx = mat_cmplx %>% mutate("drugname_typaslab" = the_matrix_mostias_nochemfeats_2dosages$drugname_typaslab,
                   "conc" = the_matrix_mostias_nochemfeats_2dosages$conc, 
                   "process_broad" = the_matrix_mostias_nochemfeats_2dosages$process_broad) 

mat_cmplx = mat_cmplx %>% select(drugname_typaslab, conc, process_broad, everything())

```

Extreme features selection : First take the Protein complexes matrix, and apply the correlation based selection with 0.6 or 0.7 cutoff. Than look at the variance across all drugs. 
By boxploting these variances, one can extract the outlier individuals (based on some distribution and IQR, outlier are individuals with values above (median + 1.5 * IQR)). It is similar in a way to the top 10% or top 15% of individuals with the highest variance but it make more sense to define the cutoff that way. It is in this case kind of a data-dependant cutoff.


```{r}

mat_cmplx_corr07 = corr_feat_selection(data = mat_cmplx %>% select(-drugname_typaslab, -conc, -process_broad), thres = 0.7)
var_all = unlist(apply(mat_cmplx_corr07, 2, var))
out_ind = boxplot.stats(var_all)$out
mat_cmplx_corr07 = mat_cmplx %>% select(drugname_typaslab, conc, process_broad, names(out_ind))


mat_cmplx_Bonf01 = corr_feat_selection(data = mat_cmplx %>% select(-drugname_typaslab, -conc, -process_broad), thres = "bonf01")
var_all = unlist(apply(mat_cmplx_Bonf01, 2, var))
out_ind = boxplot.stats(var_all)$out
mat_cmplx_Bonf01 = mat_cmplx %>% select(drugname_typaslab, conc, process_broad, names(out_ind))

mat_cmplx_Bonf05 = corr_feat_selection(data = mat_cmplx %>% select(-drugname_typaslab, -conc, -process_broad), thres = "bonf05")
var_all = unlist(apply(mat_cmplx_Bonf05, 2, var))
out_ind = boxplot.stats(var_all)$out
mat_cmplx_Bonf05 = mat_cmplx %>% select(drugname_typaslab, conc, process_broad, names(out_ind))


mat_cmplx_corr06 = corr_feat_selection(data = mat_cmplx %>% select(-drugname_typaslab, -conc, -process_broad), thres = 0.6)
var_all = unlist(apply(mat_cmplx_corr06, 2, var))
out_ind = boxplot.stats(var_all)$out
mat_cmplx_corr06 = mat_cmplx %>% select(drugname_typaslab, conc, process_broad, names(out_ind))


```


Building the new matrix container

```{r}

instance_2mostia_mainMoA = readRDS(file = "data/RNCV_instance_2mostia_mainMoa.rds")

tmp = list()
tmp = list(the_matrix_mostias_nochemfeats_2dosages, the_matrix_mostias_nochemfeats_2dosages,
                mat_corr06, mat_corr06, mat_corr07, mat_corr07,
                mat_cmplx, mat_cmplx, mat_cmplx_corr06, mat_cmplx_corr06, 
                mat_corrBonf01, mat_corrBonf01, mat_cmplx_Bonf01, mat_cmplx_Bonf01,
                mat_corrBonf05, mat_corrBonf05, mat_cmplx_Bonf05, mat_cmplx_Bonf05)

matrix_container_new <- 
    tibble(datasets_included = rep("nichols_2011", 18), 
          drug_dosages =  rep("most2_interactions", 18), 
          feat_preselect = rep(c("all", "corr06", "corr07", "protCmplx", "cplx_corr_outlier", "corrBonf01", "cplx_corrBonf_outlier01", "corrBonf05", "cplx_corrBonf_outlier05"), each = 2), 
          chemical_feats = rep(FALSE, 18), 
          drug_feature_matrices = tmp)

matrix_container_new$tuning_measure <- list("meas" = list(auc, mmce, ppv))
matrix_container_new$resamp_instance <- list(instance_2mostia_mainMoA)

el_net_hyp_param <- makeParamSet( makeDiscreteParam("alpha", values = c(0,0.25,0.5,0.75,1)), 
                    makeDiscreteParam("s", values = seq(from = 0.01, to = 10, length.out = 100)))


rf_hyp_param <- lapply(map_dbl(matrix_container_new$drug_feature_matrices, ncol), 
        function(x) {
            x <- x - 3 # to account for drugname, process_broad, conc
            makeParamSet(makeDiscreteParam("ntree", values = c(200, 500)), 
                makeDiscreteParam("mtry", values = floor(c(x, x*(3/4), x/2, x/4, sqrt(x))))
            )
        })

names(rf_hyp_param) <- rep_len("rf_hyp_param", length(rf_hyp_param))
matrix_container_new$hyperparam_grid = rf_hyp_param
matrix_container_new$fitted_model = rep(c("classif.glmnet", "classif.randomForest"), times = 9)

matrix_container_new[matrix_container_new$fitted_model == "classif.glmnet", ]$hyperparam_grid = list("classif.elastic_net" = el_net_hyp_param)


saveRDS(object = matrix_container_new, file = "data/matrix_container_new.rds")

```


# System and session info

```{r}
R.version
sessionInfo()
```
