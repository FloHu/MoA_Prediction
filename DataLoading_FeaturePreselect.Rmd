---
title: "Predicting drug mode of action: loading data and preselecting features"
author: "Florian Huber, Leonard Dubois"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_caption: yes
    fig_height: 6
    fig_width: 6
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
editor_options: 
  chunk_output_type: console
---

# Setup, library loading

```{r}
rm(list = ls())
# function to check if a package is installed, if so, load it, else install and then load it
source("./R/ipak.R")
# set chunk options and load libraries
source("./setup.R")
knitr::opts_chunk$set(cache = TRUE)

# directory for automatically generated data:
outdir <- "./data/programmatic_output"
```


# Loading and preprocessing

In all subsequent cases, the final goal is to have a matrix with the drugs in 
the rows and the features in the columns. We will refer to such a matrix as a 
`drug_feature_matrix`. In the next section we will generate different "versions" 
of this matrix, differing, for example, in the number of drugs or features 
selected or whether features were transformed in some way.


## Reading in and joining of tables

```{r, data_import}
indir <- "/Volumes/typas/Florian/dbsetup_tables_new"

(nichols_2011 <- read_delim(file.path(indir, "nichols_2011.csv"), delim = ";"))
# Lucia's data
(newsize <- read_delim(file.path(indir, "newsize.csv"), delim = ";"))
(genes <- read_delim(file.path(indir, "genes.csv"), delim = ";"))
(drugs_complete <- read_delim(file.path(indir, "drugs.csv"), delim = ";"))

# get mode of action information using Google docs, if it fails look for 
# information on the server
tryCatch(
  error = function(e) {
    moa <- read_delim(file.path(indir, "mode_of_action.csv"))
    return(moa)
  }, 
  {
  gfiles <- drive_find(pattern = "drug_moa")
  outpath <- file.path(outdir, "drug_moa_gdrive.csv")
  drive_download(file = gfiles[1, ], path = outpath, overwrite = TRUE)
  }
)

mode_of_action <- read_delim(outpath, delim = ",", na = c("-"))
stopifnot(all(!duplicated(mode_of_action$drugname_typaslab)))
mode_of_action <- mode_of_action[, c("drug", "moa_broad_II (after 09/05/2018)", 
  "dataset (not exclusive)")]
colnames(mode_of_action) <- c("drugname_typaslab", "process_broad", "dataset")
```

Write out `drugs_complete` with MoA information.

```{r}
drugs_complete <- left_join(drugs_complete, mode_of_action)
saveRDS(drugs_complete, file = file.path(outdir, "drugs_complete.rds"))
```

Write out `the_matrix_complete_nochanges.rds` with MoA information. 

```{r}
the_matrix <- dplyr::select(nichols_2011, gene_synonym, drugname_typaslab, 
  conc, sscore, qvalue, strain)
the_matrix$significant <- the_matrix$qvalue <= 0.05
the_matrix <- left_join(the_matrix, drugs_complete[, c("drugname_typaslab", 
  "process_broad")])
# is in long format
saveRDS(the_matrix, file.path(outdir, "the_matrix_complete_nochanges.rds"))
```


## Removing drugs

In principle, keep all drugs. However, for model assessment, only keep drugs 
that:
  * are in the Nichols data set
  * Have chemical features defined
  * Have one of the four "main" modes of action: cell_wall, dna, 
  membrane_stress, protein_synthesis

--> Tables `drugs_complete` and `drugs_subset`. 

```{r}
main_moas <- c("cell_wall", "dna", "membrane_stress", "protein_synthesis")
drugs_subset <- filter(drugs_complete, dataset == "NICHOLS", !is.na(SlogP), 
  process_broad %in% main_moas)
drugs_subset
table(drugs_subset$process_broad)
saveRDS(drugs_subset, file = file.path(outdir, "drugs_subset.rds"))
```

Subset `the_matrix` accordingly. 

```{r}
# keep only drugs in drug_subset
the_matrix <- filter(the_matrix, drugname_typaslab %in% 
    unique(drugs_subset$drugname_typaslab))
```

## Feature filtering

`the_matrix`: table derived from nichols_2011 that will be used for model 
assessment. Keep only mutants that:
  * interact with at least one gene and 
  * don't have more than 10 conditions where the s-score is NA (see notebook 
  `Inspecting_the_matrix.html`)

```{r}
# number of genes before gene filtering:
nunique(the_matrix$gene_synonym)

the_matrix <- the_matrix %>%
   group_by(gene_synonym) %>% 
   filter(any(significant)) %>%
   ungroup()

# and after:
nunique(the_matrix$gene_synonym)
stopifnot(nunique(the_matrix$gene_synonym) == nunique(the_matrix$strain))
saveRDS(the_matrix, file = file.path(outdir, "Inspecting_the_matrix_input.rds"))
```

For excluding conditions with many NA values need to do a bit more processing, 
which has been outsourced (due to historical reasons) to 
`Inspecting_the_matrix.Rmd`.

```{r}
rmarkdown::render("Inspecting_the_matrix.Rmd", 
  rmarkdown::html_document(toc = TRUE), envir = new.env())
```

Can now remove some genes with many NA values:

```{r}
the_matrix <- filter(the_matrix, 
  !gene_synonym %in% readRDS(file.path(outdir, "feats_to_remove_many_NAs.rds")))
```

Save it:

```{r}
saveRDS(the_matrix, 
  file = file.path(outdir, "the_matrix_drugsgenesremoved.rds"))
```


## Reshape

Convert to wide format. If qvalues are `NA` we treat them as non-significant. 

```{r}
the_matrix_signifs <- the_matrix

the_matrix <- select(the_matrix, gene_synonym, drugname_typaslab, conc, sscore)
the_matrix <- spread(the_matrix, key = gene_synonym, value = sscore)

the_matrix_signifs <- select(the_matrix_signifs, gene_synonym, drugname_typaslab, 
  conc, significant)
the_matrix_signifs <- spread(the_matrix_signifs, key = gene_synonym, 
  value = significant, fill = FALSE)
```


## Replacing NA values

Number and fraction of observations affected: less than 2â€°. 

```{r}
# check if all drug names are defined 
stopifnot(!any(is.na(the_matrix$drugname_typaslab)))

sel <- grep(colnames(the_matrix), pattern = "drugname_typaslab|conc")

sum(is.na(the_matrix[, -sel]))
reduce(dim(the_matrix[, -sel]), `*`)

sum(is.na(the_matrix[, -sel])) / 
  reduce(dim(the_matrix[, -sel]), `*`)
```

We replace all NA values with 0.

```{r}
the_matrix[, -sel] <- lapply(the_matrix[, -sel], function(x) {
   x[is.na(x)] <- 0
   return(x)
})

if (any(sapply(the_matrix, is.na))) {
   stop("Undefined values present in the_matrix.")
}
```

We save again this version of the matrix:

```{r}
saveRDS(the_matrix, file = file.path(outdir, 
  "the_matrix_drugsgenesremoved_noNAs_wide.rds"))
```


## Inspecting feature collinearity, determining which features to merge

The following chunks were previously in `Model_lab.Rmd`. 

```{r}
feats <- select(the_matrix, -one_of("drugname_typaslab", "conc"))
feats_cor <- cor(feats, method = "spearman")

# quite a large and unwieldy plot - but still shows a few useful clusters:
if (!file.exists("./plots/Correlation_all_by_all.png")) {
  png("./plots/Correlation_all_by_all.png", width = 90, height = 90, 
    units = "cm", res = 500)
  corrplot::corrplot(feats_cor, method = "color", order = "hclust", 
    tl.cex = 0.1)
  dev.off()
}

# to get a distribution of the correlations:
# get all possible combinations:
corpairs <- melt_cormat_to_pairs(feats_cor)
arrange(corpairs, desc(cor))

# retrieving all protein complexes, code from notebook 1 (Leonard) -----------------------
cmplx = read_tsv(file = "data/All_instances_of_Protein-Complexes_in_Escherichia_coli_K-12_substr._MG1655.txt")
(load("../dbsetup/data/genesWithEG_ID.RData"))
gene_synonyms$synonym = toupper(gene_synonyms$synonym)

genes_cmplx = lapply(cmplx$`Genes of polypeptide, complex, or RNA`,
        FUN = function(x){
            genenames = str_match_all(string = x, pattern = "[a-zA-Z]{3,4}")
            genenames = toupper(unlist(genenames))
       })

names(genes_cmplx) = cmplx$`Protein-Complexes`
genes_cmplx = genes_cmplx[!is.na(genes_cmplx)]

lens = lapply(genes_cmplx, function(x){length(x)})
genes_cmplx = genes_cmplx[lens != 1]
saveRDS(genes_cmplx, file = "./data/programmatic_output/genes_cmplx.rds")

# add to each pair the information if the two genes are also part of the same protein complex
genes_cmplx_v <- unique(unname(unlist(genes_cmplx)))

corpairs$in_same_cmplx <- 
  map2_lgl(corpairs$featA, corpairs$featB, function(.featA, .featB) {
    drugpair <- c(.featA, .featB)
    if (!all(c(.featA, .featB) %in% genes_cmplx_v)) {
      FALSE
      } else {
        any(map_lgl(genes_cmplx, ~ (sum(.x %in% drugpair) == 2)))
      }
    })
# only 354 pairs
View(corpairs[corpairs$in_same_cmplx, ])

ggplot(corpairs, aes(x = cor)) + 
  geom_histogram(bins = 30) + 
  facet_wrap( ~ in_same_cmplx, scales = "free") + 
  labs(title = "Spearman correlations of all mutant pairs.\nLeft: not part of the same protein complex\nRight: within the same protein complex")

# two selected examples (highest and lowest correlation above cutoff):
ggplot(feats, aes(x = NUOE, y = NUOF)) + 
  geom_point() + 
  labs(title = "S-scores across all conditions (Spearman = 0.85)")

ggplot(feats, aes(x = ATPB, y = ATPE)) + 
  geom_point() + 
  labs(title = "S-scores across all conditions (Spearman = 0.75)")

ggplot(feats, aes(x = FLIF, y = FLIQ)) + 
  geom_point() + 
  labs(title = "S-scores across all conditions (Spearman = 0.6)")

```

When choosing a cutoff of 0.6 and requiring that genes are in the same complex 
we get `r sum(corpairs$in_same_cmplx & corpairs$cor > 0.6)` pairs. 
A lot of the genes are part of the NADH:quinone oxidoreductase 
complex (nuoX genes). Other prominent complexes are:
  * the terminal oxidase complex (cyoX)
  * sulfate adenylyltransferase (cysD, cysN)
  * acrAB-tolC 
  * ATP synthase (atpX)
  * the Tol-Pal system (Pal, TolB, TolR, TolQ)
  * TatB-TatC (part of the twin arginine translocation (Tat) complex for the 
  export of folded proteins)
  * some flagellum-related genes (FlhA, FLiF, FliQ)

```{r}
# so we'd probably choose a cutoff of 0.6 or so 
View(corpairs[corpairs$in_same_cmplx & corpairs$cor > 0.6, ])
sum(corpairs$in_same_cmplx & corpairs$cor > 0.6)
sum(corpairs$cor > 0.6)
```

If we don't require them to be in the same complex we get 
`r sum(corpairs$cor > 0.6)` pairs with, among others:

* ribonucleotide biosynthesis (pyrX, purX)
* LPS biosynthesis: rfaX

For details check:

```{r}
View(corpairs[corpairs$cor > 0.6, ])
sum(corpairs$cor > 0.6)
```

Anticorrelation is a lot rarer, only `r sum(corpairs$cor < -0.6)` pairs have a 
Spearman correlation of less than -0.6. 

Notably, Pur and Pyr genes are anticorrelated with RsxB (together with rseC 
turns off SoxR-mediated induction of SoxS), YrbA (= ibaG, defends against acid 
stress), and UbiE/F (ubiquinone biosynthesis). Moreover, GuaB (IMP 
dehydrogenase) is anticorrelated with LipA (lipoate biosynthesis) and Rph 
(an RNAse). 

```{r}
View(corpairs[corpairs$cor < -0.6, ])
sum(corpairs$cor < -0.6)
```

Now merge correlated predictors. Follow procedure from Kuhn et al, p47. 

```{r}
# removed_correlated_feats <- character()
cor_thresh <- 0.6
continue <- TRUE

# involved data sets:
# 1) feats = all features in a tibble
# 2) feats_cor = correlation matrix derived from 1)
# 3) corpairs = melted version of 2)

my_backup <- list(corpairs = corpairs, feats = feats, feats_cor = feats_cor)
corpairs <- my_backup$corpairs
feats <- my_backup$feats
feats_cor <- my_backup$feats_cor

while (continue) {
  list_of_pairs <- list()
  corpairs <- arrange(corpairs, desc(cor))
  above_thresh <- sum(corpairs$cor > cor_thresh)
  
  for (r in seq_len(above_thresh)) {
    pair <- c(corpairs$featA[r], corpairs$featB[r])
    if (any(pair %in% unlist(list_of_pairs))) {
      # we don't want to go through the whole procedure of merging features for every pair 
      # as long as pairs don't overlap we can merge several pairs at once
      break
    } else {
      list_of_pairs <- c(list_of_pairs, list(pair))
    }
  }
  
  # now merge the feats
  for (el in list_of_pairs) {
    # just to be safe ...
    stopifnot(length(el) == 2)
    newfeat <- paste(el[[1]], el[[2]], sep = "_")
    feats[[newfeat]] <- apply(feats[el], 1, mean)
  }
  
  # and calculate everything again
  feats <- select(feats, -one_of(unlist(list_of_pairs)))
  feats_cor <- cor(feats, method = "spearman")
  corpairs <- melt_cormat_to_pairs(feats_cor)
  
  # if not TRUE means we're done
  continue <- max(corpairs$cor > cor_thresh)
}
```

This means that `r ncol(my_backup$feats) - ncol(feats)` features were merged 
into other features. The newly emerged features are:

```{r}
feats_to_merge <- names(feats)[nchar(names(feats)) > 4] %>% 
  str_split(pattern = "_")

saveRDS(feats_to_merge, file = file.path(outdir, "feats_to_merge"))
```

Also plot the correlation matrix again, let's check:

```{r}
feats_cor <- cor(feats, method = "spearman")

# quite a large and unwieldy plot - but still shows a few useful clusters:
if (!file.exists("./plots/Correlation_all_by_all_aftermerge.png")) {
  png("./plots/Correlation_all_by_all_aftermerge.png", width = 90, height = 90, 
    units = "cm", res = 500)
  corrplot::corrplot(feats_cor, method = "color", order = "hclust", 
    tl.cex = 0.1)
  dev.off()
}
```


## Merging collinear features

```{r}
head(feats_to_merge)

merge_features(the_matrix, feats_to_merge, mean)

```















# Generating different 'versions' of our matrix

## Drug selection and drug classification procedures

### Dosage selection

#### Approach 1: "`most_interactions`"

Selects for each drug the one dosages with the highest number of significant 
interactions. If none or all are, keep the highest dosage. 

```{r}
selector <- 
   the_matrix_signifs %>%
   group_by(drugname_typaslab) %>%
   arrange(conc, .by_group = TRUE) %>%
   do(select_dosage_most_ias(.)) %>%
   ungroup() %>%
   pull(selector)

the_matrix <- the_matrix %>%
   group_by(drugname_typaslab) %>%
   arrange(conc, .by_group = TRUE) %>%
   ungroup()

the_matrix_alldosgs_nochemfeats <- the_matrix
the_matrix_mostias_nochemfeats <- the_matrix[selector, ]
```


## Collecting data in a data frame with list columns - matrix_container

```{r}
matrix_container <- 
   tibble(datasets_included = list("nichols_2011", "nichols_2011"), 
          drug_dosages = c("all", "most_interactions"), 
          feat_preselect = c("keepall", "keepall"), 
          chemical_feats = c(FALSE, FALSE), 
          drug_feature_matrices = list(the_matrix_alldosgs_nochemfeats, the_matrix_mostias_nochemfeats))
```


## Feature selection and transformation procedures

### Selecting features with the highest variance

Sort features (i.e. mutants = genes here) by variance and select top x %. 

```{r}
variances_to_select <- c(5, 10, 15, 20, 25, 30, 40, 50)

# add some datasets to our matrix_container: for the table using all dosages, we want to select 
# the genes which have the highest variance (top x%)
targetrow <- match("all", matrix_container$drug_dosages)
for (v in variances_to_select) {
   tmp_row <- matrix_container[targetrow, ] # = row containing matrix with all drug dosages => let's do feature preselection
   tmp_mat <- tmp_row$drug_feature_matrices[[1]]
   tmp_mat <- feature_selection_variance(tmp_mat, featStart = 3, percentTop = v)
   tmp_row$drug_feature_matrices[[1]] <- tmp_mat # replace the matrix
   tmp_row$feat_preselect <- paste0("top", v, "pct") # update metadata
   matrix_container <- bind_rows(matrix_container, tmp_row) # and update our data container
}

# repeat the same thing with the table that doesn't have all dosages but only those dosages with 
# most interactions in the chemical genomics data
# I know, code repetition - shame! but I really want to be explicit here
(targetrow <- match("most_interactions", matrix_container$drug_dosages))
for (v in variances_to_select) {
   tmp_row <- matrix_container[targetrow, ] # = row containing matrix with all drug dosages => let's do feature preselection
   tmp_mat <- tmp_row$drug_feature_matrices[[1]]
   tmp_mat <- feature_selection_variance(tmp_mat, featStart = 3, percentTop = v)
   tmp_row$drug_feature_matrices[[1]] <- tmp_mat # replace the matrix
   tmp_row$feat_preselect <- paste0("top", v, "pct") # update metadata
   matrix_container <- bind_rows(matrix_container, tmp_row) # and update our data container
}
```

### Adding chemical features

Don't use all chemical features from KNIME. Make tables with and without chemical features

```{r}
# check if all drugs in all tables are in our 'drugs_full' table
stopifnot(
   all(
      unique(flatten_chr(map(matrix_container$drug_feature_matrices, "drugname_typaslab")))
      %in%
      drugs_full$drugname_typaslab
   )
)

drugs_full_selected_features <- drugs_full[, c("drugname_typaslab", "SlogP", "LabuteASA", "TPSA", 
                                               "ExactMW", "NumLipinskiHBA", "NumLipinskiHBD", 
                                               "NumRotatableBonds", "NumAmideBonds", 
                                               "NumRings", "NumAromaticRings", "NumSaturatedRings", 
                                               "NumAliphaticRings", "data_effective_rotor_count")]

# take whole matrix_container, add chemical features, update metadata and rbind to old container
matrix_container <- 
   matrix_container %>%
   mutate(drug_feature_matrices = map(drug_feature_matrices, left_join, drugs_full_selected_features), 
          chemical_feats = TRUE, 
          datasets_included = map(datasets_included, append, "knime")) %>%
   bind_rows(matrix_container) %>%
   arrange(drug_dosages, feat_preselect, chemical_feats)
```


## Adding drug classification = mode of action information, generate dfr with list columns

Remove drugs with label "unknown", reducing the number of drugs from 83 to 78. 

```{r}
my_labels <- drugs_full[, c("drugname_typaslab", "process_broad")]
my_labels_knowndrugs <- my_labels[my_labels$process_broad != "unknown", ]

# remove unknown drugs, then add MoA information
matrix_container <- 
   matrix_container %>%
   mutate(drug_feature_matrices = map(drug_feature_matrices, semi_join, my_labels_knowndrugs)) %>%
   mutate(drug_feature_matrices = map(drug_feature_matrices, left_join, my_labels))

# arrange rows nicely
matrix_container$drug_feature_matrices <- 
   map(matrix_container$drug_feature_matrices, select, drugname_typaslab, conc, process_broad, everything())
```

## Adding model and hyperparameter specifications

For all of the above drug-feature matrices we want to run the following:
- random forests with a number of trees and mtry values
- boosted trees in 3 flavours: (i) 'normal' parameters changed, (ii) testing regularisation, (iii) 
  trying out subsample parameters
- lasso regression

```{r}
matrix_container.bak <- matrix_container
matrix_container_tmp <- matrix_container

# stuff common to all: tuning measures, CV instances
# normal instanced repeated stratified CV 
load("./data/programmatic_output/Rep_Nest_CV_instance_newDrugs.RData") 
# as above but with dosages blocked together
load("./data/programmatic_output/Rep_Nest_CV_instance_allDosage.RData") 

matrix_container$tuning_measure <- list("auc" = list(auc, mmce, ppv))
matrix_container$resamp_instance <- 
   ifelse(matrix_container$drug_dosages == "all", 
          list(Rep_Nest_CV_instance_allDosage), 
          list(Rep_Nest_CV_instance_newDrugs))

names(matrix_container$resamp_instance) <- # as ifelse ignores names
   ifelse(matrix_container$drug_dosages == "all", 
          "Rep_Nest_CV_instance_allDosage", 
          "Rep_Nest_CV_instance_newDrugs")


#####################################
## SPECIFYING HYPERPARAMETER GRIDS ##
#####################################
# specify hyperparameter grids, put them into lists with the fitted model as the names of the 
# elements
# lists should have same lengths as matrix_container since the whole matrix_container should be 
# processed once for each hyperparameter grid
# then apply some map magic to collect everything into a big data frame

#### step (1): specifying the hyperparameter grids

# RANDOM FORESTS:
rf_hyp_param <- 
   lapply(
      map_dbl(matrix_container$drug_feature_matrices, ncol), 
      function(x) {
         x <- x - 3 # to account for drugname, process_broad, conc
         makeParamSet(
            makeDiscreteParam("ntree", values = c(200, 500)), 
            makeDiscreteParam("mtry", values = floor(c(x, x*(3/4), x/2, x/4, sqrt(x))))
         )
      }
   )
names(rf_hyp_param) <- rep_len("rf_hyp_param", length(rf_hyp_param))

# XGBOOST:
# (a) 'standard' approach, tuning just most common parameters
xgboost_hyp_param_std <- 
   makeParamSet(
    makeDiscreteParam("nrounds", values = c(200,500)), # number of trees
    makeDiscreteParam("max_depth", values = c(1,2,3, 6)), 
    makeDiscreteParam("eta", values = c(0.01,0.1,0.3)) 
    )
xgboost_hyp_param_std <- rep(list("xgboost_hyp_param_std" = xgboost_hyp_param_std), nrow(matrix_container))

# (b) play around with regularisations
xgboost_hyp_param_reg <- 
   makeParamSet(
    makeDiscreteParam("nrounds", values = c(200,500)), # number of trees
    makeDiscreteParam("max_depth", values = c(1,2,3, 6)), 
    makeDiscreteParam("eta", values = c(0.01,0.1,0.3)), 
    makeDiscreteParam("lambda", values = c(1, 10, 100, 1000)), 
    makeDiscreteParam("alpha", values = c(0, 0.5, 1))
    )
xgboost_hyp_param_reg <- rep(list("xgboost_hyp_param_reg" = xgboost_hyp_param_reg), nrow(matrix_container))

# (c) play around with subsampling functions
xgboost_hyp_param_subsmp <- 
   makeParamSet(
    makeDiscreteParam("nrounds", values = c(200,500)), # number of trees
    makeDiscreteParam("max_depth", values = c(1,2,3, 6)), 
    makeDiscreteParam("eta", values = c(0.01,0.1,0.3)), 
    makeDiscreteParam("subsample", values = c(0.5, 0.8, 1)), 
    makeDiscreteParam("colsample_bytree", values = c(0.5, 0.8, 1))
    )
xgboost_hyp_param_subsmp <- rep(list("xgboost_hyp_param_subsmp" = xgboost_hyp_param_subsmp), nrow(matrix_container))

# LASSO:
lasso_hyp_param <- 
   makeParamSet(
      makeDiscreteParam("alpha", 1), 
      makeDiscreteParam("s", values = seq(from = 0.01, to = 10, length.out = 200))
   )
lasso_hyp_param <- rep(list("lasso_hyp_param" = lasso_hyp_param), nrow(matrix_container))


#### step (2): merging hyperparameter grids + model information with matrix_container

# add here the information about the model that is fitted
hyperparam_container <- 
   list("classif.randomForest" = rf_hyp_param, 
        "classif.xgboost" = xgboost_hyp_param_std, 
        "classif.xgboost" = xgboost_hyp_param_reg, 
        "classif.xgboost" = xgboost_hyp_param_subsmp, 
        "classif.glmnet" = lasso_hyp_param)

# turn into list of data frames
hyperparam_container <- 
   map2(hyperparam_container, 
        names(hyperparam_container), 
        ~data_frame('hyperparam_grid' = .x, 'fitted_model' = .y))

# dplyr functions remove names of list columns with map_dfr - so go back to good old do.call + rbind
matrix_container <- do.call(rbind, map(hyperparam_container, ~bind_cols(matrix_container, .x)))

saveRDS(matrix_container, file = "./data/programmatic_output/matrix_container.rds")
```

For convenience, save one copy of the_matrix with all dosages and one with most interactions (and 
keeping all genes = 'keepall', and no chemical features).

```{r}
tmp <- matrix_container$drug_feature_matrices[[1]]
saveRDS(object = tmp, file = "./data/programmatic_output/the_matrix_matrixcontainer_alldosg.rds")

tmp <- matrix_container$drug_feature_matrices[[91]]
saveRDS(object = tmp, file = "./data/programmatic_output/the_matrix_matrixcontainer_mostinteractions.rds")
```


# System and session info

```{r echo = TRUE, eval = TRUE}
R.version
sessionInfo()
```
