---
title: "Predicting drug mode of action: loading data and preselecting features"
author: "Florian Huber, Leonard Dubois"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_caption: yes
    fig_height: 6
    fig_width: 6
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
editor_options: 
  chunk_output_type: console
---

# Setup, library loading

```{r}
rm(list = ls())
# function to check if a package is installed, if so, load it, else install and then load it
source("./R/ipak.R")
# set chunk options and load libraries
source("./setup.R")
knitr::opts_chunk$set(cache = FALSE)

# directory for automatically generated data:
outdir <- "./data/programmatic_output"
```


# Loading and preprocessing

In all subsequent cases, the final goal is to have a matrix with the drugs in 
the rows and the features in the columns. We will refer to such a matrix as a 
`drug_feature_matrix`. In the next section we will generate different "versions" 
of this matrix, differing, for example, in the number of drugs or features 
selected or whether features were transformed in some way.


## Reading in and joining of tables

```{r, data_import}
indir <- "/Volumes/typas/Florian/dbsetup_tables_new"

(nichols_2011 <- read_delim(file.path(indir, "nichols_2011.csv"), delim = ";"))
(newsize <- read_delim(file.path(indir, "newsize.csv"), delim = ";"))
(shiver <- read_delim(file.path(indir, "shiver.csv"), delim = ";"))
(price <- read_delim(file.path(indir, "price.csv"), delim = ";"))
(genes <- read_delim(file.path(indir, "genes.csv"), delim = ";"))
(drugs_complete <- read_delim(file.path(indir, "drugs.csv"), delim = ";"))

my_datasets <- c("nichols_2011", "newsize", "shiver", "price")
all_studies <- mget(my_datasets) %>% 
  map(~mutate(.x, significant = qvalue <= 0.05))
```

Interestingly, the fraction of significant values varies greatly between the 
data sets:

```{r}
map(all_studies, function(x) {
  sum(x$significant, na.rm = TRUE) / nrow(x)
})
```


Get MoA information.

```{r}
# get mode of action information using Google docs, if it fails look for 
# information on the server
tryCatch(
  error = function(e) {
    moa <- read_delim(file.path(indir, "mode_of_action.csv"))
    return(moa)
  }, 
  {
  gfiles <- drive_find(pattern = "drug_moa")
  outpath <- file.path(outdir, "drug_moa_gdrive.csv")
  drive_download(file = gfiles[1, ], path = outpath, overwrite = TRUE)
  }
)

(mode_of_action <- read_delim(outpath, delim = ",", na = c("-")))
mode_of_action <- mode_of_action[, c("drug", "moa_broad", "moa_subgroup", 
  "dataset")]
colnames(mode_of_action) <- c("drugname_typaslab", "process_broad", 
  "process_subgroup", "dataset")
mode_of_action <- mode_of_action[1:153, ]
mode_of_action_complete <- mode_of_action

stopifnot(all(!duplicated(mode_of_action$drugname_typaslab)))
```

Write out `drugs_complete` with MoA information.

```{r}
(drugs_complete <- left_join(drugs_complete, mode_of_action))
saveRDS(drugs_complete, file = file.path(outdir, "drugs_complete.rds"))
```


# Removing/merging features/drugs, replacing NAs etc.

## Data inspection

For each data set: find out which mutants (= features) have lots of NA values. 
Can do the same for the drugs. Purpose: excluding either mutants that are very 
prone to giving NA values or excluding conditions that don't interact with 
anything. 

```{r}
# then check if it's possible to keep only the overlap
# then merge collinear features, based on Nichols, in all data sets
# replace NA by 0
# do all the things like the_matrix etc. only for Nichols so that we can fit 1-vs-rest like before
# (special step there is the thing with chemical features)

# record for each gene number of significant interactions, NA values
(feature_stats <- map(all_studies, function(x) {
  group_by(x, gene_synonym) %>%
    summarise(n_signif = sum(significant, na.rm = TRUE), 
      n_NA_sscores = sum(is.na(sscore)), 
      unique_conds = length(unique(paste(drugname_typaslab, conc)))) %>%
    arrange(desc(n_NA_sscores))
}))
# add names
feature_stats <- imap(feature_stats, ~{.x$dataset = .y; return(.x)})

# and now the same for drugs: drug-dosage combinations that don't interact with 
# anything will be difficult to predict
(drug_stats <- map(all_studies, function(x) {
  group_by(x, drugname_typaslab, conc) %>%
    summarise(n_signif = sum(significant, na.rm = TRUE), 
      n_NA_sscores = sum(is.na(sscore))) %>%
    arrange(n_signif)
}))
drug_stats <- imap(drug_stats, ~{.x$dataset = .y; return(.x)})
```

Number of NA values per condition. Why so many in the shiver data? Why 
distribution so different between newsize and nichols?

```{r}
feature_stats %>% 
  bind_rows() %>%
  ggplot(aes(x = dataset, y = n_NA_sscores)) +
  geom_jitter(shape = 1, height = 0) + 
  annotate("text", x = 1:4, y = 40, label = paste("N = ", c(95, 275, 26, 28))) + 
  labs(title = "Number of NA values per mutant")
```

Statistics of how many mutants have 0, 1, 2, etc. number of interactions.

```{r}
feature_stats %>%
  bind_rows() %>%
  group_by(dataset) %>%
  count(n_signif) %>%
  ggplot(aes(x = n_signif, y = n)) + 
  geom_bar(stat = "identity") + 
  facet_wrap( ~ dataset, scales = "free") + 
  labs(title = "Number of genes per number of significant interactions", 
    x = "Number of significant interactions", y = "Number of genes")
```

Do the same for drugs. It looks like price and shiver data sets behave very 
differently from nichols and newsize. 

```{r}
drug_stats %>%
  bind_rows() %>%
  group_by(dataset) %>%
  count(n_signif) %>%
  ggplot(aes(x = n_signif)) + 
  geom_freqpoly(binwidth = 10) + 
  facet_wrap( ~ dataset) + 
  labs(title = "Number of conditions per number of significant interactions (binwidth = 10)", 
    x = "Number of significant interactions", y = "Number of conditions")
```

## Removing drugs/features

Inspecting the data suggests the following:
  * Only work with Nichols and Newsize because Price and Shiver seem to behave 
  quite differently. Moreover, they don't add much more drugs that aren't 
  already present in Nichols and Newsize. The following points only apply to 
  those 2 datasets. 
  * Remove features that have 10 or more NA values. 
  * Remove conditions with less than 5 significant interactions. 
  * Finally, we also want to remove conditions that have no significant 
  interaction as they are likely to not yield any information. 

```{r}
(feats_to_exclude_NAs <- 
  map(feature_stats[c("nichols_2011", "newsize")], ~filter(.x, n_NA_sscores > 10)))

(conds_to_exclude <- 
  map(drug_stats[c("nichols_2011", "newsize")], ~filter(.x, n_signif < 5)))

(feats_no_IAs <- 
  map(feature_stats[c("nichols_2011", "newsize")], ~filter(.x, n_signif == 0)))
```

Now, for actually excluding conditions/features, do the following: 

  1. Features with many NAs: if a feature fulfills this criterion, remove it 
  everywhere.
  2. Features with no interactions: only remove if they don't interact in all 
  of the data sets. 

And finally:
  3. Only keep features that are in both nichols and newsize. 

```{r}
# Number of features that don't interact with anything between nichols and 
# newsize.
venn(list(nichols = feats_no_IAs$nichols_2011$gene_synonym, 
  newsize = feats_no_IAs$newsize$gene_synonym))
```

Write out data nichols and newsize data without any changes and then after 
removing the features.

```{r}
kept_studies <- all_studies[c("nichols_2011", "newsize")]
saveRDS(kept_studies, file.path(outdir, "kept_datasets_long_nochanges.rds"))

# excluding conditions
kept_studies <- imap(kept_studies, function(data, name) {
  # remove conditions with few interactions
  to_remove <- conds_to_exclude[[name]]
  data <- data[!(paste(data$drugname_typaslab, data$conc) %in% 
      paste(to_remove$drugname_typaslab, to_remove$conc)), ]
  
  # remove features with lots of NAs
  data <- data[!(data$gene_synonym %in% 
      feats_to_exclude_NAs[[name]][["gene_synonym"]]), ]
  
  # remove features never interacting with anything
  to_remove <- reduce(map(feats_no_IAs, "gene_synonym"), dplyr::intersect)
  data <- data[!(data$gene_synonym %in% to_remove), ]
  return(data)
})
```

And finally, only keep features that are both in nichols and newsize. 

```{r}
# before:
venn(list(nichols = unique(kept_studies$nichols_2011$gene_synonym), 
  newsize = unique(kept_studies$newsize$gene_synonym)))

# after:
kept_studies <- map(kept_studies, function(data) {
  total_intersect <- reduce(map(kept_studies, "gene_synonym"), dplyr::intersect)
  data <- data[data$gene_synonym %in% total_intersect, ]
})
venn(list(nichols = unique(kept_studies$nichols_2011$gene_synonym), 
  newsize = unique(kept_studies$newsize$gene_synonym)))
```

Save to disk.

```{r}
saveRDS(kept_studies, file.path(outdir, 
  "kept_datasets_long_featsndrugs_removed.rds"))
```

### Correlation between Nichols and Newsize

Leaves the question: how well do conditions correlate? 

```{r}
# for each condition that is the same: calculate correlation coefficient
(nic <- select(kept_studies$nichols_2011, gene_synonym, drugname_typaslab, 
  conc, sscore))
(new <- select(kept_studies$newsize, gene_synonym, drugname_typaslab, conc, 
  sscore))

cors <- 
  semi_join(nic, new, by = c("gene_synonym", "drugname_typaslab", "conc")) %>%
  left_join(new, by = c("gene_synonym", "drugname_typaslab", "conc"), suffix = 
      c(".nic", ".new"))

# e.g.: A22: 
filter(cors, drugname_typaslab == "A22", conc == 2) %>%
  ggplot(aes(x = sscore.nic, y = sscore.new)) + 
  geom_point()

# spearman corrs across all conditions:
group_by(cors, drugname_typaslab, conc) %>%
  summarise(spearman = cor(sscore.nic, sscore.new, method = "spearman", 
    use = "complete.obs")) %>%
  ggplot(aes(x = "", y = spearman)) + 
  ggrepel::geom_text_repel(aes(label = paste0(drugname_typaslab, "_", conc)), 
    size = 3) +
  labs(title = "Spearman correlation of conditions shown across all genes", 
    x = "", y = "Spearman's rho")
```


## Spread data, replace NA values

Convert to wide format. `NA` values are replaced by 0 for s-scores and `FALSE` 
for significance values (qvalues). 

```{r}
kept_studies_wide <- unlist(
  map(kept_studies, function(data) {
    data <- filter(data, !is.na(conc))
    sscores <- select(data, gene_synonym, drugname_typaslab, conc, sscore) %>%
      spread(key = gene_synonym, value = sscore, fill = 0)
    qvals <- select(data, gene_synonym, drugname_typaslab, conc, significant) %>%
      spread(key = gene_synonym, value = significant, fill = FALSE)
    stopifnot({
      all(!is.na(sscores))
      all(!is.na(qvals))
    })
    return(list(sscores = sscores, qvals = qvals))
  }), 
  recursive = FALSE)
```

Save.

```{r}
saveRDS(kept_studies_wide, file.path(outdir, 
  "kept_datasets_wide_featsndrugs_removed_noNAs.rds"))

the_matrix <- kept_studies_wide$nichols_2011.sscores
```


## Exploring (and later merging) between-feature correlations

### Exploring correlated features.

```{r}
feats <- select(the_matrix, -one_of("drugname_typaslab", "conc"))
feats_cor <- cor(feats, method = "spearman")

# quite a large and unwieldy plot - but still shows a few useful clusters:
if (!file.exists("./plots/Correlation_all_by_all.png")) {
  png("./plots/Correlation_all_by_all.png", width = 90, height = 90, 
    units = "cm", res = 500)
  corrplot::corrplot(feats_cor, method = "color", order = "hclust", 
    tl.cex = 0.1)
  dev.off()
}

# to get a distribution of the correlations:
# get all possible combinations:
corpairs <- melt_cormat_to_pairs(feats_cor)
arrange(corpairs, desc(cor))

# retrieving all protein complexes, code from notebook 1 (Leonard) -----------
cmplx = read_tsv(file = "data/All_instances_of_Protein-Complexes_in_Escherichia_coli_K-12_substr._MG1655.txt")
(load("../dbsetup/data/genesWithEG_ID.RData"))
gene_synonyms$synonym = toupper(gene_synonyms$synonym)

genes_cmplx = lapply(cmplx$`Genes of polypeptide, complex, or RNA`,
        FUN = function(x){
            genenames = str_match_all(string = x, pattern = "[a-zA-Z]{3,4}")
            genenames = toupper(unlist(genenames))
       })

names(genes_cmplx) = cmplx$`Protein-Complexes`
genes_cmplx = genes_cmplx[!is.na(genes_cmplx)]

lens = lapply(genes_cmplx, function(x){length(x)})
genes_cmplx = genes_cmplx[lens != 1]
saveRDS(genes_cmplx, file = "./data/programmatic_output/genes_cmplx.rds")

# add to each pair the information if the two genes are also part of the same 
# protein complex
genes_cmplx_v <- unique(unname(unlist(genes_cmplx)))

corpairs$in_same_cmplx <- 
  map2_lgl(corpairs$featA, corpairs$featB, function(.featA, .featB) {
    drugpair <- c(.featA, .featB)
    if (!all(c(.featA, .featB) %in% genes_cmplx_v)) {
      FALSE
      } else {
        any(map_lgl(genes_cmplx, ~ (sum(.x %in% drugpair) == 2)))
      }
    })
# View(corpairs[corpairs$in_same_cmplx, ])

ggplot(corpairs, aes(x = cor)) + 
  geom_freqpoly(binwidth = 0.05) + 
  facet_wrap( ~ in_same_cmplx, scales = "free") + 
  labs(title = "Spearman correlations of all mutant pairs.
    Left: not part of the same protein complex
    Right: within the same protein complex")

# two selected examples (highest and lowest correlation above cutoff):
ggplot(feats, aes(x = NUOE, y = NUOF)) + 
  geom_point() + 
  labs(title = "S-scores across all conditions (Spearman = 0.84)")

ggplot(feats, aes(x = ATPB, y = ATPE)) + 
  geom_point() + 
  labs(title = "S-scores across all conditions (Spearman = 0.75)")

ggplot(feats, aes(x = FLIF, y = FLIQ)) + 
  geom_point() + 
  labs(title = "S-scores across all conditions (Spearman = 0.58)")
```

When choosing a cutoff of 0.6 and requiring that genes are in the same complex 
we get `r sum(corpairs$in_same_cmplx & corpairs$cor > 0.6)` pairs. 
A lot of the genes are part of the NADH:quinone oxidoreductase 
complex (nuoX genes). Other prominent complexes are:
  * the terminal oxidase complex (cyoX)
  * sulfate adenylyltransferase (cysD, cysN)
  * acrAB-tolC 
  * ATP synthase (atpX)
  * the Tol-Pal system (Pal, TolB, TolR, TolQ)
  * TatB-TatC (part of the twin arginine translocation (Tat) complex for the 
  export of folded proteins)
  * some flagellum-related genes (FlhA, FLiF, FliQ)

```{r}
# so we'd probably choose a cutoff of 0.6 or so 
# View(corpairs[corpairs$in_same_cmplx & corpairs$cor > 0.6, ])
sum(corpairs$in_same_cmplx & corpairs$cor > 0.6)
sum(corpairs$cor > 0.6)
```

If we don't require them to be in the same complex we get 
`r sum(corpairs$cor > 0.6)` pairs with, among others:

* ribonucleotide biosynthesis (pyrX, purX)
* LPS biosynthesis: rfaX

For details check:

```{r}
# View(corpairs[corpairs$cor > 0.6, ])
sum(corpairs$cor > 0.6)
```

Anticorrelation is a lot rarer, only `r sum(corpairs$cor < -0.6)` pairs have a 
Spearman correlation of less than -0.6. 

Notably, Pur and Pyr genes are anticorrelated with RsxB (together with rseC 
turns off SoxR-mediated induction of SoxS), YrbA (= ibaG, defends against acid 
stress), and UbiE/F (ubiquinone biosynthesis). Moreover, GuaB (IMP 
dehydrogenase) is anticorrelated with LipA (lipoate biosynthesis) and Rph 
(an RNAse). 


### Merging correlated features

Now merge correlated predictors. Use a bit higher threshold (0.7) because 
otherwise it would merge too many features. Iterative averaging not an option 
because `mean(mean(c(a, b)), c) != mean(c(a, b, c))`. Instead, do 
correlation-based hierarchical clustering of all genes which have at least one 
correlation above the threshold. Then based on this result determine clusters 
and calculate centroids of the clusters. 

```{r}
cor_thresh <- 0.7
(high_cor_genes <- unique(unlist(corpairs[corpairs$cor > cor_thresh, 
  c("featA", "featB")])))
```

So `r length(high_cor_genes)` are affected. 

Make hierarchical clustering

```{r}
feats_cor_high <- feats_cor[high_cor_genes, high_cor_genes]
feats_cor_high_d <- as.dist(1 - feats_cor_high)

pdf("./plots/correlated_feats.pdf", width = 14, height = 14)
heatmap.2(feats_cor_high, 
  trace = "none", 
  Rowv = as.dendrogram(hclust(feats_cor_high_d)), 
  symm = TRUE, 
  dendrogram = "both", 
  cexRow = 0.5)
dev.off()
```

[Link]("./plots/correlated_feats.pdf"). 

Looks like 23 clusters is a good number to capture similar groups. 

```{r}
nclust <- 23
clusters <- cutree(hclust(feats_cor_high_d), k = nclust)
clusters[order(clusters)]
clusters <- tibble(clust_id = clusters, members = names(clusters)) %>%
  group_by(clust_id) %>%
  nest(.key = members) %>%
  mutate(members = map(members, flatten_chr))

clusters$clust_label <- sapply(clusters$members, function(x) {
  ifelse(length(x) < 3, 
    paste(x, collapse = "_"), 
    paste0(x[1], "_and_", length(x) - 1, "_more"))
})
clusters
saveRDS(object = clusters, file = file.path(outdir, "clusters.rds"))
```

Now merge the features by calculating the centroids in case of sscores. For 
qvalues set to `TRUE` if at least one of the members is `TRUE`. 

```{r}
kept_studies_wide.bak <- kept_studies

# merge features in clusters frame using function f of merge_features(), 
# then remove features that have been merged 
tmp <- c("nichols_2011.sscores", "newsize.sscores")
kept_studies_wide[tmp] <- map(kept_studies_wide[tmp], merge_features, 
  cluster_fr = clusters, f = mean)

tmp <- c("nichols_2011.qvals", "newsize.qvals")
kept_studies_wide[tmp] <- map(kept_studies_wide[tmp], merge_features, 
  cluster_fr = clusters, f = any)

saveRDS(kept_studies_wide, file = file.path(outdir, 
  "kept_datasets_wide_featsndrugs_removed_noNAs_featsmerged.rds"))
```


Plot the correlation matrix again, let's check:

```{r}
the_matrix <- kept_studies_wide$nichols_2011.sscores
feats <- select(the_matrix, -one_of("drugname_typaslab", "conc"))
feats_cor <- cor(feats, method = "spearman")

# quite a large and unwieldy plot - but still shows a few useful clusters:
if (!file.exists("./plots/Correlation_all_by_all_aftermerge.png")) {
  png("./plots/Correlation_all_by_all_aftermerge.png", width = 90, height = 90, 
    units = "cm", res = 500)
  corrplot::corrplot(feats_cor, method = "color", order = "hclust", 
    tl.cex = 0.1)
  dev.off()
}
```


# `the_matrix_container` for comparative model assessment

Note: until commit 716861c processing steps were quite different because only 
at that commit other datasets were properly integrated. Main difference is that 
a number of preprocessing steps were based on a limited selection of drugs. 
Now the preprocessing steps take more drugs and also other datasets into 
account whereas processing steps of `the_matrix` are now specific to stuff 
that is needed for comparative model assessment. New are drugs Bicyclomycin, 
CecropinB, Dibucaine, Procaine (had been excluded before). 


## Removing drugs

In principle, keep all drugs. However, for model assessment, only keep drugs 
that:
  * are in the Nichols data set
  * Have chemical features defined
  * Have one of the four "main" modes of action: cell_wall, dna, 
  membrane_stress, protein_synthesis

--> Tables `drugs_complete` and `drugs_subset`. 

```{r}
the_matrix <- kept_studies_wide$nichols_2011.sscores
the_matrix_signifs <- kept_studies_wide$nichols_2011.qvals

main_moas <- c("cell_wall", "dna", "membrane_stress", "protein_synthesis")
drugs_subset <- filter(drugs_complete, dataset == "NICHOLS", !is.na(SlogP), 
  process_broad %in% main_moas)
drugs_subset
table(drugs_subset$process_broad)
saveRDS(drugs_subset, file = file.path(outdir, "drugs_subset.rds"))
```

Subset `the_matrix` accordingly. 

```{r}
# keep only drugs in drug_subset
the_matrix <- filter(the_matrix, drugname_typaslab %in% 
    unique(drugs_subset$drugname_typaslab))
saveRDS(the_matrix, file = file.path(outdir, "the_matrix_keepall_wide.rds"))

the_matrix_signifs <- filter(the_matrix_signifs, drugname_typaslab %in% 
    unique(drugs_subset$drugname_typaslab))
saveRDS(the_matrix, file = file.path(outdir, "the_matrix_keepall_wide.rds"))
```


## Generating `matrix_container`

### Generating different versions of the_matrix

Put all information for subsequent model fitting into `matrix_container`, which 
should contain all information to fit a machine learning model. 

```{r}
matrix_container <- 
   tibble(datasets_included = list("nichols_2011"), 
          drug_dosages = c("all"), 
          feat_preselect = c("keepall"), 
          chemical_feats = c(FALSE), 
          drug_feature_matrices = list(the_matrix))
```

### Selecting variances

Keep features with highest variance (top x%, but only the mutants). 

```{r}
variances_to_select <- c(5, 10, 15, 20, 25, 30, 40, 50)

# add some datasets to our matrix_container: for the table using all dosages, 
# we want to select the genes which have the highest variance (top x%)
stopifnot(nrow(matrix_container) == 1)
targetrow <- 1
targetmat <- matrix_container$drug_feature_matrices[[targetrow]]
for (v in variances_to_select) {
  # tmp_row contains matrix with all drug dosages to do feature preselection
  tmp_row <- matrix_container[targetrow, ] 
  # tmp_mat <- tmp_row$drug_feature_matrices[[1]]
  tmp_mat <- feature_selection_variance(targetmat, featStart = 3, percentTop = v)
  tmp_row$drug_feature_matrices[[1]] <- tmp_mat # replace the matrix
  tmp_row$feat_preselect <- paste0("top", v, "pct") # update metadata
  matrix_container <- bind_rows(matrix_container, tmp_row) # and the data container
}
```

### Selecting dosages

Either keep all dosages or dosage with most number of interactions (after 
selecting for most variant features). 

```{r}
(matrix_container <- 
  matrix_container %>% 
  mutate(drug_dosages = "most_interactions", 
    drug_feature_matrices = 
      map(drug_feature_matrices, select_most_ias, 
        the_matrix_signifs = the_matrix_signifs)) %>%
  bind_rows(matrix_container))
```

### Adding chemical features

Don't use all chemical features from KNIME. Make tables with and without 
chemical features.

```{r}
# Make sure we have all drugs recorded in drugs_subset:
stopifnot(
   all(unique(flatten_chr(map(matrix_container$drug_feature_matrices, "drugname_typaslab")))
      %in%
      drugs_subset$drugname_typaslab)
)

# keep selected chemical features
drugs_subset_selected_features <- drugs_subset[, c("drugname_typaslab", 
  "SlogP", "LabuteASA", "TPSA", "ExactMW", "NumLipinskiHBA", "NumLipinskiHBD",
  "NumRotatableBonds", "NumAmideBonds", "NumRings", "NumAromaticRings", 
  "NumSaturatedRings", "NumAliphaticRings", "data_effective_rotor_count")]

# take whole matrix_container, add chemical features, update metadata and 
# rbind to old container
(matrix_container <- 
   matrix_container %>%
   mutate(drug_feature_matrices = map(drug_feature_matrices, left_join, drugs_subset_selected_features), 
          chemical_feats = TRUE, 
          datasets_included = map(datasets_included, append, "knime")) %>%
   bind_rows(matrix_container) %>%
   arrange(drug_dosages, feat_preselect, chemical_feats))
```

### Adding MoA labels

```{r}
my_labels <- drugs_subset[, c("drugname_typaslab", "process_broad")]

# add MoA information to all drug_feature_matrices
matrix_container <- 
   matrix_container %>%
   mutate(drug_feature_matrices = map(drug_feature_matrices, left_join, my_labels))

# arrange columns nicely
matrix_container$drug_feature_matrices <- 
   map(matrix_container$drug_feature_matrices, select, drugname_typaslab, conc, 
     process_broad, everything())
```

### Generating nested CV instances

Need one matrix for all dosages and another one for dosage with most 
interactions. While the drug-dosage combination may differ depending on the 
variance selection, it doesn't matter for the CV instance creation which one 
to take as long as it's the same drugs in the same order. 

```{r, cvinst_generation}
# ensure that the order of the drugs is the same throughout:
invisible(filter(matrix_container, drug_dosages == "all") %>%
  pull(drug_feature_matrices) %>%
  map("drugname_typaslab") %>%
  reduce(function(a, b) {
    if (all(a == b)) return(a) else stop()
  }))

invisible(filter(matrix_container, drug_dosages == "most_interactions") %>%
  pull(drug_feature_matrices) %>%
  map("drugname_typaslab") %>%
  reduce(function(a, b) {
    if (all(a == b)) return(a) else stop()
  }))

cvinst_alldosg_input <- 
  (filter(matrix_container, drug_dosages == "all") %>%
  pull(drug_feature_matrices))[[1]]
saveRDS(cvinst_alldosg_input, file.path(outdir, "cvinst_alldosg_input.rds"))

cvinst_mostias_input <- 
  (filter(matrix_container, drug_dosages == "most_interactions") %>%
  pull(drug_feature_matrices))[[1]]
saveRDS(cvinst_mostias_input, file.path(outdir, "cvinst_mostias_input.rds"))

# most interactions repeated nested cv instance required as input for cv 
# instance generation of all dosages
rep_ncvinst_mostias <- list()
for (i in 1:10) {
  rep_ncvinst_mostias[[paste0("NCV_", i)]] <- 
    instance_creation(dataset = cvinst_mostias_input, nFoldsOuter = 8, 
      nFoldsInner = 8)
}
run_cv_tests(rep_ncvinst_mostias, data = cvinst_mostias_input)
saveRDS(rep_ncvinst_mostias, file.path(outdir, "rep_ncvinst_mostias.rds"))

# now generate rep nested cv instance for all dosages (works via mapping 
# approach, drugs with different dosages are moved together)
rep_ncvinst_alldosg <- 
  RepNCV_instance_map_drugname(instance_oneDrug = rep_ncvinst_mostias, 
    dataset_oneDosage = cvinst_mostias_input, 
    dataset_allDosage = cvinst_alldosg_input)
run_cv_tests(rep_ncvinst_alldosg, data = cvinst_alldosg_input)
saveRDS(rep_ncvinst_alldosg, file.path(outdir, "rep_ncvinst_alldosg.rds"))
```


## Adding model and hyperparameter specifications

For all of the above drug-feature matrices we want to run the following:
  * random forests with a number of trees and mtry values
  * boosted trees in 3 flavours
    + (i) 'normal' parameters changed
    + (ii) testing regularisation
    + (iii) trying out subsample parameters
  * lasso regression

```{r}
matrix_container.bak <- matrix_container

# stuff common to all: tuning measures, CV instances
matrix_container$tuning_measure <- list("auc" = list(auc, mmce, ppv))
matrix_container$resamp_instance <- 
   ifelse(matrix_container$drug_dosages == "all", 
          list(rep_ncvinst_alldosg), 
          list(rep_ncvinst_mostias))


## SPECIFYING HYPERPARAMETER GRIDS #----------------------------
# specify hyperparameter grids, put them into lists with the fitted model as 
# the names of the elements
# lists should have same lengths as matrix_container since the whole 
# matrix_container should be processed once for each hyperparameter grid
# then apply some map magic to collect everything into a big data frame

#### step (1): specifying the hyperparameter grids

# RANDOM FORESTS:
rf_hyp_param <- 
   lapply(
      map_dbl(matrix_container$drug_feature_matrices, ncol), 
      function(x) {
         x <- x - 3 # to account for drugname, process_broad, conc
         makeParamSet(
            makeDiscreteParam("ntree", values = c(200, 500)), 
            makeDiscreteParam("mtry", values = floor(c(x, x*(3/4), x/2, x/4, sqrt(x))))
         )
      }
   )
names(rf_hyp_param) <- rep_len("rf_hyp_param", length(rf_hyp_param))

# XGBOOST:
# (a) 'standard' approach, tuning just most common parameters
xgboost_hyp_param_std <- 
   makeParamSet(
    makeDiscreteParam("nrounds", values = c(200,500)), # number of trees
    makeDiscreteParam("max_depth", values = c(1,2,3, 6)), 
    makeDiscreteParam("eta", values = c(0.01,0.1,0.3)) 
    )
xgboost_hyp_param_std <- 
  rep(list("xgboost_hyp_param_std" = xgboost_hyp_param_std), 
    nrow(matrix_container))

# (b) play around with regularisations
xgboost_hyp_param_reg <- 
   makeParamSet(
    makeDiscreteParam("nrounds", values = c(200,500)), # number of trees
    makeDiscreteParam("max_depth", values = c(1,2,3, 6)), 
    makeDiscreteParam("eta", values = c(0.01,0.1,0.3)), 
    makeDiscreteParam("lambda", values = c(1, 10, 100, 1000)), 
    makeDiscreteParam("alpha", values = c(0, 0.5, 1))
    )
xgboost_hyp_param_reg <- 
  rep(list("xgboost_hyp_param_reg" = xgboost_hyp_param_reg), 
    nrow(matrix_container))

# (c) play around with subsampling functions
xgboost_hyp_param_subsmp <- 
   makeParamSet(
    makeDiscreteParam("nrounds", values = c(200,500)), # number of trees
    makeDiscreteParam("max_depth", values = c(1,2,3, 6)), 
    makeDiscreteParam("eta", values = c(0.01,0.1,0.3)), 
    makeDiscreteParam("subsample", values = c(0.5, 0.8, 1)), 
    makeDiscreteParam("colsample_bytree", values = c(0.5, 0.8, 1))
    )
xgboost_hyp_param_subsmp <- 
  rep(list("xgboost_hyp_param_subsmp" = xgboost_hyp_param_subsmp), 
    nrow(matrix_container))

# LASSO:
lasso_hyp_param <- 
   makeParamSet(
      makeDiscreteParam("alpha", 1), 
      makeDiscreteParam("s", values = seq(from = 0.01, to = 10, length.out = 200))
   )
lasso_hyp_param <- rep(list("lasso_hyp_param" = lasso_hyp_param), 
  nrow(matrix_container))


#### step (2): merging hyperparameter grids + model information with matrix_container

# add here the information about the model that is fitted
hyperparam_container <- 
   list("classif.randomForest" = rf_hyp_param, 
        "classif.xgboost" = xgboost_hyp_param_std, 
        "classif.xgboost" = xgboost_hyp_param_reg, 
        "classif.xgboost" = xgboost_hyp_param_subsmp, 
        "classif.glmnet" = lasso_hyp_param)

# turn into list of data frames
hyperparam_container <- 
   map2(hyperparam_container, 
        names(hyperparam_container), 
        ~data_frame('hyperparam_grid' = .x, 'fitted_model' = .y))

# dplyr functions remove names of list columns with map_dfr - so go back to good old do.call + rbind
matrix_container <- do.call(rbind, 
  map(hyperparam_container, ~bind_cols(matrix_container, .x)))
saveRDS(matrix_container, file.path(outdir, "matrix_container_2019.rds"))
```

For convenience, save one copy of the_matrix with all dosages and one with most 
interactions (and keeping all genes = 'keepall', and no chemical features, 
note that drug-dosage combinations kept may differ in the not 'keepall' 
data sets).

```{r}
filter_container(matrix_container, dosgs = "all", feats = "keepall", 
  chemfeats = FALSE, models = "classif.randomForest")$drug_feature_matrices[[1]] %>%
  saveRDS(file = file.path(outdir, "the_matrix_matrixcontainer_alldosg_2019.rds"))

filter_container(matrix_container, dosgs = "most_interactions", feats = "keepall", 
  chemfeats = FALSE, models = "classif.randomForest")$drug_feature_matrices[[1]] %>%
  saveRDS(file = file.path(outdir, "the_matrix_matrixcontainer_mostias_2019.rds"))
```


# System and session info

```{r}
R.version
sessionInfo()
```
