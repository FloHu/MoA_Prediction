---
title: "Inspecting models"
author: "Florian Huber, Leonard Dubois"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_caption: yes
    fig_height: 6
    fig_width: 6
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
editor_options: 
  chunk_output_type: console
---

# Setup, library loading

This part is the general setup, whichever model we are using.

```{r setup}
# function to check if a package is installed, if so, load it, else install and then load it
source("./R/ipak.R")
# set chunk options and load libraries
source("./setup.R")
# custom functions
walk(list.files("./R", pattern = "*.R", full.names = T), source)

matrix_container = readRDS("/Volumes/typas/Florian/matrix_container_withextractions.rds")
ipak(plotmo)
ipak(reshape2)
ipak(gplots)
ipak("gridExtra")
ipak("plotly")
```


Aim of this notebook is to have a deeper look at all the different results from the matrix container and understand which features are used, for what, which of them help us defining groups based on MoA.


# Lasso model regularization paths

First, we have a look at the regularization path of a LASSO model, which is the evolution of the coefficient for one feature depending on the value of the regularization parameter lambda. Regularization path are contained in a matrix in lasso model objects build with glmnet.

Main problem here is that it exist 80 slightly different regularization path in one run : one for each outer fold times the number of repetitions

It would be great to find a way to average all of this...

```{r}
# Result object to test
resObj = readRDS("run_results_from_server/matrix_container_result/lasso_hyp_param_all_top5pct_TRUE.rds")

#   par(mfrow = c(4,2))
#   for(i in 1:8){plot_glmnet(resObj$`Nested CV 1`[[paste0("Outer fold ", i)]]$model_dna$learner.model)}


# For a given model, example with NCV 1, Outer fold 1 DNA MoA
modelInstance = resObj$`Nested CV 1`$`Outer fold 1`$model_dna

# I write my own function for the plot_glmnet one form the plotmo package is not that great.

plot_reg_path = function(modelInstance){
    lambda_for_pred = modelInstance$learner$par.vals$s
    # Get the index of the lambda used in model building which is the closest to s, the lambda used for testing
    closest_lambda_index = which.min(abs(lambda_for_pred - modelInstance$learner.model$lambda))
    
    coeffs = as.matrix(modelInstance$learner.model$beta[, 1:closest_lambda_index])
    coeffs = coeffs[ rowSums(coeffs)!=0, ] 
    coeffs = as.data.frame(coeffs)
    colnames(coeffs) = seq(1:ncol(coeffs))
    coeffs$feat = rownames(coeffs)
    
    coeffs_plotable = melt(coeffs, id.vars = "feat")
    coeffs_plotable$variable = as.numeric(coeffs_plotable$variable)
    ggplot() + geom_path(data = coeffs_plotable, mapping = aes(x = variable, y = value, group = feat)) +
            geom_hline(yintercept = 0, linetype="dashed") +
            annotate("text", x = ncol(coeffs), y = coeffs[, ncol(coeffs)-1], label = coeffs$feat) +
            theme_bw() + xlim(0,ncol(coeffs)+5)
}

dna11 = plot_reg_path(resObj$`Nested CV 1`$`Outer fold 1`$model_dna)
dna12 = plot_reg_path(resObj$`Nested CV 1`$`Outer fold 2`$model_dna)
dna13 = plot_reg_path(resObj$`Nested CV 1`$`Outer fold 3`$model_dna)
dna14 = plot_reg_path(resObj$`Nested CV 1`$`Outer fold 4`$model_dna)

grid.arrange(dna11, dna12, dna13, dna14, nrow = 2)

```


# Averaging Lasso coefficients

Idea : boxplot of the values of the coefficient aassociated with one feature across rep/fold.
On top of that, we use a color code depending on in how many models does a feature appear

```{r}

plot_cat_lasso_coeffs = function(resObj, moa = "dna", thres = 0, return_obj = FALSE, ...){
    
    match.arg(arg = moa, choices = c("cell_wall", "dna", "membrane_stress", "protein_synthesis"))
    
    nrep = length(resObj)
    nfold = length(resObj[[1]])
    #List of coefficient values across all models
    coeff_cat = list()
    
    for(rep in 1:nrep){
        for(fold in 1:nfold){
            model = resObj[[rep]][[nfold]][[paste0("model_", moa)]]
            
            lambda_for_pred = model$learner$par.vals$s
            # Get the index of the lambda used in model building that is the closest to s, the lambda used for testing
            closest_lambda_index = which.min(abs(lambda_for_pred - model$learner.model$lambda))
            
            coeffs = as.matrix(model$learner.model$beta[, closest_lambda_index])
            coeffs = coeffs[coeffs !=0,  ]
            for(n in names(coeffs)){
                coeff_cat[[n]] = c(coeff_cat[[n]], coeffs[n])
            }
        }
    }

    #eff contains how many times features appear in a model
    eff = sort(unlist(lapply(coeff_cat, length)))
    coeff_cat = coeff_cat[names(eff)]

    # filter
    coeff_cat = coeff_cat[(eff/80) >= thres]
    eff = eff[(eff/80) >= thres]
    
    colMap = rainbow(length(unique(eff)))
    names(colMap) = unique(eff)
    
    par(mar = c(5,10,4,2))
    boxplot(coeff_cat, horizontal = T, las = 2, lwd = 1.5, col = colMap[as.character(eff)], ...)
    legend("bottomleft", legend = paste0(as.numeric(names(colMap))/80 * 100, " %"), 
           fill = colMap, title = "Present in % models", cex = 0.8)
    abline(v = 0)
    if(return_obj){
        return(coeff_cat)
    }
}

# Simple test to see how the function behave

lasso_5pc = readRDS("run_results_from_server/matrix_container_result/lasso_hyp_param_all_top5pct_TRUE.rds")

par(mfrow = c(2,2))
plot_cat_lasso_coeffs(resObj = lasso_5pc, moa = "dna", main= "Lasso 5pc dna", thres = 0.6)
plot_cat_lasso_coeffs(resObj = lasso_5pc, moa = "cell_wall", main= "Lasso 5pc cell_wall", thres = 0.6)
plot_cat_lasso_coeffs(resObj = lasso_5pc, moa = "membrane_stress", main= "Lasso 5pc membrane_stress", thres = 0.6)
plot_cat_lasso_coeffs(resObj = lasso_5pc, moa = "protein_synthesis", main= "Lasso 5pc protein_synthesis", thres = 0.6)

```


# Similar function for tree based models 

It averages the feature importance score for tree based models, which is the Decrease in Gini impurity

```{r}

plot_cat_xgb_feat_importance = function(resObj, moa = "dna", thres = 0, return_obj = FALSE, ...){
    
    match.arg(arg = moa, choices = c("cell_wall", "dna", "membrane_stress", "protein_synthesis"))
    
    nrep = length(resObj)
    nfold = length(resObj[[1]])
    #List of coefficient values across all models
    feat_cat = list()
    
    for(rep in 1:nrep){
        for(fold in 1:nfold){
        
            coeffs = getFeatureImportance(resObj[[rep]][[fold]][[paste0("model_", moa)]])$res
            coeffs = coeffs[which(coeffs !=0)]
            for(n in names(coeffs)){
                feat_cat[[n]] = unlist(c(feat_cat[[n]], coeffs[n]))
            }
        }
    }

    #eff contains how many times features appear in a model
    eff = sort(unlist(lapply(feat_cat, length)))
    feat_cat = feat_cat[names(eff)]

    # filter
    feat_cat = feat_cat[(eff/80) >= thres]
    eff = eff[(eff/80) >= thres]
    
    colMap = rainbow(length(unique(eff)))
    names(colMap) = unique(eff)
    
    par(mar = c(5,10,4,2))
    boxplot(feat_cat, horizontal = T, las = 2, lwd = 1.5, col = colMap[as.character(eff)], ...)
    legend("bottomright", legend = paste0(as.numeric(names(colMap))/80 * 100, " %"), 
           fill = colMap, title = "Present in % models", cex = 0.8)
    abline(v = 0)
    if(return_obj){
        return(feat_cat)
    }
}


xgb_10pc = readRDS("run_results_from_server/matrix_container_result/xgboost_hyp_param_std_all_top10pct_TRUE.rds")
lasso_10pc = readRDS("run_results_from_server/matrix_container_result/lasso_hyp_param_all_top10pct_TRUE.rds")

# Simple comparison
par(mfrow = c(1,2))
plot_cat_xgb_feat_importance(resObj = xgb_10pc, moa = "dna", thres = 0.7)
plot_cat_lasso_coeffs(resObj = lasso_10pc, moa = "dna", main= "Lasso 10pc dna", thres = 0.7)

```



# Model exploration of features importance

Overview of the analysis :

- For each MoA, take a "good" model, here, the one displaying the highest AUC for the MoA chosen.
- Display features importance distribution as well as in how many models they appear
- For the best features, have a look at the distribution of the s-score across MoA
- Also look at what happen if we try to clusterize drugs based on these features only : Heatmap function

## Heatmap function

```{r}
plot_heatmap <- function(m  , plotFile = F, name_size = 0.3 , names_order = NULL) {
    # plots a heatmap for all drugs with only the features provided in the feats_to_keep argument
    cluster_matrix <- m
    moa_to_colour <- c(cell_wall = "#FF0000FF",
                       dna = "#80FF00FF",
                       protein_synthesis = "#8000FFFF",
                       membrane_stress = "#00FFFFFF",
                       pmf = "#bababa", protein_qc = "#bababa", oxidative_stress = "#bababa"
    )
    
    process_lut <- cluster_matrix$process_broad

    rowcols <- moa_to_colour[process_lut]
    drugs_names = cluster_matrix$drugname_typaslab
    if(!is.null(names_order)){
        row_ord = unlist(lapply(names_order, function(x){which(cluster_matrix$drugname_typaslab== x)}))
    }else{
        row_ord = TRUE
    }
    
    cluster_matrix$drugname_typaslab <- NULL
   
    cluster_matrix$process_broad <- NULL
    cluster_matrix <- as.matrix(cluster_matrix)

    if(plotFile){ pdf("./plots/heatmap.pdf", width = 20, height = 20) }
    
    heatmap.2(cluster_matrix,
              scale = "column",
              trace = "none",
              Rowv = row_ord, 
              breaks = c(seq(-5,5,length=20)), # use this i/o zlim
              RowSideColors = rowcols,
              cexRow = name_size,
              labRow = drugs_names,
              col = colorRampPalette(c("red", "white", "blue")),
              margins = c(12, 9),
              dendrogram = "row") # only draw row dendrogram
    legend("top",
           legend = names(moa_to_colour),
           col = moa_to_colour,
           lty = 1,
           lwd = 10)
    
    if(plotFile){ dev.off() }
}

```

For keeping the same color code for MoA

```{r}
colMap = rainbow(4)
names(colMap) = c("cell_wall", "dna", "membrane_stress", "protein_synthesis")
```


## CELL WALL 

```{r}
lasso_30pc_all = readRDS("run_results_from_server/matrix_container_result/lasso_hyp_param_all_top30pct_FALSE.rds")

model_analysis(res_obj = lasso_30pc_all, matrix_container_line = matrix_container[155, ], matrix_container_line_noChemFeat = matrix_container[156, ], moa = "cell_wall", pdf_filename = "model_explanation_cell_wall.pdf", model_type = "lasso")
```

```{r}
# Best model based on AUC : line 155
lasso_30pc_all = readRDS("run_results_from_server/matrix_container_result/lasso_hyp_param_all_top30pct_FALSE.rds")

pdf(file = "model_explanation_cell_wall.pdf", width = 14, height = 14 )
mat = matrix_container[2, ]$drug_feature_matrices[[1]]

par(mfrow= c(1,1))
plot_ROC_allRep(lasso_30pc_all, moa = "cell_wall", plotAllRep = T)

par(mfrow= c(2,2))
plot_cat_lasso_coeffs(resObj = lasso_30pc_all, moa = "cell_wall", main= "lasso_30pc_all", thres = 0.7)
stripchart(MIOC ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)
stripchart(YDAN ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)
stripchart(ISO ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)

par(mfrow= c(2,2))
plot_cat_lasso_coeffs(resObj = lasso_30pc_all, moa = "cell_wall", main= "lasso_30pc_all", thres = 0.7)
stripchart(ASMA ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)
stripchart(RFAC ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)
stripchart(SLT ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)

par(mfrow= c(1,1))
plot(SLT ~ ASMA, data = mat, pch = 21, bg = colMap[process_broad], cex = 1.5, las = 2)
plot(RFAC ~ MIOC, data = mat, pch = 21, bg = colMap[process_broad], cex = 1.5, las = 2)

a = plot_cat_lasso_coeffs(resObj = lasso_30pc_all, moa = "cell_wall", main= "lasso_30pc_all", thres = 0.6, return_obj = T)
# Load matrix correpsonding to the model : with All dosage
mat = matrix_container[2, ]$drug_feature_matrices[[1]]
mat = mat %>% select(drugname_typaslab, process_broad, names(a))
plot_heatmap(m = mat)

#Same heatmap order by probabilities of prediction
names_order = drugs_pred_prob_from_container(pred_data = matrix_container[155, ]$PredData[[1]], moa="cell_wall" )
mat = matrix_container[2, ]$drug_feature_matrices[[1]]
mat = mat %>% select(drugname_typaslab, process_broad, names(a))
plot_heatmap(m = mat,  names_order = names_order)

dev.off()
```

We can see on the Heatmap that a robust and pure cluster of cell wall drug is "driven" by SLT and MRCB


## PROTEIN SYNTHESIS

```{r}
lasso_5pc_most = readRDS("run_results_from_server/matrix_container_result/lasso_hyp_param_most_interactions_top5pct_TRUE.rds")

model_analysis(res_obj = lasso_5pc_most, matrix_container_line = matrix_container[180, ], matrix_container_line_noChemFeat = matrix_container[179, ] , moa = "protein_synthesis", pdf_filename = "model_explanation_protein_synthesis.pdf", model_type = "lasso")
```


```{r}
# Best model based on AUC : line 180
lasso_5pc_most = readRDS("run_results_from_server/matrix_container_result/lasso_hyp_param_most_interactions_top5pct_TRUE.rds")

pdf(file = "model_explanation_prot_synthesis.pdf", width = 14, height = 14 )
mat = matrix_container[20, ]$drug_feature_matrices[[1]]

par(mfrow= c(1,1))
plot_ROC_allRep(lasso_5pc_most, moa = "protein_synthesis", plotAllRep = T)
par(mfrow= c(2,2))
plot_cat_lasso_coeffs(resObj = lasso_5pc_most, moa = "protein_synthesis", main= "lasso_5pc_most", thres = 0.5)
stripchart(TOLB ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)
stripchart(SPR~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)
plot(SPR ~ TOLB, data = mat, pch = 21, bg = colMap[process_broad], cex = 1.2, las = 2)

par(mfrow= c(2,2))
plot_cat_lasso_coeffs(resObj = lasso_5pc_most, moa = "protein_synthesis", main= "lasso_5pc_most", thres = 0.5)
stripchart(VISC ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)
stripchart(ASMA ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)
stripchart(ACRA ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)

par(mfrow= c(1,1))
plot(SlogP ~ TOLB, data = mat, pch = 21, bg = colMap[process_broad], cex = 1.5, las = 2)
plot(SlogP ~ SPR, data = mat, pch = 21, bg = colMap[process_broad], cex = 1.5, las = 2)

a = plot_cat_lasso_coeffs(resObj = lasso_5pc_most, moa = "protein_synthesis", main= "lasso_5pc_most", thres = 0.6, return_obj = T)
# Load matrix correpsonding to the model : dosage with most interaction
mat = matrix_container[20, ]$drug_feature_matrices[[1]]
mat = mat %>% select(drugname_typaslab, process_broad, names(a))
plot_heatmap(m = mat, name_size = 1)

#Same heatmap order by probabilities of prediction
names_order = drugs_pred_prob_from_container(pred_data = matrix_container[180, ]$PredData[[1]], moa="protein_synthesis" )
mat = matrix_container[20, ]$drug_feature_matrices[[1]]
mat = mat %>% select(drugname_typaslab, process_broad, names(a))
plot_heatmap(m = mat, name_size = 1, names_order = names_order)

dev.off()
```

Here it is not really clear which features are driving the clusterization

Potentialy ASMA and GLMS, maybe RFAE and ACRA

The result also depends on the threshold used (% of models with a given feature)


## MEMBRANE STRESS

```{r}
lasso_25pc_all = readRDS("run_results_from_server/matrix_container_result/lasso_hyp_param_all_top25pct_TRUE.rds")

model_analysis(res_obj = lasso_25pc_all, matrix_container_line = matrix_container[154, ], matrix_container_line_noChemFeat = matrix_container[153, ],  moa = "membrane_stress", pdf_filename = "model_explanation_membrane_stress.pdf", model_type = "lasso")
```


```{r}
# Best model based on AUC : line 154
lasso_25pc_all = readRDS("run_results_from_server/matrix_container_result/lasso_hyp_param_all_top25pct_TRUE.rds")

pdf(file = "model_explanation_membrane_stress.pdf", width = 14, height = 14 )
mat = matrix_container[154, ]$drug_feature_matrices[[1]]

par(mfrow= c(1,1))
plot_ROC_allRep(lasso_25pc_all, moa = "membrane_stress", plotAllRep = T)
par(mfrow= c(2,2))
plot_cat_lasso_coeffs(resObj = lasso_25pc_all, moa = "membrane_stress", main= "lasso_25pc_all", thres = 0.6)
stripchart(YBIM ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)
stripchart(MALK~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)
stripchart(YFIO~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)

par(mfrow= c(2,2))
plot_cat_lasso_coeffs(resObj = lasso_25pc_all, moa = "membrane_stress", main= "lasso_25pc_all", thres = 0.6)
stripchart(MALS ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)
stripchart(ISCR ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)
stripchart(ACEF ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)

par(mfrow= c(1,1))
plot(SlogP ~ YBIM, data = mat, pch = 21, bg = colMap[process_broad], cex = 1.5, las = 2)
plot(MALK ~ YFIO, data = mat, pch = 21, bg = colMap[process_broad], cex = 1.5, las = 2)

a = plot_cat_lasso_coeffs(resObj = lasso_25pc_all, moa = "membrane_stress", main= "lasso_25pc_all", thres = 0.3, return_obj = T)
# Load matrix correpsonding to the model : with All dosage
mat = matrix_container[2, ]$drug_feature_matrices[[1]]
mat = mat %>% select(drugname_typaslab, process_broad, names(a))
plot_heatmap(m = mat)

drugs_pred_prob_from_container(pred_data = matrix_container[172, ]$PredData[[1]], moa="membrane_stress" )

#Same heatmap order by probabilities of prediction
names_order = drugs_pred_prob_from_container(pred_data = matrix_container[172, ]$PredData[[1]], moa="membrane_stress" )
mat = matrix_container[2, ]$drug_feature_matrices[[1]]
mat = mat %>% select(drugname_typaslab, process_broad, names(a))
plot_heatmap(m = mat, names_order = names_order)


dev.off()
```

Clusters of membrane stress drugs seem driven by SURA, PAL, RFAF but also maybe HFQ, SlogP


## DNA

```{r}
lasso_10pc_most = readRDS("run_results_from_server/matrix_container_result/lasso_hyp_param_most_interactions_top10pct_FALSE.rds")

model_analysis(res_obj = lasso_10pc_most, matrix_container_line = matrix_container[165, ], matrix_container_line_noChemFeat = matrix_container[166, ], moa = "dna", pdf_filename = "model_explanation_dna.pdf", model_type = "lasso")
```


```{r}
# Best model based on AUC : line 165
lasso_10pc_most = readRDS("run_results_from_server/matrix_container_result/lasso_hyp_param_most_interactions_top10pct_FALSE.rds")

pdf(file = "model_explanation_dna.pdf", width = 14, height = 14 )
mat = matrix_container[20, ]$drug_feature_matrices[[1]]

par(mfrow= c(1,1))
plot_ROC_allRep(lasso_10pc_most, moa = "dna", plotAllRep = T)
par(mfrow= c(2,2))
plot_cat_lasso_coeffs(resObj = lasso_10pc_most, moa = "dna", main= "lasso_10pc_most", thres = 0.6)
stripchart(RECC ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)
stripchart(RECA ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)
stripchart(NAGA ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)

par(mfrow= c(2,2))
plot_cat_lasso_coeffs(resObj = lasso_10pc_most, moa = "dna", main= "lasso_10pc_most", thres = 0.6)
stripchart(TOLQ ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)
stripchart(YCHJ ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)
stripchart(PROQ ~ process_broad, data = mat, pch = 21, bg = "orange", cex = 1.2, las = 2)

par(mfrow= c(1,1))
plot(RECC ~ NAGA, data = mat, pch = 21, bg = colMap[process_broad], cex = 1.5, las = 2)
plot(RECA ~ TOLQ, data = mat, pch = 21, bg = colMap[process_broad], cex = 1.5, las = 2)

a = plot_cat_lasso_coeffs(resObj = lasso_10pc_most, moa = "dna", main= "lasso_10pc_most", thres = 0.6, return_obj = T)
# Load matrix correpsonding to the model : with All dosage
mat = matrix_container[20, ]$drug_feature_matrices[[1]]
mat = mat %>% select(drugname_typaslab, process_broad, names(a))
plot_heatmap(m = mat, name_size = 1)

#Same heatmap order by probabilities of prediction
names_order = drugs_pred_prob_from_container(pred_data = matrix_container[165, ]$PredData[[1]], moa="dna" )
plot_heatmap(m = mat, name_size = 1, names_order = names_order)

dev.off()
```

DNA drugs cluster easily with RECC and RECA values

Somehow NAGA, YCHJ, TOLQ, GUAB, CYSB, NUDB drive small cluster of dna drugs (subclasses ?) or help seperating it from other MoA


# Run of model analysis using best RF models


```{r}

# Line 18 corresp 17
bestRF_dna = readRDS("run_results_from_server/matrix_container_result/rf_hyp_param_all_top5pct_TRUE.rds")
#Line 24 corresp 23
bestRF_cell_wall = readRDS("run_results_from_server/matrix_container_result/rf_hyp_param_most_interactions_top15pct_TRUE.rds")
#Line 6 corresp 5
bestRF_membrane_stress = readRDS("run_results_from_server/matrix_container_result/rf_hyp_param_all_top15pct_TRUE.rds")
#Line 10 corresp 9
bestRF_protein_synthesis = readRDS("run_results_from_server/matrix_container_result/rf_hyp_param_all_top25pct_TRUE.rds")


model_analysis(res_obj = bestRF_dna, matrix_container_line = matrix_container[18, ], matrix_container_line_noChemFeat = matrix_container[17, ], moa = "dna", pdf_filename = "model_explanation_RF_dna.pdf", model_type = "tree", feat_imp_thres = 0.9, topFeatThres = 0.95)
model_analysis(res_obj = bestRF_cell_wall, matrix_container_line = matrix_container[24, ], matrix_container_line_noChemFeat = matrix_container[23, ], moa = "cell_wall", pdf_filename = "model_explanation_RF_cell_wall.pdf", model_type = "tree", feat_imp_thres = 0.9, topFeatThres = 0.95)
model_analysis(res_obj = bestRF_membrane_stress, matrix_container_line = matrix_container[6, ], matrix_container_line_noChemFeat = matrix_container[5, ], moa = "membrane_stress", pdf_filename = "model_explanation_RF_membrane_stress.pdf", model_type = "tree", feat_imp_thres = 0.99, topFeatThres = 1)
model_analysis(res_obj = bestRF_protein_synthesis, matrix_container_line = matrix_container[10, ], matrix_container_line_noChemFeat = matrix_container[9, ], moa = "protein_synthesis", pdf_filename = "model_explanation_RF_protein_synthesis.pdf", model_type = "tree", feat_imp_thres = 0.95, topFeatThres = 1)
```

Random Forest is really worse in feature selection and even if one select only features found in all the models, it still is too much. Threshold are quite high here, but otherwise pdf file are too big


# FOCUS on best features driving the MoA

Quick look : does it make sense to use only features mentioned above ?

In each MoA there are two or three features that allow a very nice isolation of at least half of the MoA drugs

Try to clusterize using these only for all dosage and most interaction

```{r}
best_feat = c("MRCB", "SLT","TOLB","SPR","SURA","PAL","RFAF","RECC","RECA","YLCG", "SlogP", "NumAromaticRings")
best_feat_extended = c("SLT", "MRCB", "TOLB", "SPR", "SlogP", "ACRB", "GLMS", "ASMA", "RFAE", "SURA", "PAL", "RFAF", "IMP", "NAGA", "RECC", "RECA", "YCHJ", "TOLQ", "GUAB", "CYSB", "NUDB")

mat = matrix_container[2, ]$drug_feature_matrices[[1]]
mat = mat %>% select(drugname_typaslab, process_broad, best_feat)
plot_heatmap(m = mat)

# DO PCA
mat = matrix_container[2, ]$drug_feature_matrices[[1]]
m = mat %>% select(best_feat)
pca_data <- prcomp(m, scale = TRUE)

barplot(pca_data$sdev / sum(pca_data$sdev))
var_3pca = sum((pca_data$sdev / sum(pca_data$sdev))[1:3])

plotData <- as.data.frame(pca_data$x)
plotData = cbind(plotData, process_broad = mat$process_broad, drugnames = mat$drugname_typaslab)

plotData$process_broad = as.character(plotData$process_broad)
plotData$process_broad[!(plotData$process_broad %in% c("cell_wall", "dna", "membrane_stress", "protein_synthesis"))] <- "other"

p1 <- ggplot(plotData, aes(x = PC1, y = PC2)) +
geom_point(aes(fill = process_broad), shape = 21, size = 4, colour = "black") +
theme_bw() + scale_fill_manual(values=rainbow(4)) +
ggtitle(" PC 1 and 2")

p2 <- ggplot(plotData, aes(x = PC3, y = PC2)) +
geom_point(aes(fill = process_broad), shape = 21, size = 4, colour = "black") +
theme_bw() + scale_fill_manual(values=rainbow(4)) +
ggtitle(" PC 2 and 3 ")

p3 <- ggplot(plotData, aes(x = PC3, y = PC4)) +
geom_point(aes(fill = process_broad), shape = 21, size = 4, colour = "black") +
theme_bw() + scale_fill_manual(values=rainbow(4)) +
ggtitle(" PC 3 and 4 ")

p4 <- ggplot(plotData, aes(x = PC5, y = PC4)) +
geom_point(aes(fill = process_broad), shape = 21, size = 4, colour = "black") +
theme_bw() + scale_fill_manual(values=rainbow(4)) +
ggtitle(" PC 4 and 5 ")

grid.arrange(p1, p2, p4, p3, nrow = 2)


p <- plot_ly(plotData, x = ~PC1, y = ~PC2, z = ~PC3, color = ~process_broad, colors = c("#FF0000FF", "#80FF00FF", "#00FFFFFF", "black" , "#8000FFFF") ) %>%
  add_markers(text = ~drugnames) %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                     yaxis = list(title = 'PC2'),
                     zaxis = list(title = 'PC3')))

```


## MultiDimensional Scaling

Since PCA try to represent variability across individuals, it may not be the perfect tool if one want to seperate groups

Try MDS to see if there's some difference. MDS is based on the distance between individual and the algorithm try to keep the same distances when going from a N-dim space to a n-dim space (N > n)

```{r}
best_feat = c("MRCB", "SLT","TOLB","SPR","SURA","PAL","RFAF","RECC","RECA","YLCG", "SlogP")
mat = matrix_container[20, ]$drug_feature_matrices[[1]]
labels_save = mat %>% select(drugname_typaslab, process_broad)
mat = mat %>% select(best_feat)

dist_mat = dist(mat, method = "euclidian")
mat_MDS_res = cmdscale(dist_mat, k = 3)
mat_MDS_res = cbind(mat_MDS_res, labels_save)
colnames(mat_MDS_res)[1:3] = c("MDS1", "MDS2", "MDS3")

p <- plot_ly(mat_MDS_res, x = ~MDS1, y = ~MDS2, z = ~MDS3, color = ~process_broad, colors = c("#FF0000FF", "#80FF00FF", "#00FFFFFF","grey", "grey", "grey", "#8000FFFF") ) %>%
    add_markers() %>%
    layout(scene = list(xaxis = list(title = 'MDS axis 1'),
                     yaxis = list(title = 'MDS axis 2'),
                     zaxis = list(title = 'MDS axis 3')))


```


## Kmeans or KNN based on a subspace of features

Compare results of KNN in the all-feature space and limited best features space : For which MoA does it make a difference. Since we're using LOO CV, it's also easy to assesss which drugs are misclassified

```{r}
best_feat = c("MRCB", "SLT","ASMA", "GLMS","RFAE", "ACRA" ,"SURA", "PAL", "RFAF", "HFQ", "SlogP", "RECC", "RECA") 
best_feat_extended = c("SLT", "MRCB", "TOLB", "SPR", "SlogP", "ACRB", "GLMS", "ASMA", "RFAE", "SURA", "PAL", "RFAF", "IMP", "NAGA", "RECC", "RECA", "YCHJ", "TOLQ", "GUAB", "CYSB", "NUDB")


run_KNN = function(feat_subset = NULL, knn_k = 1){
    
    models_knn = list()
    for (moa in c("cell_wall", "dna", "membrane_stress", "protein_synthesis")){

        input_data = matrix_container[20, ]$drug_feature_matrices[[1]]
        input_data = input_data %>% mutate(process_broad = replace(process_broad, process_broad != moa, paste0("not_", moa)))
            
        if("drugname_typaslab" %in% colnames(input_data)){
                input_data = select(input_data, -drugname_typaslab)
            }
        if("conc" %in% colnames(input_data)){
            input_data = select(input_data, -conc)
        }
        
        if(!is.null(feat_subset)){
            if(feat_subset == "random"){
                input_data = input_data %>% select(process_broad, sample(colnames(input_data)[-1], size = length(best_feat), replace = F))
            }else{
                input_data = input_data %>% select(process_broad, feat_subset)
            }
        }
        predictMoa = makeClassifTask(data = input_data, target = "process_broad")
            
        lrn = makeLearner("classif.knn", par.vals = list(k = knn_k)) 
        model = resample(learner = lrn,task =  predictMoa, resampling = makeResampleDesc(method = "LOO", predict = "both"))
        models_knn[[moa]] = model
    }
    return(models_knn)
}

knn_res = list()

for(feat in list(NULL, best_feat_extended, best_feat, "random")){
    for(nb_knn in c(1,2,3,4,5)){
        print(length(knn_res))
        name =  as.character(length(knn_res))
        knn_res[[name]] <- run_KNN(feat_subset = feat, knn_k = nb_knn)
    }
}


a = unlist(knn_res, recursive = F)
a = lapply(a, function(x){x$aggr})

a = as.data.frame(unlist(a))
colnames(a) = "mmce"
a$moa = rep(c("cell_wall", "dna", "membrane_stress", "protein_synthesis"), times = 20)
a$knn = rep(seq(1,5), each = 4)
a$model = rep(c("all_feat_knn_", "best_feat_knn_", "best_feat_ext_knn_", "random"), each = 20)

p1 = ggplot(data = a[1:20, ]) + geom_line(mapping = aes(x = knn, y = mmce, color = moa), lwd = 1.5) + theme_bw() + scale_color_manual(values = rainbow(4)) + ggtitle("All feat") + theme(legend.position="bottom")+ ylim(0,0.4)
p2 = ggplot(data = a[21:40, ]) + geom_line(mapping = aes(x = knn, y = mmce, color = moa), lwd = 1.5) + theme_bw() + scale_color_manual(values = rainbow(4)) + ggtitle("Best feat ext") + theme(legend.position="bottom")+ ylim(0,0.4)
p3 = ggplot(data = a[41:60, ]) + geom_line(mapping = aes(x = knn, y = mmce, color = moa), lwd = 1.5) + theme_bw() + scale_color_manual(values = rainbow(4)) + ggtitle("Best feat") + theme(legend.position="bottom") + ylim(0,0.4)
p4 = ggplot(data = a[61:80, ]) + geom_line(mapping = aes(x = knn, y = mmce, color = moa), lwd = 1.5) + theme_bw() + scale_color_manual(values = rainbow(4)) + ggtitle("Random feat") + theme(legend.position="bottom") + ylim(0,0.4)

grid.arrange(p1, p2, p3,p4, nrow = 1)

```




# Features selection based on T test pvalue


```{r}

mat = matrix_container[1, ]$drug_feature_matrices[[1]]
mat = mat %>% select( -conc,  -drugname_typaslab)
allRes = c()

matTmp = as.data.frame(mat)

for( moa in c("cell_wall", "dna", "membrane_stress", "protein_synthesis")){
    res = list()
    
    for (i in colnames(matTmp)) {
        if(i != "process_broad"){
            res[[i]] = wilcox.test(matTmp[matTmp$process_broad == moa, i], matTmp[matTmp$process_broad != moa, i])$p.value
        }
    }
    res = sort(unlist(res))
    allRes = c(allRes, names(res[1:5]))
}

```



# Model surgery

Two best models for DNA in terms of AUC, almost equal but input data really different

```{r}
# line 26
rf_model1 = readRDS("run_results_from_server/matrix_container_result/rf_hyp_param_most_interactions_top20pct_TRUE.rds")

drugs_pred_prob_from_container(pred_data = matrix_container[26, ]$PredData[[1]], moa="dna" )


# line 18
rf_model2 = readRDS("run_results_from_server/matrix_container_result/rf_hyp_param_all_top5pct_TRUE.rds")

drugs_pred_prob_from_container(pred_data = matrix_container[18, ]$PredData[[1]], moa="dna" )
```

Actually line 26 is better after looking at the plots



Test with one tree. You never know...

```{r}
library(rpart)
library(rpart.plot)


misclass_drugs = list()

for (moa in c("cell_wall", "dna", "membrane_stress", "protein_synthesis")){
    input_data = matrix_container[19, ]$drug_feature_matrices[[1]]
    input_data = input_data %>% mutate(process_broad = replace(process_broad, process_broad != moa, paste0("not_", moa)))
    
    if("drugname_typaslab" %in% colnames(input_data)){
            input_data = select(input_data, -drugname_typaslab)
        }
    if("conc" %in% colnames(input_data)){
        input_data = select(input_data, -conc)
    }
    
    predictMoa = makeClassifTask(data = input_data, target = "process_broad")
    
    lrn = makeLearner("classif.rpart", par.vals = list(minsplit = 3)) 
    model = resample(learner = lrn,task =  predictMoa, resampling = makeResampleDesc(method = "LOO", predict = "both"))
    
    # With LOO classification, see which drugs don't fit in a given tree
    tough_drugs = which(model$measures.test$mmce == 1)
    input_data = matrix_container[26, ]$drug_feature_matrices[[1]]
    misclass_drugs[[moa]] = input_data$drugname_typaslab[tough_drugs]
}


# Multiclass

input_data = matrix_container[19, ]$drug_feature_matrices[[1]]
input_data = input_data %>% mutate(process_broad = replace(process_broad, !(process_broad %in% c("cell_wall", "dna", "membrane_stress", "protein_synthesis")), "other"))


if("drugname_typaslab" %in% colnames(input_data)){
    input_data = select(input_data, -drugname_typaslab)
}
if("conc" %in% colnames(input_data)){
    input_data = select(input_data, -conc)
}

predictMoa = makeClassifTask(data = input_data, target = "process_broad")

lrn = makeLearner("classif.rpart", par.vals = list(minsplit = 10)) 
model = resample(learner = lrn,task =  predictMoa, resampling = makeResampleDesc(method = "CV", predict = "both", iters = 10))


rpart.plot::rpart.plot(model$learner.model, extra = 1)
summary(model$learner.model)

# with minsplit it overfits, find a way to label individuals in each leaf

```


Plot Boosting tree : always the same gene during ~50 trees, which correpsonds to the time needed for the weight put on the misclassified individuals to be big enough to change the way the preditcion is done

```{r}
# line 40
xgb_10pc = readRDS("run_results_from_server/matrix_container_result/xgboost_hyp_param_std_all_top10pct_TRUE.rds")

input_data = matrix_container[40, ]$drug_feature_matrices[[1]]
if("drugname_typaslab" %in% colnames(input_data)){
        input_data = select(input_data, -drugname_typaslab)
    }
if("conc" %in% colnames(input_data)){
    input_data = select(input_data, -conc)
}

ipak("DiagrammeR")
a = xgb_10pc$`Nested CV 1`$`Outer fold 1`$model_dna$learner.model

ipak("DiagrammeR")
library(xgboost)

xgb.plot.tree(model = a, trees = 1:10, feature_names = colnames(input_data)[-1])
xgb.plot.tree(model = a, trees = 10:20, feature_names = colnames(input_data)[-1])


```



