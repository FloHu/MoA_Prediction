---
title: "Inspecting models"
author: "Florian Huber, Leonard Dubois"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_caption: yes
    fig_height: 6
    fig_width: 6
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
editor_options: 
  chunk_output_type: console
---

# Setup, library loading

This part is the general setup, whichever model we are using.

```{r setup}
# function to check if a package is installed, if so, load it, else install and then load it
source("./R/ipak.R")
# set chunk options and load libraries
source("./setup.R")
# custom functions
walk(list.files("./R", pattern = "*.R", full.names = T), source)

#matrix_container = readRDS("/Volumes/typas/Florian/MoA_prediction_data/matrix_container_withextractions.rds")
matrix_container_new = readRDS("data/matrix_container_new_withextractions.rds")

ipak(plotmo)
ipak(reshape2)
ipak(gplots)
ipak("gridExtra")
ipak("plotly")
library(ComplexHeatmap)
ipak("circlize")
```


Aim of this notebook is to have a deeper look at all the different results from the matrix container and understand which features are used, for what, which of them help us defining groups based on MoA.

For keeping the same color code for MoA

```{r}
colMap = rainbow(4)
names(colMap) = c("cell_wall", "dna", "membrane_stress", "protein_synthesis")
```


# Lasso model regularization paths

First, we have a look at the regularization path of a LASSO model, which is the evolution of the coefficient for one feature depending on the value of the regularization parameter lambda. Regularization path are contained in a matrix in lasso model objects build with glmnet.

Main problem here is that it exist 80 slightly different regularization path in one run : one for each outer fold times the number of repetitions

It would be great to find a way to average all of this...

```{r}
# Result object to test
resObj = readRDS("run_results_from_server/matrix_container_result/lasso_hyp_param_all_top5pct_TRUE.rds")

#   par(mfrow = c(4,2))
#   for(i in 1:8){plot_glmnet(resObj$`Nested CV 1`[[paste0("Outer fold ", i)]]$model_dna$learner.model)}


# For a given model, example with NCV 1, Outer fold 1 DNA MoA
modelInstance = resObj$`Nested CV 1`$`Outer fold 1`$model_dna

# I write my own function for the plot_glmnet one form the plotmo package is not that great.

plot_reg_path = function(modelInstance){
    lambda_for_pred = modelInstance$learner$par.vals$s
    # Get the index of the lambda used in model building which is the closest to s, the lambda used for testing
    closest_lambda_index = which.min(abs(lambda_for_pred - modelInstance$learner.model$lambda))
    
    coeffs = as.matrix(modelInstance$learner.model$beta[, 1:closest_lambda_index])
    coeffs = coeffs[ rowSums(coeffs)!=0, ] 
    coeffs = as.data.frame(coeffs)
    colnames(coeffs) = seq(1:ncol(coeffs))
    coeffs$feat = rownames(coeffs)
    
    coeffs_plotable = melt(coeffs, id.vars = "feat")
    coeffs_plotable$variable = as.numeric(coeffs_plotable$variable)
    ggplot() + geom_path(data = coeffs_plotable, mapping = aes(x = variable, y = value, group = feat)) +
            geom_hline(yintercept = 0, linetype="dashed") +
            annotate("text", x = ncol(coeffs), y = coeffs[, ncol(coeffs)-1], label = coeffs$feat) +
            theme_bw() + xlim(0,ncol(coeffs)+5)
}

dna11 = plot_reg_path(resObj$`Nested CV 1`$`Outer fold 1`$model_dna)
dna12 = plot_reg_path(resObj$`Nested CV 1`$`Outer fold 2`$model_dna)
dna13 = plot_reg_path(resObj$`Nested CV 1`$`Outer fold 3`$model_dna)
dna14 = plot_reg_path(resObj$`Nested CV 1`$`Outer fold 4`$model_dna)

grid.arrange(dna11, dna12, dna13, dna14, nrow = 2)

```




# Model exploration of features importance

Overview of the analysis :

- For each MoA, take a "good" model, here, the one displaying the highest AUC for the MoA chosen.
- Display features importance distribution as well as in how many models they appear
- For the best features, have a look at the distribution of the s-score across MoA
- Also look at what happen if we try to clusterize drugs based on these features only : Heatmap function


## CELL WALL 

```{r}
lasso_30pc_all = readRDS("run_results_from_server/matrix_container_result/lasso_hyp_param_all_top30pct_FALSE.rds")

model_analysis(res_obj = lasso_30pc_all, matrix_container_line = matrix_container[155, ], matrix_container_line_noChemFeat = matrix_container[156, ], moa = "cell_wall", pdf_filename = "model_explanation_cell_wall.pdf", model_type = "lasso")
```

We can see on the Heatmap that a robust and pure cluster of cell wall drug is "driven" by SLT and MRCB


## PROTEIN SYNTHESIS

```{r}
lasso_5pc_most = readRDS("run_results_from_server/matrix_container_result/lasso_hyp_param_most_interactions_top5pct_TRUE.rds")

model_analysis(res_obj = lasso_5pc_most, matrix_container_line = matrix_container[180, ], matrix_container_line_noChemFeat = matrix_container[179, ] , moa = "protein_synthesis", pdf_filename = "model_explanation_protein_synthesis.pdf", model_type = "lasso")
```


Here it is not really clear which features are driving the clusterization

Potentialy ASMA and GLMS, maybe RFAE and ACRA

The result also depends on the threshold used (% of models with a given feature)


## MEMBRANE STRESS

```{r}
lasso_25pc_all = readRDS("run_results_from_server/matrix_container_result/lasso_hyp_param_all_top25pct_TRUE.rds")

model_analysis(res_obj = lasso_25pc_all, matrix_container_line = matrix_container[154, ], matrix_container_line_noChemFeat = matrix_container[153, ],  moa = "membrane_stress", pdf_filename = "model_explanation_membrane_stress.pdf", model_type = "lasso")
```

Clusters of membrane stress drugs seem driven by SURA, PAL, RFAF but also maybe HFQ, SlogP


## DNA

```{r}
lasso_10pc_most = readRDS("run_results_from_server/matrix_container_result/lasso_hyp_param_most_interactions_top10pct_FALSE.rds")

model_analysis(res_obj = lasso_10pc_most, matrix_container_line = matrix_container[165, ], matrix_container_line_noChemFeat = matrix_container[166, ], moa = "dna", pdf_filename = "model_explanation_dna.pdf", model_type = "lasso")
```


DNA drugs cluster easily with RECC and RECA values

Somehow NAGA, YCHJ, TOLQ, GUAB, CYSB, NUDB drive small cluster of dna drugs (subclasses ?) or help seperating it from other MoA


# Run of model analysis using best RF models


```{r}

# Line 18 corresp 17
bestRF_dna = readRDS("run_results_from_server/matrix_container_result/rf_hyp_param_all_top5pct_TRUE.rds")
#Line 24 corresp 23
bestRF_cell_wall = readRDS("run_results_from_server/matrix_container_result/rf_hyp_param_most_interactions_top15pct_TRUE.rds")
#Line 6 corresp 5
bestRF_membrane_stress = readRDS("run_results_from_server/matrix_container_result/rf_hyp_param_all_top15pct_TRUE.rds")
#Line 10 corresp 9
bestRF_protein_synthesis = readRDS("run_results_from_server/matrix_container_result/rf_hyp_param_all_top25pct_TRUE.rds")


model_analysis(res_obj = bestRF_dna, matrix_container_line = matrix_container[18, ], matrix_container_line_noChemFeat = matrix_container[17, ], moa = "dna", pdf_filename = "model_explanation_RF_dna.pdf", model_type = "tree", feat_imp_thres = 0.9, topFeatThres = 0.95)
model_analysis(res_obj = bestRF_cell_wall, matrix_container_line = matrix_container[24, ], matrix_container_line_noChemFeat = matrix_container[23, ], moa = "cell_wall", pdf_filename = "model_explanation_RF_cell_wall.pdf", model_type = "tree", feat_imp_thres = 0.9, topFeatThres = 0.95)
model_analysis(res_obj = bestRF_membrane_stress, matrix_container_line = matrix_container[6, ], matrix_container_line_noChemFeat = matrix_container[5, ], moa = "membrane_stress", pdf_filename = "model_explanation_RF_membrane_stress.pdf", model_type = "tree", feat_imp_thres = 0.99, topFeatThres = 1)
model_analysis(res_obj = bestRF_protein_synthesis, matrix_container_line = matrix_container[10, ], matrix_container_line_noChemFeat = matrix_container[9, ], moa = "protein_synthesis", pdf_filename = "model_explanation_RF_protein_synthesis.pdf", model_type = "tree", feat_imp_thres = 0.95, topFeatThres = 1)
```

Random Forest is really worse in feature selection and even if one select only features found in all the models, it still is too much. Threshold are quite high here, but otherwise pdf file are too big


# Run of model analysis - New matrix container

## Total overview

```{r}

pdf(file= "new_matrix_container_results/matrix_container_new_allROC.pdf", height = 32, width = 17)
plot_ROC_from_container(containerObj = matrix_container_new, moa = "all", by = c("feat_preselect", "fitted_model"))
dev.off()

```

## Overview by Model type and MoA

```{r}

pdf(file = "new_matrix_container_results/EN_overview.pdf", width = 24, height = 17)
p1 = plot_ROC_from_container(containerObj = matrix_container_new %>% filter(fitted_model == "classif.glmnet"), moa = "dna")
p2 = plot_ROC_from_container(containerObj = matrix_container_new %>% filter(fitted_model == "classif.glmnet"), moa = "cell_wall")
p3 = plot_ROC_from_container(containerObj = matrix_container_new %>% filter(fitted_model == "classif.glmnet"), moa = "membrane_stress")
p4 = plot_ROC_from_container(containerObj = matrix_container_new %>% filter(fitted_model == "classif.glmnet"), moa = "protein_synthesis")
grid.arrange(p1, p2, p3, p4, nrow = 2)
dev.off()

pdf(file = "new_matrix_container_results/RF_overview.pdf", width = 24, height = 17)
p1 = plot_ROC_from_container(containerObj = matrix_container_new %>% filter(fitted_model == "classif.randomForest"), moa = "dna")
p2 = plot_ROC_from_container(containerObj = matrix_container_new %>% filter(fitted_model == "classif.randomForest"), moa = "cell_wall")
p3 = plot_ROC_from_container(containerObj = matrix_container_new %>% filter(fitted_model == "classif.randomForest"), moa = "membrane_stress")
p4 = plot_ROC_from_container(containerObj = matrix_container_new %>% filter(fitted_model == "classif.randomForest"), moa = "protein_synthesis")
grid.arrange(p1, p2, p3, p4, nrow = 2)
dev.off()

```

Analysis of these plots allows to decide which models should we focus on.
Since multiple model display similar perfromances, one should look for interpretability

## In depth analysis

The aim is to identify a group of gene in a model which is driving the clusterization. We can easily visualize it with the dendrogramm from the heatmap function. However, whether it is really obvious depends mainly on the threshold one choose : in how many models is a feature used ? (Most of the time it's between 90 and 100% )

```{r}

# Best model (highest AUC)

res_best_dna = readRDS(file = "run_results_from_server/matrix_container_result/most2_interactions_classif.randomForest_corr06_FALSE.rds")
model_analysis(res_obj = res_best_dna, matrix_container_line = matrix_container_new[1, ], matrix_container_line_noChemFeat = matrix_container_new[1, ], moa = "dna", pdf_filename = "new_matrix_container_results/best_dna_results.pdf", model_type = "tree", feat_imp_thres = 0.98, topFeatThres = 0.98)
rm(res_best_dna)

res_best = readRDS(file = "run_results_from_server/matrix_container_result/most2_interactions_classif.randomForest_all_FALSE.rds")
model_analysis(res_obj = res_best, matrix_container_line = matrix_container_new[1, ], matrix_container_line_noChemFeat = matrix_container_new[1, ], moa = "membrane_stress", pdf_filename = "new_matrix_container_results/best_membrane_stress_results.pdf", model_type = "tree", feat_imp_thres = 1, topFeatThres = 1)
rm(res_best)

res_best = readRDS(file = "run_results_from_server/matrix_container_result/most2_interactions_classif.glmnet_protCmplx_FALSE.rds")
model_analysis(res_obj = res_best, matrix_container_line = matrix_container_new[7, ], matrix_container_line_noChemFeat = matrix_container_new[7, ], moa = "protein_synthesis", pdf_filename = "new_matrix_container_results/best_protein_synthesis_results.pdf", model_type = "lasso", feat_imp_thres = 1, topFeatThres = 1)
rm(res_best)

res_best = readRDS(file = "run_results_from_server/matrix_container_result/most2_interactions_classif.glmnet_all_FALSE.rds")
model_analysis(res_obj = res_best, matrix_container_line = matrix_container_new[1, ], matrix_container_line_noChemFeat = matrix_container_new[1, ], moa = "cell_wall", pdf_filename = "new_matrix_container_results/best_cell_wall_results.pdf", model_type = "lasso", feat_imp_thres = 0.6, topFeatThres = 0.9)
rm(res_best)

```

Try to obtain a nice representation showing the group of features driving a pure cluster of the targeted MoA

## Screening Heatmap cutting schemes


```{r}
# DNA Model
cut_DNA = screening_heatmap_cuts(res_obj_file = "run_results_from_server/matrix_container_result/most2_interactions_classif.randomForest_corr06_FALSE.rds", 
                                  model_type = "tree", moa = "dna", mat_from_container = matrix_container_new[1, ]$drug_feature_matrices[[1]])

# Cell Wall
cut_WALL = screening_heatmap_cuts(res_obj_file = "run_results_from_server/matrix_container_result/most2_interactions_classif.glmnet_all_FALSE.rds", 
                                  model_type = "lasso", moa = "cell_wall", mat_from_container = matrix_container_new[1, ]$drug_feature_matrices[[1]])


#Protein Synthesis
cut_PROT = screening_heatmap_cuts(res_obj_file = "run_results_from_server/matrix_container_result/most2_interactions_classif.glmnet_protCmplx_FALSE.rds", 
                                  model_type = "lasso", moa = "protein_synthesis", mat_from_container = matrix_container_new[7, ]$drug_feature_matrices[[1]])


#Membrane Stress
cut_MEMBRANE = screening_heatmap_cuts(res_obj_file = "run_results_from_server/matrix_container_result/most2_interactions_classif.randomForest_all_FALSE.rds", 
                                  model_type = "tree", moa = "membrane_stress", mat_from_container = matrix_container_new[1, ]$drug_feature_matrices[[1]])

save(cut_DNA, cut_WALL, cut_PROT, cut_MEMBRANE, file = "data/HM_cut.RData")

```


```{r}
load(file = "data/HM_cut.RData")

chemogeno_fingerprint = c()
```


```{r}

# DNA
cut_DNA = na.omit(cut_DNA)
#cut_plan = cut_DNA[which(cut_DNA$distToOptPoint == min(cut_DNA$distToOptPoint)), ]
#Second one slightly better for it invlves far less features
cut_plan = arrange(cut_DNA %>% filter(recall >= 0.75 & ppv >= 0.75), nbGene)[1, ]
res_obj = readRDS(file = "run_results_from_server/matrix_container_result/most2_interactions_classif.randomForest_corr06_FALSE.rds")
featImp = plot_top_feat_importance(resObj = res_obj,
                                   moa = "dna", main= deparse(substitute(resObj)) , thres = 0.95, return_obj = T, model_type = "tree")  
rm(res_obj)

cluster_matrix = matrix_container_new[1, ]$drug_feature_matrices[[1]] %>% select(drugname_typaslab, process_broad, names(featImp))
cluster_matrix = as.data.frame(cluster_matrix)
rownames(cluster_matrix) = paste(cluster_matrix$drugname_typaslab, seq(1, nrow(cluster_matrix)), sep = "_")
        
annot = data.frame(MoA = cluster_matrix[ ,"process_broad"])
rownames(annot) = rownames(cluster_matrix)
        
cluster_matrix = cluster_matrix %>% select(-drugname_typaslab)

genes_grp = cutree(hclust(dist(t(cluster_matrix %>% select(-process_broad) ))), k = cut_plan$nGeneCut )

for (i in 1:cut_plan$nGeneCut){
    mats_subGene = cluster_matrix[, c(names(genes_grp[genes_grp == i]), "process_broad")]
    drugs_grp = cutree(hclust(dist(mats_subGene %>% select(-"process_broad"))), k = cut_plan$nDrugsCut)
    assign(x = paste0("h", as.character(i)),
           value = Heatmap(matrix = mats_subGene  %>% select(-"process_broad"), col = colorRamp2(c(-5, 0, 4), c("red", "white", "blue")),
                    gap = unit(10, "mm"), show_row_names = F, split = drugs_grp)
           )
}

ha_row = rowAnnotation(df = annot, col = list(MoA = colMap), width = unit(1, "cm"))

pdf(file = "plots/HMcut_dna.pdf", height = 15, width = 15)
h3 +h1 + h2 +h4+h5+h6+ ha_row
dev.off()

chemogeno_fingerprint = c(chemogeno_fingerprint, colnames(h3@matrix) )

```

```{r}
cut_PROT = na.omit(cut_PROT)
# cut_plan = cut_PROT[which(cut_PROT$distToOptPoint == min(cut_PROT$distToOptPoint)), ]
cut_plan = arrange(cut_PROT %>% filter(recall >= 0.75 & ppv >= 0.75), nbGene)[1, ]
res_obj = readRDS(file = "run_results_from_server/matrix_container_result/most2_interactions_classif.glmnet_protCmplx_FALSE.rds")
featImp = plot_top_feat_importance(resObj = res_obj,
                                   moa = "protein_synthesis", main= deparse(substitute(resObj)) , thres = 1, return_obj = T, model_type = "lasso")  
rm(res_obj)

cluster_matrix = matrix_container_new[7, ]$drug_feature_matrices[[1]] %>% select(drugname_typaslab, process_broad, names(featImp))
cluster_matrix = as.data.frame(cluster_matrix)
rownames(cluster_matrix) = paste0(cluster_matrix$process_broad, seq(1, nrow(cluster_matrix)))
        
annot = data.frame(MoA = cluster_matrix[ ,"process_broad"])
rownames(annot) = rownames(cluster_matrix)
        
cluster_matrix = cluster_matrix %>% select(-drugname_typaslab)

genes_grp = cutree(hclust(dist(t(cluster_matrix %>% select(-process_broad) ))), k = cut_plan$nGeneCut )

for (i in 1:cut_plan$nGeneCut){
    mats_subGene = cluster_matrix[, c(names(genes_grp[genes_grp == i]), "process_broad")]
    drugs_grp = cutree(hclust(dist(mats_subGene %>% select(-"process_broad"))), k = cut_plan$nDrugsCut)
    assign(x = paste0("h", as.character(i)),
           value = Heatmap(matrix = mats_subGene  %>% select(-"process_broad"), col = colorRamp2(c(-5, 0, 4), c("red", "white", "blue")),
                    gap = unit(10, "mm"), show_row_names = F, split = drugs_grp)
           )
}

ha_row = rowAnnotation(df = annot, col = list(MoA = colMap), width = unit(1, "cm"))

pdf(file = "plots/HMcut_protein_synthesis.pdf", height = 15, width = 15)
h2 + h1+h3 + ha_row
dev.off()

chemogeno_fingerprint = c(chemogeno_fingerprint, colnames(h2@matrix) )

```

```{r}
cut_MEMBRANE = na.omit(cut_MEMBRANE)
# cut_plan = cut_MEMBRANE[which(cut_MEMBRANE$distToOptPoint == min(cut_MEMBRANE$distToOptPoint)), ]
cut_plan = arrange(cut_MEMBRANE %>% filter(recall >= 0.7 & ppv >= 0.7), nbGene)[1, ]

res_obj = readRDS(file = "run_results_from_server/matrix_container_result/most2_interactions_classif.randomForest_all_FALSE.rds")
featImp = plot_top_feat_importance(resObj = res_obj,
                                   moa = "membrane_stress", main= deparse(substitute(resObj)) , thres = 0.8625, return_obj = T, model_type = "tree")  
rm(res_obj)

cluster_matrix = matrix_container_new[1, ]$drug_feature_matrices[[1]] %>% select(drugname_typaslab, process_broad, names(featImp))
cluster_matrix = as.data.frame(cluster_matrix)
rownames(cluster_matrix) = paste0(cluster_matrix$process_broad, seq(1, nrow(cluster_matrix)))
        
annot = data.frame(MoA = cluster_matrix[ ,"process_broad"])
rownames(annot) = rownames(cluster_matrix)
        
cluster_matrix = cluster_matrix %>% select(-drugname_typaslab)

genes_grp = cutree(hclust(dist(t(cluster_matrix %>% select(-process_broad) ))), k = cut_plan$nGeneCut )

for (i in 1:cut_plan$nGeneCut){
    mats_subGene = cluster_matrix[, c(names(genes_grp[genes_grp == i]), "process_broad")]
    drugs_grp = cutree(hclust(dist(mats_subGene %>% select(-"process_broad"))), k = cut_plan$nDrugsCut)
    assign(x = paste0("h", as.character(i)),
           value = Heatmap(matrix = mats_subGene  %>% select(-"process_broad"), col = colorRamp2(c(-5, 0, 4), c("red", "white", "blue")),
                    gap = unit(10, "mm"), show_row_names = F, split = drugs_grp)
           )
}

ha_row = rowAnnotation(df = annot, col = list(MoA = colMap), width = unit(1, "cm"))

pdf(file = "plots/HMcut_membrane_stress.pdf", height = 15, width = 15)
h1 + h2 +h3  + ha_row
dev.off()

chemogeno_fingerprint = c(chemogeno_fingerprint, colnames(h1@matrix) )
```

```{r}
cut_WALL = na.omit(cut_WALL)
cut_plan = cut_WALL[which(cut_WALL$distToOptPoint == min(cut_WALL$distToOptPoint)), ]
cut_plan = cut_plan[1, ]
res_obj = readRDS(file = "run_results_from_server/matrix_container_result/most2_interactions_classif.glmnet_all_FALSE.rds")
featImp = plot_top_feat_importance(resObj = res_obj,
                                   moa = "cell_wall", main= deparse(substitute(resObj)) , thres = 1, return_obj = T, model_type = "lasso")  
rm(res_obj)

cluster_matrix = matrix_container_new[1, ]$drug_feature_matrices[[1]] %>% select(drugname_typaslab, process_broad, names(featImp))
cluster_matrix = as.data.frame(cluster_matrix)
rownames(cluster_matrix) = paste0(cluster_matrix$process_broad, seq(1, nrow(cluster_matrix)))
        
annot = data.frame(MoA = cluster_matrix[ ,"process_broad"])
rownames(annot) = rownames(cluster_matrix)
        
cluster_matrix = cluster_matrix %>% select(-drugname_typaslab)

genes_grp = cutree(hclust(dist(t(cluster_matrix %>% select(-process_broad) ))), k = cut_plan$nGeneCut )

for (i in 1:cut_plan$nGeneCut){
    mats_subGene = cluster_matrix[, c(names(genes_grp[genes_grp == i]), "process_broad")]
    drugs_grp = cutree(hclust(dist(mats_subGene %>% select(-"process_broad"))), k = cut_plan$nDrugsCut)
    assign(x = paste0("h", as.character(i)),
           value = Heatmap(matrix = mats_subGene  %>% select(-"process_broad"), col = colorRamp2(c(-5, 0, 4), c("red", "white", "blue")),
                    gap = unit(10, "mm"), show_row_names = F, split = drugs_grp)
           )
}

ha_row = rowAnnotation(df = annot, col = list(MoA = colMap), width = unit(1, "cm"))

pdf(file = "plots/HMcut_cell_wall.pdf", height = 15, width = 15)
h1 + ha_row
dev.off()

chemogeno_fingerprint = c(chemogeno_fingerprint, colnames(h1@matrix) )
```




```{r}
# Based on intuitive extraction on cluster driving genes
chemogeno_fingerprint_old = c("MRCB", "SLT", "YEJE", "YBAB",
                        "RECG", "XERC", "YDFI", "MOTA", "TPX", "YGFA", "RECN", "HUPA",
                        "RYFC", "YAIU", "GLXK", "YGAZ_YGAH", "YHFW", "YGAT", "DSRB", "KSGA",
                        "RFAF", "YJHQ", "YRAP", "YJJG", "YDCH", "PLDB", "YBGC")

# Based on researchof a trade-off between recal, ppv and number of genes used
chemogeno_fingerprint = c('CSPD', 'YABI', 'YBHE', 'YIHF', 'YQAC', 'YJBG', 'YIGB', 'GLMU', 'MDTC', 'RNB', 'YFJO', 'NAGA', 'YCEF',
                          'GLPD', 'YCGF', 'FIMF', 'YBAD', 'YFHJ', 'FIMC', 'FADD', 'WZZE', 'YGEX', 'YJHX', 'YMDA', 'PYRI', 'ALLD',
                          'ULAE', 'YIBA', 'YJJY', 'HUPB', 'MALS', 'FLIO', 'ILVN', 'SPOT', 'DCRB', 'YFDM', 'YBED', 'PRPB',
                          'PHNN', 'CVPA', 'GLPT', 'YCEP', 'YFIO', 'SPEF', 'ISCR', 'KEFA', 'YIDH', 'MDTA', 'PLDB', 'YDCH', 
                          'YJJG', 'YRAP', 'YJHQ', 'SLT', 'MRCB', 'MIOC')

#if needed
#   chemogeno_fingerprint = chemogeno_fingerprint[-grep(chemogeno_fingerprint, pattern =  "^Y")]

# Need to build a new matrix containing data from gene AND complexes. This allows to extract simply everything we need
full_mat = bind_cols(x = matrix_container_new[1, ]$drug_feature_matrices[[1]],
                      y = matrix_container_new[7, ]$drug_feature_matrices[[1]]) 

chemGeno_mat = as.data.frame(full_mat %>% select(chemogeno_fingerprint, "process_broad"))
rownames(chemGeno_mat) = paste(chemGeno_mat$drugname_typaslab, seq(1, nrow(chemGeno_mat)), sep = "_")
annot = data.frame(MoA = chemGeno_mat[ ,"process_broad"])
rownames(annot) = rownames(chemGeno_mat)
      
Heatmap(matrix = chemGeno_mat  %>% select(-process_broad), col = colorRamp2(c(-5, 0, 4), c("red", "white", "blue")),
                    gap = unit(10, "mm"), show_row_names = F) + rowAnnotation(df = annot, col = list(MoA = colMap), width = unit(1, "cm"))

# OR ALSO THAT :
res = kmeans(chemGeno_mat %>% select(-process_broad), centers = 4, nstart = 100)
chemGeno_mat$clust = res$cluster
table(chemGeno_mat[, c("clust", "process_broad")])

```

```{r}
load(file = "../dbsetup/data/genesWithEG_ID.RData")

genes %>% filter(gene_synonym %in% chemogeno_fingerprint) %>% select(ugi, gene_synonym, name)
# Extract information for interaction prediction
bigMat = matrix_container[1, ]$drug_feature_matrices[[1]] %>% select(drugname_typaslab, conc, chemogeno_fingerprint)
saveRDS(bigMat, file = "data/chemGen_fingerprint_mat.rds")
```


## t-SNE

```{r}
ipak(Rtsne)

mat = full_mat %>% select(drugname_typaslab, process_broad, chemogeno_fingerprint)
mat$process_broad = as.factor(mat$process_broad)

#tsne_res = Rtsne(X = mat[, -1], dims = 3, pca = F)
tsne_res = Rtsne(X = mat[, -1], dims = 3, perplexity = 10, max_iter = 2000)

plotData = data.frame(tsne_res$Y, MoA = mat$process_broad, drug = full_mat$drugname_typaslab)
colnames(plotData)[1:3] = c("tSNE1", "tSNE2", "tSNE3")
p <- plot_ly(plotData, x = ~tSNE1, y = ~tSNE2, z = ~tSNE3, color = ~MoA, colors = c("#FF0000FF", "#80FF00FF", "#00FFFFFF" , "#8000FFFF"),
        marker = list(size = 8, line = list(color = 'rgba(0, 0, 0, 1)', width = 1.5))) %>%
        add_markers(text = ~drug) %>%
        layout(title = "Best Features",
                scene = list(xaxis = list(title = 'tSNE1'),
                        yaxis = list(title = 'tSNE2'),
                        zaxis = list(title = 'tSNE3')))
p
# =====================================================

#tsne_res = Rtsne(X = mat[, -1], dims = 2, pca = F)
tsne_res = Rtsne(X = mat[, -1], dims = 2, perplexity = 10, max_iter = 2000, pca = F)
plotData = data.frame(tsne_res$Y, MoA = mat$process_broad, drug = full_mat$drugname_typaslab)
colnames(plotData)[1:2] = c("tSNE1", "tSNE2")
plot_ly(plotData, x = ~tSNE1, y = ~tSNE2, color = ~MoA, colors = c("#FF0000FF", "#80FF00FF", "#00FFFFFF" , "#8000FFFF"),
        marker = list(size = 12, line = list(color = 'rgba(0, 0, 0, .8)', width = 1.5))) %>%
        add_markers(text = ~drug) %>%
        layout(title = "Best Features",
                scene = list(xaxis = list(title = 'tSNE1'),
                            yaxis = list(title = 'tSNE2')))

# =====================================================

mat = full_mat 
mat$process_broad = as.factor(mat$process_broad)

tsne_res = Rtsne(X = mat[, -1], dims = 3, pca = F)


plotData = data.frame(tsne_res$Y, MoA = mat$process_broad, drug = full_mat$drugname_typaslab)
colnames(plotData)[1:3] = c("tSNE1", "tSNE2", "tSNE3")
pAll <- plot_ly(plotData, x = ~tSNE1, y = ~tSNE2, z = ~tSNE3, color = ~MoA, colors = c("#FF0000FF", "#80FF00FF", "#00FFFFFF" , "#8000FFFF") ) %>%
  add_markers(text = ~drug) %>% 
  layout(title = "All Features",
      scene = list(xaxis = list(title = 'tSNE1'),
                     yaxis = list(title = 'tSNE2'),
                     zaxis = list(title = 'tSNE3')))
pAll

# =====================================================

randomFeat = sample(colnames(full_mat)[-c(1,2,3)], size = length(chemogeno_fingerprint), replace = F)
mat = full_mat %>% select(drugname_typaslab, process_broad, randomFeat)
mat$process_broad = as.factor(mat$process_broad)

tsne_res = Rtsne(X = mat[, -1], dims = 3, pca = F)


plotData = data.frame(tsne_res$Y, MoA = mat$process_broad, drug = full_mat$drugname_typaslab)
colnames(plotData)[1:3] = c("tSNE1", "tSNE2", "tSNE3")
pRandom <- plot_ly(plotData, x = ~tSNE1, y = ~tSNE2, z = ~tSNE3, color = ~MoA, colors = c("#FF0000FF", "#80FF00FF", "#00FFFFFF" , "#8000FFFF") ) %>%
  add_markers(text = ~drug) %>%
  layout(title = "Random Features",
         scene = list(xaxis = list(title = 'tSNE1'),
                     yaxis = list(title = 'tSNE2'),
                     zaxis = list(title = 'tSNE3')))
pRandom

```


## PCA visualization

```{r}

fingerprint_mat = full_mat %>% select(drugname_typaslab, process_broad, conc, chemogeno_fingerprint)
saveRDS(fingerprint_mat, file = "data/chemGen_fingerprint_mat.rds")
# Save fingerprint mat to export it in the interaction prediction notebook

m = fingerprint_mat %>% select(chemogeno_fingerprint)
pca_data <- prcomp(m, scale = TRUE)

barplot(pca_data$sdev / sum(pca_data$sdev))
var_3pca = sum((pca_data$sdev / sum(pca_data$sdev))[1:3])

plotData <- as.data.frame(pca_data$x)
plotData = cbind(plotData, process_broad = fingerprint_mat$process_broad, drugnames = fingerprint_mat$drugname_typaslab)

p <- plot_ly(plotData, x = ~PC1, y = ~PC2, z = ~PC3, color = ~process_broad, colors = c("#FF0000FF", "#80FF00FF", "#00FFFFFF" , "#8000FFFF"),
             marker = list(size = 8, line = list(color = 'rgba(0, 0, 0, 1)', width = 1.5))) %>%
            add_markers(text = ~drugnames) %>%
            layout(scene = list(xaxis = list(title = 'PC1'),
                     yaxis = list(title = 'PC2'),
                     zaxis = list(title = 'PC3')))


# MDS as well but t-SNE might be even better, in any case PCA is not the best here, for it focuses on variance

dist_mat = dist(full_mat %>% select(chemogeno_fingerprint), method = "euclidian")
mat_MDS_res = cmdscale(dist_mat, k = 3)
mat_MDS_res = as.data.frame(cbind(mat_MDS_res, full_mat$process_broad))
colnames(mat_MDS_res) = c("MDS1", "MDS2", "MDS3", "process_broad")

p <- plot_ly(mat_MDS_res, x = ~MDS1, y = ~MDS2, z = ~MDS3, color = ~process_broad, colors = c("#FF0000FF", "#80FF00FF", "#00FFFFFF", "#8000FFFF") ) %>%
    add_markers() %>%
    layout(scene = list(xaxis = list(title = 'MDS axis 1'),
                     yaxis = list(title = 'MDS axis 2'),
                     zaxis = list(title = 'MDS axis 3')))
```


## KNN test as basic learner

Now KNN models to test prediction based on that

```{r}

run_KNN = function(feat_subset = NULL, knn_k = 1, dataMat){
    
    models_knn = list()
    for (moa in c("cell_wall", "dna", "membrane_stress", "protein_synthesis")){

        input_data = dataMat
        input_data = input_data %>% mutate(process_broad = replace(process_broad, process_broad != moa, paste0("not_", moa)))
        blockFactor = as.factor(input_data$drugname_typaslab)
        
        if("conc" %in% colnames(input_data)){
            input_data = select(input_data, -conc)
        }
        if("drugname_typaslab" %in% colnames(input_data)){
            input_data = select(input_data, -drugname_typaslab)
        }
        
        if(!is.null(feat_subset)){
                input_data = input_data %>% select(process_broad, feat_subset)
        }
        predictMoa = makeClassifTask(data = input_data, target = "process_broad", blocking = blockFactor)
            
        lrn = makeLearner("classif.knn", par.vals = list(k = knn_k) )
        
        model = resample(learner = lrn, task =  predictMoa, measures = mmce, resampling = makeResampleDesc(method = "LOO", predict = "both" ))
        models_knn[[moa]] = model
    }
    return(models_knn)
}

# ==============================================================================

knn_res = list()
# Don't test with 1 cause it might be the replicate with another dosage
for(nb_knn in c(3,5,7,9,11)){
    print(length(knn_res))
    name =  as.character(length(knn_res))
    knn_res[[name]] <- run_KNN(feat_subset = chemogeno_fingerprint, knn_k = nb_knn, dataMat = full_mat)
}

a = unlist(knn_res, recursive = F)
a = lapply(a, function(x){x$aggr})

a = as.data.frame(unlist(a))
colnames(a) = "mmce"
a$moa = c("cell_wall", "dna", "membrane_stress", "protein_synthesis")
a$knn = rep(c(3,5,7,9,11), each = 4)

p1 = ggplot(data = a) + geom_line(mapping = aes(x = knn, y = mmce, color = moa), lwd = 1.5) + theme_bw() + scale_color_manual(values = rainbow(4)) + ggtitle("chemogeno_fingerprint") + theme(legend.position="bottom")+ ylim(0,0.5)


```

### Repeated Random KNN

```{r}
rand_knn_res = list()

for(i in 1:20){
    randomFeat = sample(colnames(full_mat)[-c(1,2,3)], size = length(chemogeno_fingerprint), replace = F)
    
    for(nb_knn in c(3,5,7,9,11)){
        print(length(rand_knn_res))
        name =  as.character(length(rand_knn_res))
        rand_knn_res[[name]] <- run_KNN(feat_subset = randomFeat, knn_k = nb_knn, dataMat = full_mat)
    }
}

a = unlist(rand_knn_res, recursive = F)
a = lapply(a, function(x){x$aggr})
a = as.data.frame(unlist(a))
colnames(a) = "mmce"
a$moa = c("cell_wall", "dna", "membrane_stress", "protein_synthesis")
a$knn =  rep(c(3,5,7,9,11), each = 4)

p2 = ggplot(data = a) + geom_smooth(mapping = aes(x = knn, y = mmce, colour = moa)) + theme_bw() + scale_color_manual(values = rainbow(4)) +
    ggtitle("Random repeated 20 times") + theme(legend.position="bottom") + ylim(0,0.5) 


grid.arrange(p1, p2, nrow = 1)

```



# FOCUS on best features driving the MoA

Quick look : does it make sense to use only features mentioned above ?

In each MoA there are two or three features that allow a very nice isolation of at least half of the MoA drugs

Try to clusterize using these only for all dosage and most interaction

```{r}
best_feat = c("MRCB", "SLT","TOLB","SPR","SURA","PAL","RFAF","RECC","RECA","YLCG", "SlogP", "NumAromaticRings")
best_feat_extended = c("SLT", "MRCB", "TOLB", "SPR", "SlogP", "ACRB", "GLMS", "ASMA", "RFAE", "SURA", "PAL", "RFAF", "IMP", "NAGA", "RECC", "RECA", "YCHJ", "TOLQ", "GUAB", "CYSB", "NUDB")

mat = matrix_container[2, ]$drug_feature_matrices[[1]]
mat = mat %>% select(drugname_typaslab, process_broad, best_feat)
plot_heatmap(m = mat)

# DO PCA
mat = matrix_container[2, ]$drug_feature_matrices[[1]]
m = mat %>% select(best_feat)
pca_data <- prcomp(m, scale = TRUE)

barplot(pca_data$sdev / sum(pca_data$sdev))
var_3pca = sum((pca_data$sdev / sum(pca_data$sdev))[1:3])

plotData <- as.data.frame(pca_data$x)
plotData = cbind(plotData, process_broad = mat$process_broad, drugnames = mat$drugname_typaslab)

plotData$process_broad = as.character(plotData$process_broad)
plotData$process_broad[!(plotData$process_broad %in% c("cell_wall", "dna", "membrane_stress", "protein_synthesis"))] <- "other"

p1 <- ggplot(plotData, aes(x = PC1, y = PC2)) +
geom_point(aes(fill = process_broad), shape = 21, size = 4, colour = "black") +
theme_bw() + scale_fill_manual(values=rainbow(4)) +
ggtitle(" PC 1 and 2")

p2 <- ggplot(plotData, aes(x = PC3, y = PC2)) +
geom_point(aes(fill = process_broad), shape = 21, size = 4, colour = "black") +
theme_bw() + scale_fill_manual(values=rainbow(4)) +
ggtitle(" PC 2 and 3 ")

p3 <- ggplot(plotData, aes(x = PC3, y = PC4)) +
geom_point(aes(fill = process_broad), shape = 21, size = 4, colour = "black") +
theme_bw() + scale_fill_manual(values=rainbow(4)) +
ggtitle(" PC 3 and 4 ")

p4 <- ggplot(plotData, aes(x = PC5, y = PC4)) +
geom_point(aes(fill = process_broad), shape = 21, size = 4, colour = "black") +
theme_bw() + scale_fill_manual(values=rainbow(4)) +
ggtitle(" PC 4 and 5 ")

grid.arrange(p1, p2, p4, p3, nrow = 2)


p <- plot_ly(plotData, x = ~PC1, y = ~PC2, z = ~PC3, color = ~process_broad, colors = c("#FF0000FF", "#80FF00FF", "#00FFFFFF", "black" , "#8000FFFF") ) %>%
  add_markers(text = ~drugnames) %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                     yaxis = list(title = 'PC2'),
                     zaxis = list(title = 'PC3')))

```


## MultiDimensional Scaling

Since PCA try to represent variability across individuals, it may not be the perfect tool if one want to seperate groups

Try MDS to see if there's some difference. MDS is based on the distance between individual and the algorithm try to keep the same distances when going from a N-dim space to a n-dim space (N > n)

```{r}
best_feat = c("MRCB", "SLT","TOLB","SPR","SURA","PAL","RFAF","RECC","RECA","YLCG", "SlogP")
mat = matrix_container[20, ]$drug_feature_matrices[[1]]
labels_save = mat %>% select(drugname_typaslab, process_broad)
mat = mat %>% select(best_feat)

dist_mat = dist(mat, method = "euclidian")
mat_MDS_res = cmdscale(dist_mat, k = 3)
mat_MDS_res = cbind(mat_MDS_res, labels_save)
colnames(mat_MDS_res)[1:3] = c("MDS1", "MDS2", "MDS3")

p <- plot_ly(mat_MDS_res, x = ~MDS1, y = ~MDS2, z = ~MDS3, color = ~process_broad, colors = c("#FF0000FF", "#80FF00FF", "#00FFFFFF","grey", "grey", "grey", "#8000FFFF") ) %>%
    add_markers() %>%
    layout(scene = list(xaxis = list(title = 'MDS axis 1'),
                     yaxis = list(title = 'MDS axis 2'),
                     zaxis = list(title = 'MDS axis 3')))


```


## Kmeans or KNN based on a subspace of features

Compare results of KNN in the all-feature space and limited best features space : For which MoA does it make a difference. Since we're using LOO CV, it's also easy to assesss which drugs are misclassified

```{r}
best_feat = c("MRCB", "SLT","ASMA", "GLMS","RFAE", "ACRA" ,"SURA", "PAL", "RFAF", "HFQ", "SlogP", "RECC", "RECA") 
best_feat_extended = c("SLT", "MRCB", "TOLB", "SPR", "SlogP", "ACRB", "GLMS", "ASMA", "RFAE", "SURA", "PAL", "RFAF", "IMP", "NAGA", "RECC", "RECA", "YCHJ", "TOLQ", "GUAB", "CYSB", "NUDB")


run_KNN = function(feat_subset = NULL, knn_k = 1, dataMat){
    
    models_knn = list()
    for (moa in c("cell_wall", "dna", "membrane_stress", "protein_synthesis")){

        input_data = dataMat
        input_data = input_data %>% mutate(process_broad = replace(process_broad, process_broad != moa, paste0("not_", moa)))
            
        if("drugname_typaslab" %in% colnames(input_data)){
                input_data = select(input_data, -drugname_typaslab)
            }
        if("conc" %in% colnames(input_data)){
            input_data = select(input_data, -conc)
        }
        
        if(!is.null(feat_subset)){
            if(feat_subset == "random"){
                input_data = input_data %>% select(process_broad, sample(colnames(input_data)[-1], size = length(best_feat), replace = F))
            }else{
                input_data = input_data %>% select(process_broad, feat_subset)
            }
        }
        predictMoa = makeClassifTask(data = input_data, target = "process_broad")
            
        lrn = makeLearner("classif.knn", par.vals = list(k = knn_k)) 
        model = resample(learner = lrn,task =  predictMoa, resampling = makeResampleDesc(method = "LOO", predict = "both"))
        models_knn[[moa]] = model
    }
    return(models_knn)
}

knn_res = list()

for(feat in list(NULL, best_feat_extended, best_feat, "random")){
    for(nb_knn in c(1,2,3,4,5)){
        print(length(knn_res))
        name =  as.character(length(knn_res))
        knn_res[[name]] <- run_KNN(feat_subset = feat, knn_k = nb_knn)
    }
}


a = unlist(knn_res, recursive = F)
a = lapply(a, function(x){x$aggr})

a = as.data.frame(unlist(a))
colnames(a) = "mmce"
a$moa = rep(c("cell_wall", "dna", "membrane_stress", "protein_synthesis"), times = 20)
a$knn = rep(seq(1,5), each = 4)
a$model = rep(c("all_feat_knn_", "best_feat_knn_", "best_feat_ext_knn_", "random"), each = 20)

p1 = ggplot(data = a[1:20, ]) + geom_line(mapping = aes(x = knn, y = mmce, color = moa), lwd = 1.5) + theme_bw() + scale_color_manual(values = rainbow(4)) + ggtitle("All feat") + theme(legend.position="bottom")+ ylim(0,0.4)
p2 = ggplot(data = a[21:40, ]) + geom_line(mapping = aes(x = knn, y = mmce, color = moa), lwd = 1.5) + theme_bw() + scale_color_manual(values = rainbow(4)) + ggtitle("Best feat ext") + theme(legend.position="bottom")+ ylim(0,0.4)
p3 = ggplot(data = a[41:60, ]) + geom_line(mapping = aes(x = knn, y = mmce, color = moa), lwd = 1.5) + theme_bw() + scale_color_manual(values = rainbow(4)) + ggtitle("Best feat") + theme(legend.position="bottom") + ylim(0,0.4)
p4 = ggplot(data = a[61:80, ]) + geom_line(mapping = aes(x = knn, y = mmce, color = moa), lwd = 1.5) + theme_bw() + scale_color_manual(values = rainbow(4)) + ggtitle("Random feat") + theme(legend.position="bottom") + ylim(0,0.4)

grid.arrange(p1, p2, p3,p4, nrow = 1)

```




# Features selection based on T test pvalue


```{r}

mat = matrix_container[1, ]$drug_feature_matrices[[1]]
mat = mat %>% select( -conc,  -drugname_typaslab)
allRes = c()

matTmp = as.data.frame(mat)

for( moa in c("cell_wall", "dna", "membrane_stress", "protein_synthesis")){
    res = list()
    
    for (i in colnames(matTmp)) {
        if(i != "process_broad"){
            res[[i]] = wilcox.test(matTmp[matTmp$process_broad == moa, i], matTmp[matTmp$process_broad != moa, i])$p.value
        }
    }
    res = sort(unlist(res))
    allRes = c(allRes, names(res[1:5]))
}

```



# Model surgery

Two best models for DNA in terms of AUC, almost equal but input data really different

```{r}
# line 26
rf_model1 = readRDS("run_results_from_server/matrix_container_result/rf_hyp_param_most_interactions_top20pct_TRUE.rds")

drugs_pred_prob_from_container(pred_data = matrix_container[26, ]$PredData[[1]], moa="dna" )


# line 18
rf_model2 = readRDS("run_results_from_server/matrix_container_result/rf_hyp_param_all_top5pct_TRUE.rds")

drugs_pred_prob_from_container(pred_data = matrix_container[18, ]$PredData[[1]], moa="dna" )
```

Actually line 26 is better after looking at the plots



Test with one tree. You never know...

```{r}
library(rpart)
library(rpart.plot)


misclass_drugs = list()

for (moa in c("cell_wall", "dna", "membrane_stress", "protein_synthesis")){
    input_data = matrix_container[19, ]$drug_feature_matrices[[1]]
    input_data = input_data %>% mutate(process_broad = replace(process_broad, process_broad != moa, paste0("not_", moa)))
    
    if("drugname_typaslab" %in% colnames(input_data)){
            input_data = select(input_data, -drugname_typaslab)
        }
    if("conc" %in% colnames(input_data)){
        input_data = select(input_data, -conc)
    }
    
    predictMoa = makeClassifTask(data = input_data, target = "process_broad")
    
    lrn = makeLearner("classif.rpart", par.vals = list(minsplit = 3)) 
    model = resample(learner = lrn,task =  predictMoa, resampling = makeResampleDesc(method = "LOO", predict = "both"))
    
    # With LOO classification, see which drugs don't fit in a given tree
    tough_drugs = which(model$measures.test$mmce == 1)
    input_data = matrix_container[26, ]$drug_feature_matrices[[1]]
    misclass_drugs[[moa]] = input_data$drugname_typaslab[tough_drugs]
}


# Multiclass

input_data = matrix_container[19, ]$drug_feature_matrices[[1]]
input_data = input_data %>% mutate(process_broad = replace(process_broad, !(process_broad %in% c("cell_wall", "dna", "membrane_stress", "protein_synthesis")), "other"))


if("drugname_typaslab" %in% colnames(input_data)){
    input_data = select(input_data, -drugname_typaslab)
}
if("conc" %in% colnames(input_data)){
    input_data = select(input_data, -conc)
}

predictMoa = makeClassifTask(data = input_data, target = "process_broad")

lrn = makeLearner("classif.rpart", par.vals = list(minsplit = 10)) 
model = resample(learner = lrn,task =  predictMoa, resampling = makeResampleDesc(method = "CV", predict = "both", iters = 10))


rpart.plot::rpart.plot(model$learner.model, extra = 1)
summary(model$learner.model)

# with minsplit it overfits, find a way to label individuals in each leaf

```


Plot Boosting tree : always the same gene during ~50 trees, which correpsonds to the time needed for the weight put on the misclassified individuals to be big enough to change the way the preditcion is done

```{r}
# line 40
xgb_10pc = readRDS("run_results_from_server/matrix_container_result/xgboost_hyp_param_std_all_top10pct_TRUE.rds")

input_data = matrix_container[40, ]$drug_feature_matrices[[1]]
if("drugname_typaslab" %in% colnames(input_data)){
        input_data = select(input_data, -drugname_typaslab)
    }
if("conc" %in% colnames(input_data)){
    input_data = select(input_data, -conc)
}

ipak("DiagrammeR")
a = xgb_10pc$`Nested CV 1`$`Outer fold 1`$model_dna$learner.model

ipak("DiagrammeR")
library(xgboost)

xgb.plot.tree(model = a, trees = 1:10, feature_names = colnames(input_data)[-1])
xgb.plot.tree(model = a, trees = 10:20, feature_names = colnames(input_data)[-1])


```



