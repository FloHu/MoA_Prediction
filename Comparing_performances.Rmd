---
title: "Comparing model performances"
author: "Florian Huber, Leonard Dubois"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_caption: yes
    fig_height: 6
    fig_width: 6
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
editor_options: 
  chunk_output_type: console
---

# Setup

```{r setup}
# set chunk options and load libraries, load custom functions
source("./setup.R")
resdir <- "./run_results_from_server/mc_2019"
outdir <- "./data/programmatic_output"

mc <- readRDS("./data/programmatic_output/mc.rds")
head(mics <- read_delim("./data/programmatic_output/MICs.csv", delim = ";"))
```


# Extracting information from nested CV runs 

```{r}
# old results object
# res_old <- readRDS("./run_results_from_server/matrix_container_result/rf_hyp_param_all_top10pct_FALSE.rds")
# pryr::object_size(res_old)

# new one
res_new <- readRDS(file.path(resdir, "classif.randomForest_one_FALSE.rds"))
pryr::object_size(res_new)
```

## Importing results from cluster

```{r}
mc_ext_old <- readRDS("./data/programmatic_output/matrix_container_ext_2019.rds")

mc_ext <- mc
mc_ext_path <- file.path(outdir, "mc_ext.rds")
newcols <- c("perf_measures", "pred_data", "opt_path", "opt_pars")
if (file.exists(mc_ext_path)) {
  mc_ext <- readRDS(mc_ext_path)
} else {
  mc_ext[, newcols] <- list(rep(list(NA), 4))
}

if (!file.exists(mc_ext_path)) {
  for (row in seq_len(nrow(mc_ext))) {
    gc()
    
    targetfile <- 
      select(mc_ext[row, ], fitted_model, drug_dosages, chemical_feats) %>%
      reduce(paste, sep = "_") %>% 
      paste0(".rds")
    
    stopifnot(length(targetfile) == 1)
    
    if (!(file.exists(file.path(resdir, targetfile)))) {
      cat(targetfile, ": no matching file found, continuing ...\n")
      next
    }
    
    cat("Now processing file ", targetfile, "\n")
    resobj <- readRDS(file.path(resdir, targetfile))
    
    mc_ext[row, newcols] <- 
      map(list(get_perf_measures_mcl, get_pred_data_mcl, get_opt_path, 
        get_opt_pars), function(f) list(f(resobj = resobj))) # need to wrap into list()
    
    rm(resobj)
    gc()
  }
} else {
  message("Matrix container already present.")
}

saveRDS(mc_ext, file = mc_ext_path)
```

## Parsing results objects

```{r}
# model stabilities
mc_ext$pred_stabs <- map_if(mc_ext$pred_data, is_tibble, get_pred_stabs)

# adding additional information to pred_data
m_signif_all <- readRDS("./data/programmatic_output/m_signif_all.rds")
n_ias <- 
  m_signif_all %>%
  select(-one_of("drugname_typaslab", "conc", "process_broad")) %>% 
  apply(1, sum)

ia_stats <- bind_cols(
  m_signif_all[, c("drugname_typaslab", "conc", "process_broad")], 
  n_signif = n_ias)

ia_stats <- 
  group_by(ia_stats, drugname_typaslab) %>%
  mutate(conc_rank = rank(conc), n_conc = length(conc), 
    n_signif_rank = order(order(n_signif, conc)), 
    conc_mostias = which.max(n_signif) == seq_len(n()))

saveRDS(ia_stats, file = "./data/programmatic_output/ia_stats.rds")

# add additional info to pred data
mc_ext$pred_data <- map_if(mc_ext$pred_data, is_tibble, function(.x) {
  left_join(.x, select(ia_stats, -one_of("process_broad")))
})
```

# Comparison of models

## Performances

```{r}
# Most important plots: model performances, then model stabilities
# perhaps some total confusion matrix? 
plot_perf(mc_ext = mc_ext, what = "mmce_mean", save = TRUE, 
  file = "./plots/Comparison_performance_mmce.pdf")

plot_perf(mc_ext = mc_ext, what = "kappa_mean", save = TRUE, 
  file = "./plots/Comparison_performance_kappa.pdf")

## TO DO: IMPORTANT!
# number of preselected features, chemical features etc.: these parameters 
# should perhaps be plotted against the resulting performance (equivalent of 
# old plots where we had e.g. "impact of feature_preselect")
```


```{r, include = FALSE, eval = FALSE}
## FOR POSTER -------------------------
select(mc_ext, fitted_model, drug_dosages, chemical_feats, perf_measures) %>%
  unnest() %>%
  group_by(fitted_model, drug_dosages, chemical_feats, cvrep) %>%
  summarise(mmce_mean = mean(mmce), kappa_mean = mean(kappa)) %>%
  ungroup() %>%
  mutate(drug_dosages = recode(drug_dosages, 'all' = "Use all dosages", 
    'one' = "Use dosage closest to MIC"), 
    chemical_feats = recode(as.character(chemical_feats), 
      'TRUE' = "+physchem. features", 'FALSE' = "-physchem. features")) %>%
  ggplot(aes(x = fitted_model, y = (1 - mmce_mean))) +
    stat_summary(geom = "crossbar", fun.ymin = median, fun.ymax = median, 
      fun.y = median, width = 0.4, fill = "steelblue") + 
    geom_point(position = position_jitter(width = 0.2, height = 0),
      shape = 1, size = 2) +
    facet_grid(chemical_feats ~ drug_dosages) +
    labs(y = "Performance (accuracy)", title = "Model performances") +
    scale_x_discrete("", labels = classifier_repl) +
    poster_theme + 
    theme(axis.text.x = element_text(size = 14, angle = 45, hjust = 1))

ggsave(filename = "./plots/POSTER_Comparison_performance_acc.pdf", 
  width = 155, height = 155, units = "mm", useDingbats = FALSE)

## FOR PAPER
select(mc_ext, fitted_model, drug_dosages, chemical_feats, perf_measures) %>%
  unnest() %>%
  group_by(fitted_model, drug_dosages, chemical_feats, cvrep) %>%
  summarise(mmce_mean = mean(mmce), kappa_mean = mean(kappa)) %>%
  ungroup() %>%
  mutate(drug_dosages = recode(drug_dosages, 'all' = "Use all dosages", 
    'one' = "Use dosage closest to MIC"), 
    chemical_feats = recode(as.character(chemical_feats), 
      'TRUE' = "+physchem. features", 'FALSE' = "-physchem. features")) %>%
  ggplot(aes(x = fitted_model, y = (1 - mmce_mean))) +
    stat_summary(geom = "crossbar", fun.ymin = median, fun.ymax = median, 
      fun.y = median, width = 0.5, alpha = 0.75, fill = "steelblue") + 
    geom_point(position = position_jitter(width = 0.2, height = 0),
      shape = 1, size = 1.5) +
    facet_grid(chemical_feats ~ drug_dosages) +
    labs(y = "Performance (accuracy)", title = "Comparing performances") +
    scale_x_discrete("", labels = classifier_repl) +
    paper_theme

ggsave(filename = "./plots/paper/Comparison_performance_acc.pdf", 
  width = 80, height = 75, units = "mm", useDingbats = FALSE)
```

## Stabilities

```{r}
select(mc_ext, fitted_model, drug_dosages, chemical_feats, pred_stabs) %>%
  unnest() %>%
  ggplot(aes(x = fitted_model, y = sd_of_probs)) + 
  geom_violin() + 
    facet_grid(chemical_feats ~ drug_dosages) + 
  scale_x_discrete("Classifier type", labels = classifier_repl) + 
  comparison_theme + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
    panel.grid = element_blank())

ggsave(filename = "./plots/Comparison_stabilities.pdf", width = 87, height = 80, 
  units = "mm")
```

```{r, include = FALSE, eval = FALSE}
## FOR POSTER -------------------------
select(mc_ext, fitted_model, drug_dosages, chemical_feats, pred_stabs) %>%
  unnest() %>%
  ungroup() %>%
    mutate(drug_dosages = recode(drug_dosages, 'all' = "Use all dosages", 
    'one' = "Use dosage closest to MIC"), 
    chemical_feats = recode(as.character(chemical_feats), 
      'TRUE' = "+physchem. features", 'FALSE' = "-physchem. features")) %>%
  ggplot(aes(x = fitted_model, y = sd_of_probs)) + 
  geom_point(shape = 1, alpha = 0.55, position = position_jitter(width = 0.15, height = 0)) + 
    facet_grid(chemical_feats ~ drug_dosages) + 
  geom_violin(scale = "width", draw_quantiles = 0.5, fill = NA) + 
  labs(y = "Prediction s.d. across nested CV repeats", 
    title = "Model stabilities") + 
  scale_x_discrete("", labels = classifier_repl) + 
  scale_y_continuous(breaks = c(0, 0.1, 0.2)) +
  poster_theme + 
  theme(axis.text.x = element_text(size = 14, angle = 45, hjust = 1))

ggsave(filename = "./plots/POSTER_Comparison_stabilities.pdf", width = 155, 
  height = 155, units = "mm")

## FOR PAPER
select(mc_ext, fitted_model, drug_dosages, chemical_feats, pred_stabs) %>%
  unnest() %>%
  ungroup() %>%
    mutate(drug_dosages = recode(drug_dosages, 'all' = "Use all dosages", 
    'one' = "Use dosage closest to MIC"), 
    chemical_feats = recode(as.character(chemical_feats), 
      'TRUE' = "+physchem. features", 'FALSE' = "-physchem. features")) %>%
  ggplot(aes(x = fitted_model, y = sd_of_probs)) + 
  #geom_point(shape = 1, alpha = 0.3, size = 1, position = position_jitter(width = 0.15, height = 0)) + 
  geom_boxplot(width = 0.35, outlier.shape = NA, coef = 0) + 
  geom_violin(scale = "width", fill = NA) + 
  facet_grid(chemical_feats ~ drug_dosages) + 
  labs(y = "Prediction s.d. across nested CV repeats", 
    title = "Comparing stabilities") + 
  scale_x_discrete("", labels = classifier_repl) + 
  scale_y_continuous(breaks = c(0, 0.1, 0.2)) +
  paper_theme

ggsave(filename = "./plots/paper/Comparison_stabilities.pdf", width = 80, 
  height = 75, units = "mm")
```

# Define "winning" model

As the following plots are rather a quality control for the winning/chosen 
model. 

```{r}
# mc_ext_w = "winner", i.e. the model we choose
mc_ext_w <- filter(mc_ext, fitted_model == "classif.randomForest", 
  drug_dosages == "all", !chemical_feats)

pred_data_w <- mc_ext_w$pred_data[[1]]

resobj_w <- readRDS("./run_results_from_server/mc_2019/classif.randomForest_all_FALSE.rds")
```

## Performance of winning model

Confusion matrix

```{r}
# this code is similar to get_wide_confmat()
# sum up all confusion matrices
conf_mats <- map(resobj_w, function(ncv_rep) {
  conf_mats <- map(ncv_rep, function(fold) {
    calculateConfusionMatrix(fold$prediction, )$result
  })
  return(reduce(conf_mats, `+`))
})

cm_tot <- reduce(conf_mats, `+`)
cm_tot <- data.frame(cm_tot[-nrow(cm_tot), -ncol(cm_tot)], row.names = NULL, 
  stringsAsFactors = FALSE)

cm_tot$true <- colnames(cm_tot)
cm_tot <- gather(cm_tot, -one_of("true"), key = "predicted", value = "n_obs")

cm_tot$predicted <- factor(cm_tot$predicted)
cm_tot$true <- factor(cm_tot$true, levels = rev(levels(cm_tot$predicted)))

cm_tot$byclass_recall <- 
  cm_tot$n_obs / sapply(split(cm_tot$n_obs, cm_tot$true), sum)[cm_tot$true]

cm_tot$byclass_recall <- 
  cut(cm_tot$byclass_recall, breaks = seq(from = 0, to = 1, by = 0.1), 
    labels = c("0-10%", "10-20%", "20-30%", "30-40%", "40-50%", "50-60%", 
      "60-70%", "70-80%", "80-90%", "90-100%"))

cm_tot$byclass_recall[cm_tot$true != cm_tot$predicted] <- "0-10%"
#cm_tot$byclass_recall %<>% droplevels()

## ---------------
plot_wide_confmat(cm_tot, save = TRUE, file = "./plots/Confusion_matrix_chosen.pdf")
```


```{r, include = FALSE, eval = FALSE}
## FOR POSTER -------------------------
coul = RColorBrewer::brewer.pal(9, "Blues") 
# I can add more tones to this palette :
coul = colorRampPalette(coul)(10)
# set first colour to white
coul[1] <- "#FFFFFF"

ggplot(cm_tot, aes(x = predicted, y = true)) + 
  geom_tile(aes(fill = byclass_recall)) + 
  geom_text(aes(label = n_obs)) + 
  labs(x = "Predicted", y = "Label") + 
  scale_x_discrete(position = "top", labels = moa_repl) + 
  scale_y_discrete(labels = moa_repl) + 
  scale_fill_manual("Recall by class", values = coul, drop = FALSE) + 
  poster_theme + 
  theme(legend.key.size = unit(14, "pt"))

ggsave(filename = "./plots/POSTER_ConfusionMatrix.pdf", width = 210, 
  height = 145, units = "mm")
```


```{r}
le_plots <- map(moas, possibly(plot_roc_mcl, otherwise = NULL), 
  pred_data = pred_data_w)

pdf(file = "./plots/ROC_curves.pdf", width = 3.42, height = 2.76)
grid.arrange(le_plots[[1]], le_plots[[2]], le_plots[[3]], le_plots[[4]], ncol = 2)
dev.off()
```


## QC: Inner vs. outer performances

```{r}
plot_inner_vs_outer(mc_ext = mc_ext_w, save = TRUE, 
  file = "./plots/Comparison_inner-outer.pdf")
```

## QC: Stability of optimal hyperparameter values

```{r}
# stability of optimal hyperparameter values: do independently for each 
# model
# random forests:
tmp <- mc_ext_w %>%
  select(fitted_model, drug_dosages, chemical_feats, opt_pars) %>% 
  unnest() %>%
  mutate(opt_pars_value = map(opt_pars, unlist), opt_pars_name = map(opt_pars, names)) %>%
  unnest()

tmp$opt_pars_value %<>% factor(levels = sort(c(unique(tmp$opt_pars_value), 1.0)))

## TO DO: don't know how to show empty factor level with faceted plot when 
# setting scales = "free" - to show that the fw.perc = 1 value was kept
ggplot(tmp, aes(x = opt_pars_value)) + 
  geom_bar() + 
  facet_wrap( ~ opt_pars_name, scales = "free") + 
  comparison_theme

ggsave(filename = "./plots/Comparison_hyp-param_stabs.pdf", width = 87, 
  height = 95, units = "mm")

# prediction heatmap, pseudo ROC curves, confusion matrix
# general trends of prediction quality depending on hyperparameter chosen
```

## Prediction heatmap, prediction lines

```{r}
## TO DO: change order of y-axis
plot_mcl_probs_heatmap(melt_pred_data_mcl(pred_data_w), mics = mics, 
  printplot = FALSE, save = TRUE, file = "./plots/Pred_heatmap_training.pdf")

# NEW!
## TO DO: change to lollipop chart, see 
# https://www.r-bloggers.com/geom_lollipop-by-the-chartettes/
plot_mcl_probs_heatmap2(pred_data = pred_data_w, mics = mics, 
  printplot = TRUE, save = TRUE, order_by_conf = TRUE, 
  file = "./plots/Pred_heatmap_training_conf.pdf")

# profiles to see probabilities better
plot_mcl_probs_lines(melted_pred_data = melt_pred_data_mcl(pred_data_w), 
  save = TRUE, printplot = FALSE, file = "./plots/Pred_lines_training.pdf")
```

## QC: Calibration plot

```{r}
plot_prob_calib(pred_data = pred_data_w, save = TRUE, 
  file = "./plots/Probability_calibration.pdf")
```


# Impact of hyperparameter values

```{r}
# in opt_pars column
(opt_path <- mc_ext_w$opt_path[[1]])

# reminder: 8 splits per repeat of nested CV, 10 repeats --> one combination 
# of hyperparameters was assessed 80 times
opt_path_s <- 
  opt_path %>%
  group_by(ntree, mtry, fw.perc) %>%
  summarise(mmce_mean = mean(mmce.test.mean), mmce_sd = sd(mmce.test.mean))

ggplot(opt_path_s, aes(x = factor(fw.perc), y = factor(ntree), fill = mmce_mean)) + 
  geom_raster() + 
  labs(title = "Impact of fw.perc, ntree in random forests") + 
  comparison_theme

ggsave("./plots/Hyp_param_effects_RF1.pdf", width = 87, height = 80, units = "mm")


ggplot(opt_path_s, aes(x = factor(fw.perc), y = factor(mtry), fill = mmce_mean)) + 
  geom_raster() + 
  labs(title = "Impact of fw.perc, mtry in random forests") + 
  comparison_theme

ggsave("./plots/Hyp_param_effects_RF2.pdf", width = 87, height = 80, units = "mm")

# optional: stabilities?
## TO DO: check other models, could be interesting
```


# Impact of different drug concentrations

Using all dosages is better than most_interactions. At the same 
time, it seems plausible that some dosages will be "wrong" in terms of having a 
too low drug dosage. Also, it'd be interesting to see if there is a correlation of the 
number of interactions and prediction probabilities. 

How does number of dosages distribute among the different drugs and MoA?

```{r}
m <- mc_ext_w$drug_feature_matrices[[1]]

select(m, drugname_typaslab, conc, process_broad) %>%
  group_by(drugname_typaslab, process_broad) %>%
  summarise(ndosages = n()) %>% 
  ggplot(aes(x = process_broad)) + 
    geom_bar(aes(fill = factor(ndosages)), position = "fill") + 
    labs(title = "Proportions of drugs with a given number of dosages", 
      y = "Relative fraction", x = "Mode of action")
```

Test relationship of concentration with prediction probabilities. 

```{r}
pred_data_w <- mc_ext_w$pred_data[[1]]

# steps: average probabilities over cvrep
# gather by the probability that was predicted
# remove probabilities of other MoAs
# plot conc_rank vs. probability for each MoA
# moa_predicted: means that we're only interested in the probability of the 
# actual class
tmp <- pred_data_w %>% 
  gather(prob.cell_wall:prob.protein_synthesis, key = "moa_predicted", value = "prob") %>%
  separate(col = moa_predicted, into = c(NA, "moa_predicted"), sep = "\\.") %>% 
  filter(truth == moa_predicted) %>%
  group_by(drugname_typaslab, conc, truth, n_signif, conc_rank, n_conc, 
    n_signif_rank, conc_mostias, moa_predicted) %>% 
  summarise(prob = mean(prob)) %>%
  ungroup()

# need to indicate for each drug if it is mispredicted; since there are 10 
# predictions per drug, indicate if it's never/always/sometimes mispredicted
pred_correct <- pred_data_w %>%
  select(drugname_typaslab, conc, cvrep, response, truth) %>%
  group_by(drugname_typaslab, conc) %>%
  summarise(n_correct_pred = sum(response == truth)) %>% 
  ungroup()

plot(factor(pred_correct$n_correct_pred), main = "How often is a condition 
  classified correctly?")

pred_correct$n_correct_g <- cut(pred_correct$n_correct_pred, breaks = 2, 
  labels = c("<= 5", ">= 6"))

tmp <- left_join(tmp, pred_correct)

ggplot(tmp, aes(x = factor(conc_rank), y = prob, colour = truth)) + 
  geom_point(aes(shape = n_correct_g), 
    position = position_jitter(width = 0.15, height = 0), alpha = 0.75, 
    size = 1) + 
  # geom_line(aes(group = drugname_typaslab)) + 
  stat_summary(geom = "errorbar", fun.ymin = "median", fun.ymax = "median", 
    width = 0.5, colour = "black") + 
  facet_wrap( ~ truth, ncol = 2, labeller = as_labeller(moa_repl)) + 
  labs(x = "Concentration rank", 
    y = "Mean probability for MoA for each drug", 
    title = "Probabilities vs. number of interactions") + 
  scale_colour_manual("Target process", labels = moa_repl, values = moa_cols) + 
  scale_shape_manual("Correctly predicted", labels = c("<= 50% of cases", 
    "> 50% of cases"), values = c(4, 16)) + 
  comparison_theme

ggsave("./plots/Probs_vs_conc_rank.pdf", width = 87, height = 80, units = "mm")
```


```{r}
mics <- read_delim("./data/programmatic_output/MICs.csv", delim = ";")
tmp <- left_join(tmp, mics)
tmp$frc_mic <- tmp$conc / tmp$mic_curated
tmp$log2_frc_mic <- log2(tmp$frc_mic)
tmp$log2_frc_mic_bin <- cut_number(tmp$log2_frc_mic, n = 5)

# map log2 values back to actual fractions (this is not a very good solution 
# btw):
levels(tmp$log2_frc_mic_bin)
levels_lut <- c("0.05-0.125", "0.125-0.25", "0.25-0.36", "0.36-0.5", 
  "0.5-8")
names(levels_lut) <- levels(tmp$log2_frc_mic_bin)

# how to treat NAs?
filter(tmp, !is.na(mic_curated)) %>%
ggplot(aes(x = log2_frc_mic_bin, y = prob, colour = truth)) + 
  geom_point(aes(shape = n_correct_g), 
    position = position_jitter(width = 0.15, height = 0), alpha = 0.75, 
    size = 0.75) + 
  geom_line(aes(group = drugname_typaslab), size = 0.25) + 
  stat_summary(geom = "errorbar", fun.ymin = "median", fun.ymax = "median", 
    width = 0.5, colour = "black", alpha = 0.4) + 
  facet_wrap( ~ truth, ncol = 2, labeller = as_labeller(moa_repl)) + 
  labs(x = "Fraction of MIC", 
    y = "Mean probability for MoA for each drug", 
    title = "Probabilities vs. number of interactions") + 
  scale_colour_manual("Target process", labels = moa_repl, values = moa_cols) + 
  scale_shape_manual("Correctly predicted", labels = c("<= 50% of cases", 
    "> 50% of cases"), values = c(4, 16)) + 
  comparison_theme + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  scale_x_discrete(labels = levels_lut)

ggsave("./plots/Probs_vs_MICbin_traced.pdf", width = 87, height = 80, units = "mm")


by(tmp, INDICES = tmp$truth, FUN = function(x) {
  x <- x[!is.na(x$log2_frc_mic_bin), ]
  cor.test(x = as.numeric(x$log2_frc_mic_bin), y = x$prob, method = "spearman")
})

# ---------------------------

# same as above, but with number of interactions on the x-axis
ggplot(tmp, aes(x = n_signif, y = prob, colour = truth)) + 
  geom_point(aes(shape = n_correct_g), 
    position = position_jitter(width = 0.15, height = 0), alpha = 0.75, 
    size = 1) + 
  geom_line(aes(group = drugname_typaslab), size = 0.25) + 
  facet_wrap( ~ truth, ncol = 2, labeller = as_labeller(moa_repl)) + 
  labs(x = "Number of significant interactions", 
    y = "Mean probability for MoA for each drug", 
    title = "Probabilities vs. number of interactions") + 
  scale_colour_manual("Target process", labels = moa_repl, values = moa_cols) + 
  scale_shape_manual("Correctly predicted", labels = c("<= 50% of cases", 
    "> 50% of cases"), values = c(4, 16)) + 
  comparison_theme

ggsave("./plots/Probs_vs_n_interactions.pdf", width = 87, height = 80, units = "mm")
```


```{r}
mics <- read_delim("./data/programmatic_output/MICs.csv", delim = ";")
tmp <- left_join(tmp, mics)
tmp$frc_mic <- tmp$conc / tmp$mic_curated
tmp$log2_frc_mic <- log2(tmp$frc_mic)
tmp$log2_frc_mic_bin <- cut_number(tmp$log2_frc_mic, n = 5)

# map log2 values back to actual fractions (this is not a very good solution):
# keep NA values:
levels(tmp$log2_frc_mic_bin)
# levels(tmp$log2_frc_mic_bin) <- c(levels(tmp$log2_frc_mic_bin), "NA")
# tmp$log2_frc_mic_bin[is.na(tmp$log2_frc_mic_bin)] <- "NA"

levels_lut <- c("0.05-0.125", "0.125-0.25", "0.25-0.36", "0.36-0.5", "0.5-8")
names(levels_lut) <- levels(tmp$log2_frc_mic_bin)

# how to treat NAs?
filter(tmp, !is.na(mic_curated)) %>%
ggplot(aes(x = log2_frc_mic_bin, y = prob, colour = truth)) + 
  geom_point(aes(shape = n_correct_g), 
    position = position_jitter(width = 0.15, height = 0), alpha = 0.75, 
    size = 0.75) + 
  #geom_line(aes(group = drugname_typaslab), size = 0.25) + 
  stat_summary(geom = "errorbar", fun.ymin = "median", fun.ymax = "median", 
    width = 0.5, colour = "black", alpha = 0.4) + 
  facet_wrap( ~ truth, ncol = 2, labeller = as_labeller(moa_repl)) + 
  labs(x = "Fraction of MIC", 
    y = "Mean probability for MoA for each drug", 
    title = "Probabilities vs. number of interactions") + 
  scale_colour_manual("Target process", labels = moa_repl, values = moa_cols) + 
  scale_shape_manual("Correctly predicted", labels = c("<= 50% of cases", 
    "> 50% of cases"), values = c(4, 16)) + 
  comparison_theme + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  scale_x_discrete(labels = levels_lut)

ggsave("./plots/Probs_vs_MICbin.pdf", width = 87, height = 80, units = "mm")


by(tmp, INDICES = tmp$truth, FUN = function(x) {
  x <- x[!is.na(x$log2_frc_mic_bin), ]
  cor.test(x = as.numeric(x$log2_frc_mic_bin), y = x$prob, method = "spearman")
})
```


```{r, include = FALSE, eval = FALSE}
## FOR POSTER
filter(tmp, !is.na(mic_curated)) %>%
ggplot(aes(x = log2_frc_mic_bin, y = prob, colour = truth)) + 
  stat_summary(geom = "errorbar", fun.ymin = "median", fun.ymax = "median", 
    width = 0.5, colour = "black") + 
  geom_point(aes(shape = n_correct_g), alpha = 0.8, size = 2, 
    position = position_jitter(width = 0.15, height = 0)) + 
  labs(x = "Fraction of MIC", 
    y = "Mean probability", 
    title = "Returned probabilities for MoA label", 
    subtitle = "Each point = drug X at concentration Y") + 
  facet_wrap( ~ truth, ncol = 2, labeller = as_labeller(moa_repl)) + 
  scale_colour_manual("MoA label", labels = moa_repl, values = moa_cols) + 
  scale_shape_manual("Correctly predicted", 
    labels = c("<= 50% of cases", "> 50% of cases"), values = c(4, 16)) + 
  scale_x_discrete(labels = levels_lut) + 
  poster_theme + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12))

ggsave("./plots/POSTER_Probs_vs_MICbin.pdf", width = 170, height = 155, units = "mm")
```


<!--
May want to add:
- concentration vs. number of interactions
- Prediction vs. number of interactions
- Between vs. within drug correlation of profiles
-->



<!-------------------------------------------------------------------------> 
 

```{r}
knitr::opts_chunk$set(eval = FALSE)
```




## Further investigations on chemical features

First thing to note is that there is a considerable correlation between the 
chemical featues we use for the drugs in our data set. High correlation between 
features is problematic for a number of reasons: first, they indicate redundant 
information. Second, it can lead to model instability (cf. pages 12, 46 in 
Kuhn & Johnson, 2013). 

To show how strongly the chemical features are correlated:

```{r, eval = FALSE}
tmp <- matrix_container[180, ]
stopifnot(nrow(tmp) == 1 & tmp$drug_dosages == "most_interactions" & tmp$chemical_feats)
tmp <- tmp$drug_feature_matrices[[1]]

# we have 13 chemical features
tmp_m <- select(tmp, (ncol(tmp) - 12):ncol(tmp))
tmp_m <- as.matrix(tmp_m)
row.names(tmp_m) <- tmp$drugname_typaslab
tmp_m_cor <- cor(tmp_m)

corrplot::corrplot(tmp_m_cor, method = "color", order = "hclust", tl.cex = 0.7)
corrplot::corrplot(tmp_m_cor, type = "upper", method = "number", order = "hclust", tl.cex = 0.4)
```

As can also be seen in the plot "drug_drug_similarities_RDKit.pdf" (notebook 
Misc) some of our chemical features are biased towards distinguishing 
protein_synthesis from the other features. However, number of amide bonds 
favours cell wall, number of aromatic rings might favour DNA. 

```{r, eval = FALSE}
select(tmp, drugname_typaslab, process_broad, (ncol(tmp) - 12):ncol(tmp)) %>%
   filter(process_broad %in% c("cell_wall", "dna", "protein_synthesis", "membrane_stress")) %>%
   gather(-drugname_typaslab, -process_broad, key = "chemical_feature", value = "value") %>%
   ggplot(aes(x = process_broad, y = value, colour = process_broad)) + 
      ggbeeswarm::geom_beeswarm(groupOnX = TRUE, cex = 2, shape = 1) + 
      facet_wrap( ~ chemical_feature, ncol = 5, scales = "free_y") + 
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
      labs(title = "Distribution of chemical features across MoAs")
```

Check which drugs have high number of aliphatic rings and of saturated rings. This seems to bias 
the models using chemical features towards protein synthesis. 

```{r, eval = FALSE}
tmp$drugname_typaslab[tmp$NumAliphaticRings > 2.5]
tmp$drugname_typaslab[tmp$NumSaturatedRings > 2.5]
```


# System and session info

```{r, session_info}
R.version
sessionInfo()
```
