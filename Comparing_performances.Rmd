---
title: "Comparing model performances"
author: "Florian Huber, Leonard Dubois"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_caption: yes
    fig_height: 6
    fig_width: 6
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
editor_options: 
  chunk_output_type: console
---

# Setup, library loading

This part is the general setup, whichever model we are using.

```{r setup}
# function to check if a package is installed, if so, load it, else install and then load it
source("./R/ipak.R")
# set chunk options and load libraries
source("./setup.R")
# custom functions
walk(list.files("./R", pattern = "*.R", full.names = T), source)
library(cowplot)
library(pryr)
```


# Data preparation

On the cluster, each of the rows of `matrix_container` was run; each row was a different combination 
of models, feature preselections etc and was saved in a separate results object 
(`./run_results_from_server/matrix_container_result`). Since the results objects are too big for 
putting them into `matrix_container` we will add new columns just containing the parts we are 
interested in. 

```{r}
# old matrix_container object
load("./data/matrix_container.RData")
matrix_container_old <- matrix_container

# just an example of a results object
load("./run_results_from_server/result_RF_10pc_allDrugs_tuneMMCE.RData")
example_res <- result_RF_10pc_allDrugs_tuneMMCE
rm(result_RF_10pc_allDrugs_tuneMMCE)


# ## currently used functions for plotting - there are some problems
# plot_ROC_allRep(result_RF_10pc_allDrugs_tuneMMCE, moa = "all")
# compare_ROC_2models(result_RF_10pc_allDrugs_tuneMMCE, result_RF_5pc_allDrugs_tuneMMCE, moa = "all")
# compare_ROC_models(moa = "dna", result_RF_10pc_allDrugs_tuneMMCE, result_RF_5pc_allDrugs_tuneMMCE, 
#                    result_XGBT_10pc_allDrugs_tuneMMCE)
# plot_prec_recall(result_RF_10pc_allDrugs_tuneMMCE, moa = "all")
# plot_feat_4model(result_RF_10pc_allDrugs_tuneMMCE) # improve/replace
# #plot_predProb_moa(result_RF_10pc_allDrugs_tuneMMCE, dt_matrix = container_test$drug_feature_matrices[[1]]) # doesn' work like that
# plot_ROC_optThres(result_RF_10pc_allDrugs_tuneMMCE) # make customisable
# #distrib_drug_prob(result_RF_10pc_allDrugs_tuneMMCE, drug = "A22", dt_matrix = container_test$drug_feature_matrices[[1]]) # also not working


##################################################
##### ROUTINE TO READ IN ALL RESULTS OBJECTS #####
##################################################

# What follows is a loop to extract information from our results objects and adding this into 
# new columns. Since this takes some time, it's written in a way that the matrix_container can be 
# updated. 

# results we already have
if (file.exists("./data/matrix_container_withextractions.rds")) {
   matrix_container <- readRDS("./data/matrix_container_withextractions.rds")
   matrix_container.bak <- matrix_container
   matrix_container <- matrix_container.bak
} else {
   matrix_container$hyperparam_grid_name <- names(matrix_container$hyperparam_grid)
   matrix_container$ThreshVsPerfData <- list(NA)
   matrix_container$PredData <- list(NA)
}

# available results files
available_files <- list.files("./run_results_from_server/matrix_container_result/")
moas <- c("dna", "cell_wall", "protein_synthesis", "membrane_stress")

# loop to read in results files
for (rownum in seq_len(nrow(matrix_container))) {
   matrix_container_row <- matrix_container[rownum, ]
   # look for a file corresponding to a row
   targetfile <- paste(unlist(matrix_container_row[, c("hyperparam_grid_name", "drug_dosages", "feat_preselect", "chemical_feats")]), collapse = "_")
   targetfile <- paste0(targetfile, ".rds")
   my_match <- available_files[available_files == targetfile]
   
   # check if values are not defined: if yes: check if matching file exists or continue
   # if values are already defined means we parsed a corresponding results object previously so we 
   # can continue
   if ( any(is.na(unlist(matrix_container_row[, c("ThreshVsPerfData", "PredData")]))) ) {
      if (length(my_match) > 0) {
         cat("Match for unpopulated row ", rownum, "\t==>\t", my_match, "\n", sep = "")
      } else {
         cat("Didn't find a match for line ", rownum, ", continuing to next line.\n", sep = "")
         # warning("Didn't find a match for line ", rownum) # this doesn't work - no clue why - use cat()
         next
      }
   } else {
      cat("Row ", rownum, " already populated, continuing to next line.\n")
      next
   }
   
   resultsobj <- readRDS(paste0("./run_results_from_server/matrix_container_result/", my_match))
   
   # extract ThreshVsPerfData and prediction object data using some custom functions
   matrix_container$ThreshVsPerfData[[rownum]] <- map_dfr(moas, prediction_merger, res = resultsobj, extractorfunc = perf_extractor)
   
   # get prediction data, add drug name information and concentration
   pred_data <- map_dfr(moas, prediction_merger, res = resultsobj, extractorfunc = pred_extractor)
   pred_data$drugname_typaslab <- (matrix_container_row$drug_feature_matrices[[1]])$drugname_typaslab[pred_data$id]
   pred_data$conc <- (matrix_container_row$drug_feature_matrices[[1]])$conc[pred_data$id]
   matrix_container$PredData[[rownum]] <- pred_data
}

#  update
saveRDS(matrix_container, file = "./data/matrix_container_withextractions.rds")
```


# Data analyses

The aim here is to get a general idea of which models perform well, how stable they are etc. 


## Distribution of probabilities, aka 'ultimate plot' 

Ultimate plot function, recode in ggplot because I'm a base plot noob :). First need to add some 
more things though.

```{r}
## !!! matrix_container_ext = matrix_container with more information
matrix_container_ext <- matrix_container[!is.na(matrix_container$PredData), ]

# we need a drug feature matrix for some of our annotations
drug_feature_matrix <- 
   filter(matrix_container, drug_dosages == "most_interactions", feat_preselect == "keepall", 
          chemical_feats == FALSE, fitted_model == "classif.randomForest") %>%
   pull(drug_feature_matrices) %>%
   map_dfr(identity)

stopifnot(nrow(drug_feature_matrix) < 100)

# add process_broad to each prediction data frame
matrix_container_ext$PredData <- 
   map2(matrix_container_ext$PredData, matrix_container_ext$drug_feature_matrices, function(.x, .y) {
      # get process_broad (moa) for each drug
      .x$process_broad <- .y$process_broad[.x$id] 
      return(.x)
   })

# beware! dosage with "most interactions" refers to the "keepall" features, as we can see here:
nrow(
   filter(matrix_container, drug_dosages == "most_interactions") %>%
   pull(drug_feature_matrices) %>%
   map_dfr(~ .x[, c("drugname_typaslab", "conc")]) %>%
   distinct()
)

# reference data frame from which we get the information which dosage has most interactions
most_interactions <- drug_feature_matrix[, c("drugname_typaslab", "conc")]

# add a column indicating which dosage is the one with most interactions
# also, replace moas not being "dna", "cell_wall", "membrane_stress", or "protein_synthesis" with "other"
matrix_container_ext$PredData <- 
   map(matrix_container_ext$PredData, function(.x) {
      # make vector indicating if the current concentration is the one with most interactions by temporary joining with our reference data frame
      conc_mostias <- 
         select(.x, drugname_typaslab, conc) %>%
         left_join(most_interactions, by = c("drugname_typaslab" = "drugname_typaslab"), suffix = c(".origin", ".mostias")) %>%
         mutate(conc.origin.is.mostias = (conc.origin == conc.mostias)) %>%
         pull(conc.origin.is.mostias)
      .x$conc_mostias <- conc_mostias
      .x$process_broad <- ifelse(.x$process_broad %in% c("dna", "cell_wall", "membrane_stress", "protein_synthesis"), 
                                 .x$process_broad, 
                                 "other")
      return(.x)
   })

# sanity check
stopifnot(length(unique(matrix_container_ext$PredData[[1]]$drugname_typaslab)) == sum(matrix_container_ext$PredData[[1]]$conc_mostias)/40)
```

Ultimate plot with ggplot. Don't do this for all the models, it would become too big. Rather, feed 
the row you want to have the ulimate plot for into the function. 

```{r}
# Let's start with 2 ultimate plots for now: random forests, keepall, no chemical features, all dosages
# (what we discussed with Nassos)
# other stuff to come later
tmp <- filter(matrix_container_ext, feat_preselect == "keepall", chemical_feats == FALSE, 
              fitted_model == "classif.randomForest", drug_dosages == "all")

ultimate_plot_new(tmp, filename = "./plots/ultimate_plot_RF_keepall_alldosages.pdf")

## Leonard:
# This give all information for ultimate plot for a given drug. Just have to compute the desc threshold
# tmp2 %>% filter(id ==1)
# GEnerate thresholdPerf value not by concatenating thresholdPerf values but by appling thresholdPerf function to a concatenation of prediction
# tmp2 %>% filter(moa_modelled == "dna") %>% `[`(1:5) %>% head()
```





What to do with the different prediction folds? 

```{r}
# plan:
# 1.: to get a global overview we want to plot: ROC curves for each repeat of the nested CV
# 2.: similarly: we want the individual AUCs (for each repeat) and the overall AUC (apparently it's not the average - ?)
# 3.: we might want to select partial ROC curves: again, only discriminate by repetition, not by fold
# 4.: therefore, we'll work by concatenating the prediction objects and calculating the performances (--> ROCR) as well as plotting our functions
# 5.: from 1-4 we can plot the same distribution like for the 'model stabilities' (combine code perhaps) - extension perhaps later


## Option 1: get all the aucs from each outer fold and average
## let's take first repetition of first line of matrix_container as an example 
example_res <- readRDS("./run_results_from_server/matrix_container_result/rf_hyp_param_all_keepall_FALSE.rds")
pred_data_tmp <- matrix_container_ext$PredData[[1]]
threshvsperf_data_tmp <- matrix_container_ext$ThreshVsPerfData[[1]]

aucs <- map_dbl(example_res$`Nested CV 1`, function(.x) {
   performance(.x[["prediction_dna"]], measures = auc)
})

aucs
mean(aucs)

# how does this compare with a concatenated prediction fold? 
predobj <- example_res$`Nested CV 1`$`Outer fold 1`$prediction_dna
predobj$data <- map_dfr(example_res$`Nested CV 1`, function(.x) {
   .x[["prediction_dna"]][["data"]]
})
mlr::performance(predobj, measures = auc)

# ROCR package:
predobj_rocr <- mlr::asROCRPrediction(predobj)
ROCR::performance(predobj_rocr, "auc")@y.values
# can also 

measureAUC(probabilities = predobj$data$prob.dna, truth = predobj$data$truth, 
           negative = "not_dna", positive = "dna")

pred_data_tmp_dna <- pred_data_tmp[pred_data_tmp$moa_modelled == "dna", ]
measureAUC(probabilities = pred_data_tmp_dna$prob.moa, truth = pred_data_tmp_dna$truth, 
           negative = "not_dna", positive = "dna")

computeAUC(threshvsperf_data_tmp[threshvsperf_data_tmp$moa_modelled == "dna", ])

# plan: extract these measures into a separate column to get a better overview
# at the same time, can use this to annotate ggplots of ROC curves

```


Assess average variability ('stability') of predictions. 

```{r}
# we'll focus on models with just one dosage and no chemical features, take an example: 
stability_tst <- 
   filter(matrix_container, drug_dosages == "most_interactions", feat_preselect == "keepall", 
          chemical_feats == FALSE, fitted_model == "classif.randomForest") %>%
   select(PredData)
stability_tst <- stability_tst$PredData[[1]]

# the following will compute the average standard deviation
# 3120 rows = 78 drugs, modelled 4 times, 10 repeats
# function for getting average sd - focus only on case where moa_modelled = moa_actual
stability_tst %>%
   filter(truth == moa_modelled) %>% # only focus on these cases
   group_by(drugname_typaslab) %>% # get a variance for each drug
   summarise(moa = unique(truth), prob.moa_var = var(prob.moa)) %>%
   ungroup() %>%
   group_by(moa) %>%
   summarise(prob.moa_overall_sd = sqrt(mean(prob.moa_var)))

# turn into a function:
get_avg_sds <- function(predDataObj) {
   # take prediction data and compute the average standard deviation of the prediction probabilities 
   # across a whole mode of action
   avg_sd_by_moa <- 
      predDataObj %>%
      filter(truth == moa_modelled) %>% # only focus on these cases
      group_by(drugname_typaslab) %>% # get a variance for each drug
      summarise(moa = unique(truth), prob.moa_sd = sd(prob.moa)) %>%
      ungroup() %>%
      group_by(moa) %>%
      summarise(prob.moa_avg_sd = mean(prob.moa_sd))
   return(avg_sd_by_moa)
}



# STEP 1: we'll focus only on models with one dosage and no chemical features; then we'll 
# take feat_preselect, fitted_model and hyperparam_grid as factors across which to compare 
foo <- 
   matrix_container %>%
   filter(drug_dosages == "most_interactions", chemical_feats == FALSE, !is.na(PredData)) %>%
   select(drug_dosages, feat_preselect, chemical_feats, fitted_model, hyperparam_grid_name, PredData) %>%
   mutate(avg_sds = map(PredData, get_avg_sds)) %>%
   select(-PredData) %>%
   unnest()
# stuff that doesn't work, no idea why
   # #group_by(fitted_model, hyperparam_grid_name, feat_preselect) %>%
   # rowwise() %>%
   # mutate(bla = get_avg_sds(PredData))
   # do(get_avg_sds(.[["PredData"]]))# 
   # mutate(avg_sds = (get_avg_sds(.data[["PredData"]])))

# get ordering right of feat_preselect
foo$feat_preselect <- factor(foo$feat_preselect, levels = c("top5pct", "top10pct", "top15pct", 
                                                            "top20pct", "top25pct", "top30pct", 
                                                            "top40pct", "top50pct", "keepall"))

p <- 
   ggplot(foo, aes(x = moa, y = prob.moa_avg_sd)) + 
   geom_point(position = position_jitterdodge(jitter.width = 0.0), aes(colour = feat_preselect), cex = 2) + 
   geom_vline(xintercept = c(1.5, 2.5, 3.5), linetype = "dotted") + 
   facet_grid(fitted_model ~ .) + 
   labs(x = "Mode of action modelled", y = "Average standard deviation per model", 
        title = "Stabilities of MoA predictions") + 
   scale_colour_manual("Feature\npreselection", values = c("#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", 
                                                           "#a6dba0", "#c7eae5", "#80cdc1", "#35978f", 
                                                           "#01665e"))
p

ggsave(filename = "./plots/Model_Stabilities.pdf", plot = p)
```
















